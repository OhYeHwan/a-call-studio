<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제39장 DBMS_SQL</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbPSM 참조 안내서"/><link rel="up" href="index.html" title="Tibero tbPSM 참조 안내서"/><link rel="prev" href="chap_dbms_sph.html" title="제38장 DBMS_SPH"/><link rel="next" href="chap_dbms_sqltune.html" title="제40장 DBMS_SQLTUNE"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제39장 DBMS_SQL</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chap_dbms_sph.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chap_dbms_sqltune.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chap_dbms_sql"/>제39장 DBMS_SQL</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chap_dbms_sql.html#d5e14685">39.1. 개요</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#d5e14711">39.2. 타입</a></span></dt><dd><dl><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_DESC_REC">39.2.1. DESC_REC</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_DESC_REC2">39.2.2. DESC_REC2</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_DESC_TAB">39.2.3. DESC_TAB</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_DESC_TAB2">39.2.4. DESC_TAB2</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_VARCHAR2A">39.2.5. VARCHAR2A</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_DATE_TABLE">39.2.6. DATE_TABLE</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_NUMBER_TABLE">39.2.7. NUMBER_TABLE</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_VARCHAR2_TABLE">39.2.8. VARCHAR2_TABLE</a></span></dt></dl></dd><dt><span class="section"><a href="chap_dbms_sql.html#d5e14840">39.3. 프러시저</a></span></dt><dd><dl><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_BIND_ARRAY">39.3.1. BIND_ARRAY</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_BIND_VARIABLE">39.3.2. BIND_VARIABLE</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_CLOSE_CURSOR">39.3.3. CLOSE_CURSOR</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_COLUMN_VALUE">39.3.4. COLUMN_VALUE</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_DEFINE_COLUMN">39.3.5. DEFINE_COLUMN</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_DESCRIBE_COLUMNS">39.3.6. DESCRIBE_COLUMNS</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_DESCRIBE_COLUMNS2">39.3.7. DESCRIBE_COLUMNS2</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_PARSE">39.3.8. PARSE</a></span></dt></dl></dd><dt><span class="section"><a href="chap_dbms_sql.html#d5e15330">39.4. 함수</a></span></dt><dd><dl><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_EXECUTE">39.4.1. EXECUTE</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_EXECUTE_AND_FETCH">39.4.2. EXECUTE_AND_FETCH</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_FETCH_ROWS">39.4.3. FETCH_ROWS</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_OPEN_CURSOR">39.4.4. OPEN_CURSOR</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_IS_OPEN">39.4.5. IS_OPEN</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_LAST_ERROR_POSITION">39.4.6. LAST_ERROR_POSITION</a></span></dt><dt><span class="section"><a href="chap_dbms_sql.html#DBMS_SQL_LAST_ROW_COUNT">39.4.7. LAST_ROW_COUNT</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 DBMS_SQL 패키지의 기본 개념과 패키지 내의 프러시저와 함수를 사용하는 방법을 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e14685"/>39.1. 개요</h2></div></div></div>
    

    <p><span><strong class="guibutton">DBMS_SQL</strong></span><a id="d5e14689" class="indexterm"/>은 PSM으로 데이터 조작어(DML: Data Manipulation Language, 이하 DML),
    데이터 정의어(DDL: Data Definition Language) 등 Dynamic SQL 문장을 사용하기 위한
    패키지이다.</p>

    <p>Dynamic SQL 문장<a id="d5e14693" class="indexterm"/>은 PSM의 소스 안에 SQL 문장을 직접 사용하지 않고 나중에 PSM을 실행할 때, 문자열로 전달하여
    파싱되는 SQL 문장을 말한다. 따라서 PSM을 생성할 때 존재하지 않았던 테이블에 대해 SELECT를 실행할 수도 있고,
    CREATE TABLE, DROP TABLE 등의 DDL 문장도 수행할 수 있다.</p>

    <p>DBMS_SQL 패키지로 Dynamic SQL 문장을 실행하는 과정은 다음과 같다.</p>

    <div class="orderedlist"><ol type="1" compact="compact"><li>
        <p>OPEN_CURSOR 함수를 이용하여 커서를 열고, 커서 ID를 얻는다.</p>
      </li><li>
        <p>커서를 구분하기 위해 앞에서 얻은 커서 ID를 다른 함수의 파라미터로 전달한다.</p>
      </li><li>
        <p>Dynamic SQL 문장을 파싱하기 위해 PARSE 함수를 호출한다. 만약 실행할 Dynamic SQL 문장 안에
        바인드해야 할 변수가 있는 경우 BIND_VARIABLE 함수를 호출해 변수를 바인드한다.</p>
      </li><li>
        <p>실행 결과를 가져오기 전에 결과 컬럼의 타입을 정의하기 위해 DEFINE_COLUMN 함수를 호출한다.</p>
      </li><li>
        <p>EXECUTE 함수를 이용하여 파싱된 SQL 문장을 실행한다.</p>
      </li><li>
        <p>실행한 결과를 fetch하기 위해 FETCH_ROWS 함수를 실행한다. fetch한 결과를 원하는 변수로 가져오기
        위해서는 COLUMN_VALUE 함수를 호출한다.</p>
      </li><li>
        <p>모든 수행을 끝낸 후 커서를 종료하기 위해 CLOSE_CURSOR 함수를 실행한다.</p>
      </li></ol></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e14711"/>39.2. 타입</h2></div></div></div>
    

    <p>본 절에서는 DBMS_SQL 패키지에 제공하는 별도 정의된 타입들을 알파벳 순으로 설명한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_DESC_REC"/>39.2.1. DESC_REC<a id="d5e14716" class="indexterm"/></h3></div></div></div>
      

      <p>DESCRIBE_COLUMNS 프러시저<a id="d5e14720" class="indexterm"/>를 통해서 컬럼 정보들을 가져올 때 사용되는 DESC_TAB 타입<a id="d5e14722" class="indexterm"/>의 구성 요소들의 타입이다.</p>

      <div class="literallayout"><p/></div>

      <p>DESC_REC 타입<a id="d5e14726" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">TYPE DESC_REC IS RECORD 
(
    col_type             binary_integer,
    col_max_len          binary_integer,
    col_name             varchar2(32)  ,
    col_name_len         binary_integer,
    col_schema_name      varchar2(32)  ,
    col_schema_name_len  binary_integer,
    col_precision        binary_integer,
    col_scale            binary_integer,
    col_charsetid        binary_integer,
    col_charsetform      binary_integer,
    col_null_ok          boolean
);</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_DESC_REC2"/>39.2.2. DESC_REC2<a id="d5e14734" class="indexterm"/></h3></div></div></div>
      

      <p>DESCRIBE_COLUMNS2 프러시저<a id="d5e14738" class="indexterm"/>를 통해서 컬럼 정보들을 가져올 때 사용되는 DESC_TAB2 타입<a id="d5e14740" class="indexterm"/>의 구성 요소들의 타입이다.</p>

      <div class="literallayout"><p/></div>

      <p>DESC_REC2 타입<a id="d5e14744" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">TYPE DESC_REC2 IS RECORD 
(
    col_type             binary_integer,
    col_max_len          binary_integer,
    col_name             varchar2(32767),
    col_name_len         binary_integer,
    col_schema_name      varchar2(32), 
    col_schema_name_len  binary_integer,
    col_precision        binary_integer,
    col_scale            binary_integer,
    col_charsetid        binary_integer,
    col_charsetform      binary_integer,
    col_null_ok          boolean);
);</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_DESC_TAB"/>39.2.3. DESC_TAB<a id="d5e14752" class="indexterm"/></h3></div></div></div>
      

      <p>DESCRIBE_COLUMNS 프러시저<a id="d5e14756" class="indexterm"/>를 통해서 컬럼 정보들을 가져올 때 사용되는 배열 타입이다.</p>

      <div class="literallayout"><p/></div>

      <p>DESC_TAB 타입<a id="d5e14760" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">TYPE DESC_TAB IS TABLE OF DESC_REC INDEX BY BINARY_INTEGER;</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_DESC_TAB2"/>39.2.4. DESC_TAB2<a id="d5e14768" class="indexterm"/></h3></div></div></div>
      

      <p>DESCRIBE_COLUMNS2 프러시저<a id="d5e14772" class="indexterm"/>를 통해서 컬럼 정보들을 가져올 때 사용되는 배열 타입이다.</p>

      <div class="literallayout"><p/></div>

      <p>DESC_TAB2 타입<a id="d5e14776" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">TYPE DESC_TAB2 IS TABLE OF DESC_REC2 INDEX BY BINARY_INTEGER;</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_VARCHAR2A"/>39.2.5. VARCHAR2A<a id="d5e14784" class="indexterm"/></h3></div></div></div>
      

      <p>VARCHAR2 타입 데이터로 구성된 테이블 타입이다. DBMS_SQL.PARSE 프러시저에서 긴 SQL문장을 넣을때
      사용된다.<a id="d5e14788" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>VARCHAR2A 타입의 세부 내용은 다음과 같다.<a id="d5e14792" class="indexterm"/></p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">TYPE VARCHAR2A IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_DATE_TABLE"/>39.2.6. DATE_TABLE<a id="d5e14800" class="indexterm"/></h3></div></div></div>
      

      <p>DATE 타입 데이터로 구성된 테이블 타입이다.</p>

      <div class="literallayout"><p/></div>

      <p>DATE_TABLE 타입의 세부 내용은 다음과 같다.<a id="d5e14806" class="indexterm"/></p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">TYPE DATE_TABLE IS TABLE OF DATE INDEX BY BINARY_INTEGER;</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_NUMBER_TABLE"/>39.2.7. NUMBER_TABLE<a id="d5e14814" class="indexterm"/></h3></div></div></div>
      

      <p>NUMBER 타입 데이터로 구성된 테이블 타입이다.</p>

      <div class="literallayout"><p/></div>

      <p>NUMBER_TABLE 타입의 세부 내용은 다음과 같다.<a id="d5e14820" class="indexterm"/></p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">TYPE NUMBER_TABLE IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_VARCHAR2_TABLE"/>39.2.8. VARCHAR2_TABLE<a id="d5e14828" class="indexterm"/></h3></div></div></div>
      

      <p>VARCHAR2 타입 데이터로 구성된 테이블 타입이다.</p>

      <div class="literallayout"><p/></div>

      <p>VARCHAR2_TABLE 타입의 세부 내용은 다음과 같다.<a id="d5e14834" class="indexterm"/></p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">TYPE VARCHAR2_TABLE IS TABLE OF VARCHAR2(4000) INDEX BY BINARY_INTEGER;</pre>
        </li></ul></div>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e14840"/>39.3. 프러시저</h2></div></div></div>
    

    <p>본 절에서는 DBMS_SQL 패키지에서 제공하는 프러시저를 알파벳 순으로 설명한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_BIND_ARRAY"/>39.3.1. BIND_ARRAY<a id="d5e14845" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서의 SQL 문장에서 콜론(:)으로 시작하는 변수에 값들의 집합을 설정해주는 프러시저이다. 변수의 값이 모두
      설정되지 않은 상태로 EXECUTE 함수를 호출하면 예외가 발생한다. 변수는 이름으로 찾을 수 있으므로, SQL 문장 내의
      변수이름과 파라미터로 주어진 이름을 동일하게 호출해야 한다.</p>

      <p>BIND_ARRAY 프러시저는 테이블에 동시에 여러 로우를 삽입, 삭제, 변경하는 용도로 활용된다.</p>

      <div class="literallayout"><p/></div>

      <p>BIND_ARRAY 프러시저<a id="d5e14852" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <p>BIND_ARRAY 프러시저는 설정할 변수의 타입에 따라 중복으로 선언(overloading)되어
          있다.</p>

          <p>해당되는 타입으로는 NUMBER, VARCHAR2, DATE의 인덱스 기반 테이블 타입이 있다.</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>NUMBER_TABLE</p>

              <pre class="programlisting">PROCEDURE BIND_ARRAY
(
    c        IN     INTEGER, 
    name     IN     VARCHAR2, 
    n_tab    IN     NUMBER_TABLE [, 
             index1   IN     PLS_INTEGER, 
             index2   IN     PLS_INTEGER]
); </pre>
            </li><li>
              <p>VARCHAR2_TABLE</p>

              <pre class="programlisting">PROCEDURE BIND_ARRAY
(
    c        IN     INTEGER, 
    name     IN     VARCHAR2, 
    n_tab    IN     VARCHAR2_TABLE [, 
             index1   IN     PLS_INTEGER, 
             index2   IN     PLS_INTEGER]
);</pre>
            </li><li>
              <p>DATE_TABLE</p>

              <pre class="programlisting">PROCEDURE BIND_ARRAY
(
     c        IN     INTEGER, 
     name     IN     VARCHAR2, 
     n_tab    IN     DATE_TABLE [, 
              index1   IN     PLS_INTEGER, 
              index2   IN     PLS_INTEGER]
);</pre>
            </li></ul></div>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr><tr><td align="left">name</td><td>SQL 문장 내의 변수의 이름이다. 이름에서 첫 문자 콜론(:)은 생략해도 된다.</td></tr><tr><td align="left">n_tab</td><td>SQL 문장 내의 변수에 설정할 값들의 집합 변수이다.</td></tr><tr><td align="left">index1</td><td>이 파라미터를 사용할 경우 인덱스 기반 테이블 내 바인딩할 영역의 시작점을 지정한다. ( ≥
                  1)</td></tr><tr><td align="left">index2</td><td>이 파라미터를 사용할 경우 인덱스 기반 테이블 내 바인딩할 영역의 끝점을 지정한다. ( ≥
                  index1)</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p><pre class="programlisting">DECLARE
    stmt VARCHAR2(200);
    deptno_array DBMS_SQL.NUMBER_TABLE;
    name_array DBMS_SQL.VARCHAR2_TABLE;
    c NUMBER;
    dummy NUMBER;
begin
    deptno_array(1) := 10; 
    deptno_array(2) := 20;
    deptno_array(3) := 30; 
    deptno_array(4) := 40;
    deptno_array(5) := 50; 
    deptno_array(6) := 60;
    name_array(1) := 'Architecture';
    name_array(2) := 'Frontend';
    name_array(3) := 'Core';
    name_array(4) := 'Management';
    name_array(5) := 'QMS';
    name_array(6) := 'Technical Support';

    stmt := 'insert into dept values(:deptno, :name)';
    c := DBMS_SQL.OPEN_CURSOR;

    DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
    DBMS_SQL.BIND_ARRAY(c, ':deptno', deptno_array);
    DBMS_SQL.BIND_ARRAY(c, ':name', name_array, 2, 5);
    dummy := DBMS_SQL.EXECUTE(c);

    DBMS_SQL.CLOSE_CURSOR(c); 
END;
/</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_BIND_VARIABLE"/>39.3.2. BIND_VARIABLE<a id="d5e14899" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서의 SQL 문장에서 콜론(:)으로 시작하는 변수에 값을 설정해주는 프러시저이다. 변수의 값이 모두 설정되지
      않은 상태로 EXECUTE 함수를 호출하면 예외가 발생한다. 변수는 이름으로 찾을 수 있으므로, SQL 문장 내의 변수이름과
      파라미터로 주어진 이름을 동일하게 호출해야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>BIND_VARIABLE 프러시저<a id="d5e14905" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <p>BIND_VARIABLE 프러시저는 설정할 변수의 타입에 따라 중복으로 선언(overloading)되어
          있다.</p>

          <p>해당되는 타입으로는 NUMBER, VARCHAR2, DATE, TIMESTAMP, INTERVAL,
          BINARY_FLOAT, BINARY_DOUBLE, CLOB, BLOB이 있다.</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>NUMBER</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c      IN   INTEGER, 
    name   IN   VARCHAR2, 
    value  IN   NUMBER
); </pre>
            </li><li>
              <p>VARCHAR2</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c      IN   INTEGER, 
    name   IN   VARCHAR2, 
    value  IN   VARCHAR2[, OUT_VALUE_SIZE IN INTEGER]
);</pre>
            </li><li>
              <p>DATE</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c      IN   INTEGER, 
    name   IN   VARCHAR2, 
    value  IN   DATE
);</pre>
            </li><li>
              <p>TIMESTAMP</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c       IN   INTEGER, 
    name    IN   VARCHAR2, 
    value   IN   TIMESTAMP_UNCONSTRAINED
);</pre>
            </li><li>
              <p>INTERVAL</p><pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    C       IN   INTEGER, 
    NAME    IN   VARCHAR2, 
    VALUE   IN   YMINTERVAL_UNCONSTRAINED
);</pre><pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c       IN   INTEGER, 
    name    IN   VARCHAR2, 
    value   IN   DSINTERVAL_UNCONSTRAINED
);</pre>
            </li><li>
              <p>BINARY_FLOAT</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c       IN   INTEGER, 
    name    IN   VARCHAR2, 
    value   IN   BINARY_FLOAT
);</pre>
            </li><li>
              <p>BINARY_DOUBLE</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c       IN   INTEGER, 
    name    IN   VARCHAR2, 
    value   IN   BINARY_DOUBLE
);</pre>
            </li><li>
              <p>CLOB</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c       IN   INTEGER, 
    name    IN   VARCHAR2, 
    value   IN   CLOB
);</pre>
            </li><li>
              <p>BLOB</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE
(
    c       IN   INTEGER, 
    name    IN   VARCHAR2, 
    value   IN   BLOB
);</pre>
            </li></ul></div>

          <p>CHAR, RAW, ROWID 타입을 위해서는 별도의 프러시저를 사용해야 한다.</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>CHAR</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE_CHAR
(
    c      IN   INTEGER, 
    name   IN   VARCHAR2,
    value  IN   CHAR[, out_value_size IN INTEGER]
);</pre>
            </li><li>
              <p>RAW</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE_RAW
(
    c      IN   INTEGER, 
    name   IN   VARCHAR2,
    value  IN   RAW[, out_value_size IN INTEGER]
);</pre>
            </li><li>
              <p>ROWID</p>

              <pre class="programlisting">PROCEDURE BIND_VARIABLE_ROWID
(
    c      IN   INTEGER, 
    name   IN   VARCHAR2,
    value  IN   ROWID
);</pre>
            </li></ul></div>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr><tr><td align="left">name</td><td>SQL 문장 내의 변수의 이름이다. 이름에서 첫 문자 콜론(:)은 생략해도 된다.</td></tr><tr><td align="left">value</td><td>SQL 문장 내의 변수에 설정할 변수이다.</td></tr><tr><td align="left">out_value_size</td><td>지원되지 않는 기능이므로 값을 무시한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p><pre class="programlisting">DECLARE 
    csr INTEGER;
    x NUMBER := 1;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'select :var from dual', dbms_sql.native); 

    DBMS_SQL.BIND_VARIABLE(csr, 'var', x); 

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_CLOSE_CURSOR"/>39.3.3. CLOSE_CURSOR<a id="d5e14979" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서를 닫고, NULL로 설정하는 프러시저이다.</p>

      <div class="literallayout"><p/></div>

      <p>CLOSE_CURSOR 프러시저<a id="d5e14985" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p><pre class="programlisting">PROCEDURE CLOSE_CURSOR
(
    c IN OUT INTEGER
);</pre>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서를 닫은 후에 NULL로 설정한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p><pre class="programlisting">DECLARE 
    csr INTEGER := DBMS_SQL.OPEN_CURSOR(); 
BEGIN
    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_COLUMN_VALUE"/>39.3.4. COLUMN_VALUE<a id="d5e15009" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서에서 fetch한 컬럼의 값을 원하는 변수로 가져오는 프러시저이다. 실제 fetch는 FETCH_ROWS
      함수에서 일어나고, COLUMN_VALUE 프러시저는 fetch한 후 데이터를 가져오는 데 사용된다.</p>

      <p>이때 DEFINE_COLUMN의 column 파라미터와 COLUMN_VALUE의 value 파라미터가 동일한 타입을
      가지도록 함수를 호출해야 한다. 예를 들어 column 파라미터가 NUMBER인 DEFINE_COLUMN 프러시저를 호출했다면,
      COLUMN_VALUE 또한 value 파라미터의 타입이 NUMBER인 프러시저를 호출해야 한다.</p>

      <p>동일한 이름으로 타입에 따라 중복으로 선언된 프러시저가 많으므로, 암시적 타입 변환을 고려하여 주의 깊게 사용해야
      한다. 이는 변수의 실제 타입이 같아야 하는 것이 아니라, 호출된 함수의 파라미터의 타입이 동일하게 맞춰져야 한다는 의미이다.
      예를 들어 DEFINE_COLUMN_CHAR를 사용했다면, COLUMN_VALUE_CHAR를 호출해야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>COLUMN_VALUE 프러시저<a id="d5e15017" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <p>COLUMN_VALUE 프러시저는 값을 저장할 변수의 타입에 따라 중복으로 선언되어 있다.</p>

          <p>해당되는 타입으로는 NUMBER, VARCHAR2, DATE, TIMESTAMP, INTERVAL,
          BINARY_FLOAT, BINARY_DOUBLE, CLOB, BLOB이 있다.</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>NUMBER</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c            IN    INTEGER, 
    position     IN    INTEGER, 
    value        OUT   NUMBER
);</pre>
            </li><li>
              <p>VARCHAR2</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c            IN    INTEGER, 
    position     IN    INTEGER, 
    value        OUT   VARCHAR2
);</pre>
            </li><li>
              <p>DATE</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c            IN    INTEGER, 
    position     IN    INTEGER, 
    value        OUT   DATE
);</pre>
            </li><li>
              <p>TIMESTAMP</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(    
    c             IN   INTEGER, 
    position      IN   INTEGER, 
    value         OUT  TIMESTAMP_UNCONSTRAINED
);</pre>
            </li><li>
              <p>INTERVAL</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c             IN   INTEGER, 
    position      IN   INTEGER, 
    value         OUT  YMINTERVAL_UNCONSTRAINED
);</pre><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c             IN    INTEGER, 
    position      IN    INTEGER, 
    value         OUT   DSINTERVAL_UNCONSTRAINED
);</pre>
            </li><li>
              <p>BINARY_FLOAT</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c             IN    INTEGER, 
    position      IN    INTEGER, 
    value         OUT   BINARY_FLOAT
);</pre>
            </li><li>
              <p>BINARY_DOUBLE</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c             IN    INTEGER, 
    position      IN    INTEGER, 
    value         OUT   BINARY_DOUBLE
);</pre>
            </li><li>
              <p>BLOB</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c IN INTEGER,
    position IN INTEGER,
    value  OUT  BLOB
);</pre>
            </li><li>
              <p>CLOB</p><pre class="programlisting">PROCEDURE COLUMN_VALUE
(
    c IN INTEGER,
    position IN INTEGER,
    value  OUT  CLOB
);</pre>
            </li></ul></div>

          <p>CHAR, RAW, ROWID 타입을 위해서는 별도의 프러시저를 사용해야 한다.</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>CHAR</p>

              <pre class="programlisting">PROCEDURE COLUMN_VALUE_CHAR
(
    c          IN   INTEGER, 
    position   IN   INTEGER, 
    value      OUT  CHAR[, column_error OUT NUMBER, 
                          actual_length OUT INTEGER]
);</pre>
            </li><li>
              <p>RAW</p>

              <pre class="programlisting">PROCEDURE COLUMN_VALUE_RAW
(
    c          IN   INTEGER, 
    position   IN   INTEGER, 
    value      OUT  RAW[, column_error OUT NUMBER, 
                        actual_length OUT INTEGER]
);</pre>
            </li><li>
              <p>ROWID</p>

              <pre class="programlisting">PROCEDURE COLUMN_VALUE_ROWID
(
    c          IN   INTEGER, 
    position   IN   INTEGER, 
    value      OUT  ROWID[, column_error OUT NUMBER]
);</pre>
            </li></ul></div>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr><tr><td align="left">position</td><td>fetch할 컬럼 목록에서 상대적 위치이다. (1 이상)</td></tr><tr><td align="left">value</td><td>가져올 컬럼을 저장할 변수이다.</td></tr><tr><td align="left">column_error</td><td><div class="itemizedlist"><ul type="circle" compact="compact"><li>
                        <p>값이 NULL인 경우 1405이다.</p>
                      </li><li>
                        <p>값이 절삭된 경우 1406이다.</p>
                      </li></ul></div></td></tr><tr><td align="left">actual_length</td><td>실제로 가져온 컬럼의 길이이다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p><pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR2(3));
INSERT INTO PSM_TABLE VALUES('111');

DECLARE 
    csr INTEGER;
    col VARCHAR2(2);
    val VARCHAR2(2);
    ret INTEGER;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'select * from psm_table', dbms_sql.native); 

    <em class="lineannotation"><span class="lineannotation">/* result value is truncated */</span></em>
    DBMS_SQL.DEFINE_COLUMN(csr, 1, col, 2); 

    ret := DBMS_SQL.EXECUTE(csr);
    ret := DBMS_SQL.FETCH_ROWS(csr);

    DBMS_SQL.COLUMN_VALUE(csr, 1, val); 

    DBMS_OUTPUT.PUT_LINE('val=' || val || '.');

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/
val=11.</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_DEFINE_COLUMN"/>39.3.5. DEFINE_COLUMN<a id="d5e15100" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서에서 fetch될 컬럼의 타입을 정의하는 프러시저이다. 이 프러시저는 SELECT 문장에만 사용할 수
      있다.</p>

      <div class="literallayout"><p/></div>

      <p>DEFINE_COLUMN 프러시저<a id="d5e15106" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <p>DEFINE_COLUMN 프러시저는 설정할 변수의 타입에 따라 중복으로 선언되어 있다.</p>

          <p>해당되는 타입으로는 NUMBER, VARCHAR2, DATE, TIMESTAMP, INTERVAL,
          BINARY_FLOAT, BINARY_DOUBLE, CLOB, BLOB이 있다.</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>NUMBER</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   NUMBER
);</pre>
            </li><li>
              <p>VARCHAR2</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   VARCHAR2, 
    column_size    IN   INTEGER
);</pre>
            </li><li>
              <p>DATE</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   DATE
);</pre>
            </li><li>
              <p>TIMESTAMP</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   TIMESTAMP_UNCONSTRAINED
);</pre>
            </li><li>
              <p>INTERVAL</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   YMINTERVAL_UNCONSTRAINED
);</pre><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   DSINTERVAL_UNCONSTRAINED
);</pre>
            </li><li>
              <p>BINARY_FLOAT</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN    BINARY_FLOAT
);</pre>
            </li><li>
              <p>BINARY_DOUBLE</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   BINARY_DOUBLE
);</pre>
            </li><li>
              <p>CLOB</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   CLOB
);</pre>
            </li><li>
              <p>BLOB</p><pre class="programlisting">PROCEDURE DEFINE_COLUMN
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   BLOB
);</pre>
            </li></ul></div>

          <p>CHAR, RAW, ROWID 타입을 위해서는 별도의 프러시저를 사용해야 한다.</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>CHAR</p>

              <pre class="programlisting">PROCEDURE DEFINE_COLUMN_CHAR
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   CHAR, 
    column_size    IN   INTEGER
);</pre>
            </li><li>
              <p>RAW</p>

              <pre class="programlisting">PROCEDURE DEFINE_COLUMN_RAW
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   RAW, 
    column_size    IN   INTEGER
);</pre>
            </li><li>
              <p>ROWID</p>

              <pre class="programlisting">PROCEDURE DEFINE_COLUMN_ROWID
(
    c              IN   INTEGER, 
    position       IN   INTEGER, 
    column         IN   ROWID
);</pre>
            </li></ul></div>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr><tr><td align="left">position</td><td><p>SELECT를 실행할 컬럼 목록에서의 상대적 위치이다.</p><p>문장의
                  컬럼에서 첫 번째 위치를 1로 하며, 1 이상의 값을 입력한다.</p></td></tr><tr><td align="left">column</td><td>정의할 컬럼의 변수로, 타입만 참조하며 값은 관계없다.</td></tr><tr><td align="left">column_size</td><td><p>VARCHAR2, CHAR 타입에 대해 SELECT를 실행할 컬럼 값의 최대
                  길이이다.</p><p>단, 최대 길이를 초과한 결과 컬럼은 절삭하여
                  가져온다.</p></td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR2(3));
INSERT INTO PSM_TABLE VALUES('abc');

DECLARE 
    csr INTEGER;
    v VARCHAR2(1);
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'select * from psm_table', dbms_sql.native); 

    DBMS_SQL.DEFINE_COLUMN(csr, 1, v, 1); 

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_DESCRIBE_COLUMNS"/>39.3.6. DESCRIBE_COLUMNS<a id="d5e15184" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 열린 커서에서 결과 테이블의 컬럼들의 타입을 알려주는 프러시저이다. 이 프러시저는 SELECT 문장에만 사용할
      수 있으며, 반드시 PARSE 프러시저<a id="d5e15188" class="indexterm"/>로 SELECT 문장을 명시한 후 사용해야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>DESCRIBE_COLUMNS 프러시저<a id="d5e15192" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">PROCEDURE DESCRIBE_COLUMNS
(
    c              IN    INTEGER, 
    col_cnt        OUT   INTEGER,
    desc_t         OUT   DESC_TAB
);</pre>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr><tr><td align="left">col_cnt</td><td>SELECT 결과 테이블의 컬럼 갯수이다.</td></tr><tr><td align="left">desc_t</td><td>각 컬럼의 정보들(desc_rec<a id="d5e15217" class="indexterm"/>)의 리스트(desc_tab<a id="d5e15219" class="indexterm"/>)이다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR2(3));
INSERT INTO PSM_TABLE VALUES('abc');

DECLARE 
    csr INTEGER;
    col_cnt INTEGER;
    rec_tab DBMS_SQL.DESC_TAB;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'select * from psm_table', dbms_sql.native); 

    DBMS_SQL.DESCRIBE_COLUMNS(csr, col_cnt, rec_tab); 

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_DESCRIBE_COLUMNS2"/>39.3.7. DESCRIBE_COLUMNS2<a id="d5e15226" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 열린 커서에서 결과 테이블의 컬럼들의 타입을 알려주는 프러시저이다. 이 프러시저는 SELECT 문장에만 사용할
      수 있으며, 반드시 PARSE 프러시저<a id="d5e15230" class="indexterm"/>로 SELECT 문장을 명시한 후 사용해야 한다.</p>

      <p>DESCRIBE_COLUMNS에서는 정보들 중 컬럼 이름을 최대 32bytes 밖에 수용하지 못하지만, 이 프러시저는
      32767bytes까지 수용하므로, 이 함수를 사용할 것을 권장한다.</p>

      <div class="literallayout"><p/></div>

      <p>DESCRIBE_COLUMNS2 프러시저<a id="d5e15235" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">PROCEDURE DESCRIBE_COLUMNS2
(
    c              IN    INTEGER, 
    col_cnt        OUT   INTEGER,
    desc_t         OUT   DESC_TAB2
);</pre>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr><tr><td align="left">col_cnt</td><td>SELECT 결과 테이블의 컬럼 갯수이다.</td></tr><tr><td align="left">desc_t</td><td>각 컬럼의 정보들(desc_rec2<a id="d5e15260" class="indexterm"/>)의 리스트(desc_tab2<a id="d5e15262" class="indexterm"/>)이다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR2(3));
INSERT INTO PSM_TABLE VALUES('abc');

DECLARE 
    csr INTEGER;
    col_cnt INTEGER;
    rec_tab DBMS_SQL.DESC_TAB2;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'select * from psm_table', dbms_sql.native); 

    DBMS_SQL.DESCRIBE_COLUMNS2(csr, col_cnt, rec_tab); 

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_PARSE"/>39.3.8. PARSE<a id="d5e15269" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 SQL 문장을 파싱하는 프러시저이다. 이때 DDL 문장인 경우 즉시 수행된다. 기존에 열려 있는 SQL 문장이
      있다면 닫고 새로 입력된 SQL 문장을 파싱한다.</p>

      <p>일반적으로 VARCHAR2 타입의 문자열로 SQL문장을 실행하지만, 문자열 길이가 길 경우 CLOB 또는
      VARCHAR2A 타입으로 작성할 수 있다.<a id="d5e15274" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>PARSE 프러시저<a id="d5e15279" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>VARCHAR2</p><pre class="programlisting">PROCEDURE PARSE
(
    c               IN    INTEGER, 
    statement       IN    VARCHAR2, 
    language_flag   IN    INTEGER DEFAULT NULL
);</pre>
            </li><li>
              <p>CLOB</p><pre class="programlisting">PROCEDURE PARSE
(
    c               IN    INTEGER, 
    statement       IN    CLOB, 
    language_flag   IN    INTEGER DEFAULT NULL
);</pre>
            </li><li>
              <p>VARCHAR2A</p><pre class="programlisting">PROCEDURE PARSE
(
    c               IN    INTEGER, 
    statement       IN    VARCHAR2A, 
    lb              IN    INTEGER, 
    ub              IN    INTEGER,
    lfflg           IN    BOOLEAN, 
    language_flag   IN    INTEGER DEFAULT NULL
);</pre>
            </li></ul></div>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="135" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr><tr><td align="left">statement</td><td><p>파싱할 대상이 되는 SQL 문장이다.</p><p>PSM 문장과 달리 SQL
                  문장에서는 마지막 세미콜론(;)은 입력하지 않아도 된다.</p></td></tr><tr><td align="left">lb</td><td>VARCHAR2A 구성 문자열들 중 하계값이다.</td></tr><tr><td align="left">ub</td><td>VARCHAR2A 구성 문자열들 중 상계값이다.</td></tr><tr><td align="left">lfflg</td><td>TRUE이면 VARCHAR2A의 각 구성 문자열 끝마다 newline 문자가
                  추가된다.</td></tr><tr><td align="left">language_flag</td><td>지원되지 않는 기능이므로 값을 무시한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR2(3));

DECLARE 
    csr INTEGER;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'select * from psm_table', dbms_sql.native); 

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/</pre>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR2(3));

DECLARE
    csr INTEGER;
    sql_arr DBMS_SQL.VARCHAR2A;
    r number;
    trec PSM_TABLE%ROWTYPE;
    lb number;
    ub number;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    sql_arr(1) := 'insert ';
    sql_arr(2) := 'into ';
    sql_arr(3) := 'PSM_TABLE ';
    sql_arr(4) := 'values';
    sql_arr(5) := '(';
    sql_arr(6) := '''abc''';
    sql_arr(7) := ')';

    lb := 1;
    ub := 7;
    DBMS_SQL.PARSE(csr, sql_arr, lb, ub, true, dbms_sql.native);

    DBMS_SQL.CLOSE_CURSOR(csr); 
END;
/</pre>
        </li></ul></div>

      <p/>

      <p/>

      
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e15330"/>39.4. 함수</h2></div></div></div>
    

    <p>본 절에서는 DBMS_SQL 패키지에서 제공하는 함수를 알파벳 순으로 설명한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_EXECUTE"/>39.4.1. EXECUTE<a id="d5e15335" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서를 실행하는 함수이다. INSERT, UPDATE, DELETE 문장인 경우 처리된 로우의 수가
      반환된다.</p>

      <div class="literallayout"><p/></div>

      <p>EXECUTE 함수<a id="d5e15341" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">FUNCTION EXECUTE
(
    c    IN    INTEGER
) 
RETURN INTEGER;</pre>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>반환값</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">반환값</th><th>설명</th></tr></thead><tbody><tr><td align="left">INTEGER</td><td>INSERT, UPDATE, DELETE 문장인 경우 처리한 로우의 수를
                  반환한다.</td></tr><tr><td align="left">UNDEFINED</td><td>INSERT, UPDATE, DELETE 문장 이외의 경우에 반환한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR(3));
            
DECLARE 
    csr INTEGER;
    ret INTEGER;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'insert into psm_table values(''abc'')', 
                   dbms_sql.native); 

    ret := DBMS_SQL.EXECUTE(csr);

    DBMS_OUTPUT.PUT_LINE('affected row cnt = ' || ret || '.');

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/
affected row cnt = 1.</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_EXECUTE_AND_FETCH"/>39.4.2. EXECUTE_AND_FETCH<a id="d5e15381" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서에 EXECUTE 와 FETCH_ROWS 함수를 연속해서 호출하는 것과 동일한 함수이다. 반환되는 값은
      FETCH_ROWS와 동일하다. 즉, 실제 fetch한 로우의 수를 반환한다.</p>

      <div class="literallayout"><p/></div>

      <p>EXECUTE_AND_FETCH 함수<a id="d5e15387" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">FUNCTION EXECUTE_AND_FETCH
(
    c      IN   INTEGER, 
    exact  IN   BOOLEAN DEFAULT FALSE
)
RETURN INTEGER;</pre>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr><tr><td align="left">exact</td><td><div class="itemizedlist"><ul type="circle" compact="compact"><li>
                        <p>TRUE : 정확히 하나의 로우가 fetch되지 않으면 예외가 발생한다.</p>
                      </li><li>
                        <p>FALSE : 여러 개의 ROW가 fetch되어도 예외가 발생하지 않는다.</p>
                      </li></ul></div></td></tr></tbody></table>
          </div>
        </li><li>
          <p>반환값</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">반환값</th><th>설명</th></tr></thead><tbody><tr><td align="left">0</td><td>fetch할 로우가 더 이상 없는 경우에 반환한다.</td></tr><tr><td align="left">1</td><td>fetch에 성공한 경우에 반환한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR(3));
INSERT INTO PSM_TABLE VALUES('abc');
            
DECLARE 
    csr INTEGER;
    ret INTEGER;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'SELECT * FROM PSM_TABLE', dbms_sql.native); 

    ret := DBMS_SQL.EXECUTE_AND_FETCH(csr);
    DBMS_OUTPUT.PUT_LINE('fetched row cnt = ' || ret || '.');

    LOOP 
        ret := DBMS_SQL.FETCH_ROWS(csr);
        DBMS_OUTPUT.PUT_LINE('fetched row cnt = ' || ret || '.');
        exit when ret = 0;
    END LOOP;

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/
fetched row cnt = 1.
fetched row cnt = 0.</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_FETCH_ROWS"/>39.4.3. FETCH_ROWS<a id="d5e15435" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서에서 로우를 fetch하는 함수이다. 이때 실제 fetch된 로우의 수가 반환된다. 더 이상 fetch할
      로우가 없는데 이 함수를 계속 호출하게 되면 예외가 발생한다.</p>

      <div class="literallayout"><p/></div>

      <p>FETCH_ROWS 함수<a id="d5e15441" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">FUNCTION FETCH_ROWS
(
    c   IN   INTEGER
) 
RETURN INTEGER;</pre>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>반환값</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">반환값</th><th>설명</th></tr></thead><tbody><tr><td align="left">0</td><td>fetch할 로우가 더 이상 없는 경우에 반환한다.</td></tr><tr><td align="left">1</td><td>fetch에 성공한 경우에 반환한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR2(3));
INSERT INTO PSM_TABLE VALUES('abc');
            
DECLARE 
    csr INTEGER;
    ret INTEGER;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'SELECT * FROM PSM_TABLE', dbms_sql.native); 

    ret := DBMS_SQL.EXECUTE(csr);
    LOOP 
        ret := DBMS_SQL.FETCH_ROWS(csr);
        DBMS_OUTPUT.PUT_LINE('fetched row cnt = ' || ret || '.');
        exit when ret = 0;
    END LOOP;

    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/
fetched row cnt = 1.
fetched row cnt = 0.</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_OPEN_CURSOR"/>39.4.4. OPEN_CURSOR<a id="d5e15481" class="indexterm"/></h3></div></div></div>
      

      <p>SQL 문장을 수행하기 위한 커서를 새로 하나 여는 함수이다. 열린 커서는 사용 후에 반드시 close_cursor를
      호출해야 리소스가 서버에 반납된다.</p>

      <p>한번 열린 커서는 동일한 SQL 문장을 반복해서 수행할 수도 있고, 다른 SQL 문장을 실행하는 데 사용할 수도 있다.
      커서를 여는 데 성공하면, 커서 ID를 INTEGER 타입으로 반환한다. 이 값을 이후에 DBMS_SQL 패키지의 커서 파라미터로
      사용하면 된다.</p>

      <div class="literallayout"><p/></div>

      <p>OPEN_CURSOR 함수<a id="d5e15488" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">FUNCTION OPEN_CURSOR() 
RETURN INTEGER;</pre>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">DECLARE 
    csr INTEGER; 
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 
END; 
/</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_IS_OPEN"/>39.4.5. IS_OPEN<a id="d5e15499" class="indexterm"/></h3></div></div></div>
      

      <p>주어진 커서가 DBMS_SQL.open_cursor 함수로 열릴 수 있는 커서인지 검사하는 함수이다.</p>

      <div class="literallayout"><p/></div>

      <p>IS_OPEN 함수<a id="d5e15505" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">FUNCTION IS_OPEN
(
    c   IN   INTEGER
) 
RETURN BOOLEAN;</pre>
        </li><li>
          <p>파라미터</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>대상 커서이다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>반환값</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">반환값</th><th>설명</th></tr></thead><tbody><tr><td align="left">true</td><td>open 상태인 경우에 반환한다.</td></tr><tr><td align="left">false</td><td>open 상태가 아닌 경우에 반환한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">DECLARE 
    csr INTEGER := DBMS_SQL.OPEN_CURSOR(); 
    is_open BOOLEAN;
BEGIN
    is_open := DBMS_SQL.IS_OPEN(csr); 

    if is_open then
        DBMS_OUTPUT.PUT_LINE('opened.');
    end if;
END; 
/
opened.</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_LAST_ERROR_POSITION"/>39.4.6. LAST_ERROR_POSITION<a id="d5e15545" class="indexterm"/></h3></div></div></div>
      

      <p>파싱을 할 때 발생한 에러의 위치를 찾아주는 함수이다. 단, 이 함수는 PARSE 프러시저를 호출한 직후에 사용해야
      올바른 결과를 얻을 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>LAST_ERROR_POSITION 함수<a id="d5e15551" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p>

          <pre class="programlisting">FUNCTION LAST_ERROR_POSITION return INTEGER;</pre>
        </li><li>
          <p>반환값</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">반환값</th><th>설명</th></tr></thead><tbody><tr><td align="left">INTEGER</td><td>파싱을 할 때 에러가 발생한 오프셋을 반환한다. (0부터 시작)</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">DECLARE 
    csr INTEGER; 
    position INTEGER;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'select * from psm_not_exist_table', dbms_sql.native); 

EXCEPTION 
WHEN OTHERS THEN
    position := DBMS_SQL.LAST_ERROR_POSITION;

    DBMS_OUTPUT.PUT_LINE('error position = ' || position);
    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/
error position = 14</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="DBMS_SQL_LAST_ROW_COUNT"/>39.4.7. LAST_ROW_COUNT<a id="d5e15576" class="indexterm"/></h3></div></div></div>
      

      <p>현재 수행 중인 문장의 fetch된 로우 수의 총합을 반환하는 함수이다. 단, 이 함수는 PARSE 프러시저를 호출한
      직후에 사용해야 올바른 결과를 얻을 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>LAST_ROW_COUNT 함수<a id="d5e15582" class="indexterm"/>의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>프로토타입</p><pre class="programlisting">FUNCTION LAST_ROW_COUNT return INTEGER;</pre>
        </li><li>
          <p>반환값</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">반환값</th><th>설명</th></tr></thead><tbody><tr><td align="left">INTEGER</td><td>현재 수행 중인 문장의 fetch된 로우 수의 총합을 반환한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <pre class="programlisting">CREATE TABLE PSM_TABLE (A VARCHAR2(3));
INSERT INTO PSM_TABLE VALUES('111');
INSERT INTO PSM_TABLE VALUES('222');
            
DECLARE 
    csr INTEGER;
    ret INTEGER;
    cnt INTEGER;
BEGIN
    csr := DBMS_SQL.OPEN_CURSOR(); 

    DBMS_SQL.PARSE(csr, 'SELECT * FROM PSM_TABLE', dbms_sql.native); 

    ret := DBMS_SQL.EXECUTE(csr);
    LOOP 
        ret := DBMS_SQL.FETCH_ROWS(csr);
        exit when ret = 0;
    END LOOP;

    cnt := DBMS_SQL.LAST_ROW_COUNT;

    DBMS_OUTPUT.PUT_LINE('last row count = ' || cnt);
    DBMS_SQL.CLOSE_CURSOR(csr); 
END; 
/
last row count = 2</pre>
        </li></ul></div>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chap_dbms_sph.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chap_dbms_sqltune.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제38장 DBMS_SPH </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제40장 DBMS_SQLTUNE</td></tr></table></div><div xmlns="" align="center"/></body></html>