<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제6장 패키지</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbPSM 안내서"/><link rel="up" href="index.html" title="Tibero tbPSM 안내서"/><link rel="prev" href="chapter_subprogram.html" title="제5장 서브 프로그램"/><link rel="next" href="chapter_sql_execution.html" title="제7장 SQL 문장의 실행"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제6장 패키지</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_subprogram.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_sql_execution.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_package"/>제6장 패키지</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_package.html#d5e3545">6.1. 패키지 구조</a></span></dt><dt><span class="section"><a href="chapter_package.html#d5e3583">6.2. 패키지 초기화</a></span></dt><dt><span class="section"><a href="chapter_package.html#d5e3604">6.3. 패키지 객체</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_package.html#sect_package_instance">6.3.1. 패키지 객체 연속성</a></span></dt><dt><span class="section"><a href="chapter_package.html#d5e3629">6.3.2. 패키지 객체 참조범위</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_package.html#d5e3639">6.4. 패키지 서브 프로그램 중복 선언</a></span></dt><dt><span class="section"><a href="chapter_package.html#d5e3655">6.5. SERIALLY RESUABLE 패키지</a></span></dt><dt><span class="section"><a href="chapter_package.html#d5e3678">6.6. 시스템 패키지</a></span></dt></dl></div>
  

  <p>본 장에서는 <span>tbPSM</span>의 변수나 타입, 서브 프로그램 등을 그룹화하여 모아 놓은 객체인 패키지를
  기술한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3545"/>6.1. 패키지 구조<a id="d5e3547" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">패키지</strong></span>(package)는 개념적으로 관련 있는 <span>tbPSM</span>의 변수나 타입, 서브 프로그램을 그룹화하여 모아 놓은
    객체이다.</p>

    <p>패키지는 보통 선언부와 구현부로 구성된다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>선언부</p>

        <p>사용자에게 보이는 인터페이스로 공개(public)적인 성격을 띤다 .</p>

        <p>패키지의 선언부는 다음과 같은 형식을 갖는다.</p>

        <pre class="programlisting"><span><strong class="guibutton">CREATE</strong></span> [OR REPLACE] <span><strong class="guibutton">PACKAGE 패키지_이름</strong></span>
[AUTHID {CURRENT_USER | DEFINER}] {IS | AS}
    [변수, 타입 선언...]        -- 공개
    [커서 선언...]
    [함수 선언...]
    [프러시저 선언...]
END;</pre>

        <div class="informaltable">
          <table border="1"><colgroup><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">옵션</th><th>설명</th></tr></thead><tbody><tr><td align="left">AUTHID</td><td>패키지 수준으로 패키지 된 모듈이 수행하는 권한(privileges)을 지정한다.</td></tr></tbody></table>
        </div>

        <p>패키지 모듈에서는 독립형 모듈과 달리 AUTHID 절을 사용하여 각 단위를 개별적으로 다른 권한을 지정할 수
        없다.</p>
      </li><li>
        <p>구현부</p>

        <p>선언부에서 선언한 내용을 실제로 구현하는 부분이다. 사용자에게는 구현된 내용이 보이지 않으며,
        비공개적(private)인 성격을 띤다 .</p>

        <p>패키지 구현부는 다음과 같은 형식을 갖는다.</p>

        <pre class="programlisting"><span><strong class="guibutton">CREATE</strong></span> [OR REPLACE] <span><strong class="guibutton">PACKAGE BODY 패키지_이름</strong></span>
[AUTHID {CURRENT_USER | DEFINER}] {IS | AS}
    [변수, 타입 선언...]        -- 비공개
    [커서 구현...]
    [함수 구현...]
    [프러시저 구현...]
[BEGIN
    초기화]
END;</pre>

        <p>패키지는 선언부에서 선언된 커서나 서브 프로그램 등에 대해 구현부에서 실제로 실행될 내용을 구현해야 한다. 그렇지
        않으면 예외 상황이 발생한다.</p>

        <p>패키지 구현부에서는 변수나, 타입, 커서, 예외 상황, 서브 프로그램 등을 선언하고 구현할 수 있는데, 선언부에
        존재하지 않는 변수나 서브 프로그램 등은 사용자에게 공개되지 않기 때문에 사용할 수 없다.</p>
      </li></ul></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3583"/>6.2. 패키지 초기화<a id="d5e3585" class="indexterm"/></h2></div></div></div>
    

    <p>패키지 구현부에는 BEGIN ... END 절을 사용할 수 있다. BEGIN ... END 절 사이에는 선언부에서 명시한
    변수를 초기화할 수 있고, 패키지가 처음 사용되는 시점에 단 한번 호출된다.</p>

    <p>다음은 패키지 초기화의 예제이다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>anniversary_manager 패키지의 선언부</p>

        <pre class="programlisting">CREATE PACKAGE anniversary_manager IS
    month_counter PLS_INTEGER;
    PROCEDURE compute_elapsed_days(start_day DATE);
END;</pre>
      </li><li>
        <p>anniversary_manager 패키지의 구현부</p>

        <pre class="programlisting">CREATE PACKAGE BODY anniversary_manager IS
    PROCEDURE compute_elapsed_days(start_day DATE) IS
    BEGIN
        month_counter := months_between(sysdate(), start_day);
        DBMS_OUTPUT.PUT_LINE(month_counter * 30 || ' days...');
    END;
BEGIN
    month_counter := 0;
    DBMS_OUTPUT.PUT_LINE('package is initialized');
END;</pre>
      </li></ul></div>

    <div class="literallayout"><p/></div>

    <p>다음은 anniversary_manager 패키지를 수행한 결과이다.</p>

    <pre class="programlisting">SQL&gt; BEGIN
       anniversary_manager.compute_elapsed_days('1979/10/27');  <em class="lineannotation"><span class="lineannotation">... 첫 번째 호출 ...</span></em>
       DBMS_OUTPUT.PUT_LINE('============ ');
       anniversary_manager.compute_elapsed_days('1998/03/02');  <em class="lineannotation"><span class="lineannotation">... 두 번째 호출 ...</span></em>
     END;
/
package is initialized
9780 days...
============
3180 days...

PSM completed
SQL&gt; </pre>

    <p/>

    <p>위 결과에서 보듯이 첫 번째로 compute_elapsed_days 프러시저가 호출된 경우에는 패키지 구현부의
    BEGIN...END 절이 수행되는 반면, 두 번째로 호출된 경우에는 수행되지 않는 것을 알 수 있다.</p>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3604"/>6.3. 패키지 객체<a id="d5e3606" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">패키지 객체</strong></span>(Instance)란 패키지에 선언한(서브 프로그램을 제외한) 변수,
    타입, 예외 상황, 커서 등을 말한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_package_instance"/>6.3.1. 패키지 객체 연속성</h3></div></div></div>
      

      <p>최초로 패키지가 참조되는 순간에 패키지 객체의 전부가 메모리에 로딩되고, 한번 로딩된 패키지 객체는 세션이 닫히기
      전까지는 계속 존재하게 된다. 또한 한 명의 사용자가 서로 다른 프로그램을 호출하는 동안에도(직접 해당 변수를 수정하지 않는
      조건이라면) 패키지 객체는 동일한 값을 갖는다.</p>

      <p>다음은 패키지 객체 연속성 예제이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>test_instance 패키지의 선언부</p>

          <pre class="programlisting">CREATE PACKAGE test_instance IS
    total_cnt NUMBER;
    FUNCTION get_total_cnt RETURN NUMBER;
END;</pre>
        </li><li>
          <p>test_instance 패키지의 구현부</p>

          <pre class="programlisting">CREATE PACKAGE BODY test_instance IS
    FUNCTION get_total_cnt RETURN NUMBER IS
    BEGIN
        RETURN total_cnt;
    END;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Package is initialized');
    total_cnt := 0;
END;</pre>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 test_instance 패키지를 수행한 결과이다.</p>

      <pre class="programlisting">SQL&gt; BEGIN
       DBMS_OUTPUT.PUT_LINE('초기 값 = ' || test_instance.get_total_cnt);
       -- 패키지 객체인 total_cnt의 값을 바꾼다.
       test_instance.total_cnt := 3;    <em class="lineannotation"><span class="lineannotation">... ⓐ ...</span></em>
     END;
/
Package is initialized
초기 값 = 0

PSM completed
SQL&gt; </pre>

      <p>ⓐ에서 total_cnt에 대입한 값이 계속 유지되고 있다. 이때 SQL 문장을 실행하면 다음과 같이 변경된 값의
      결과가 출력된다.</p>

      <pre class="programlisting">SQL&gt; BEGIN
       DBMS_OUTPUT.PUT_LINE(test_instance.get_total_cnt);
     END;
/
3

PSM completed
SQL&gt; </pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3629"/>6.3.2. 패키지 객체 참조범위<a id="d5e3631" class="indexterm"/></h3></div></div></div>
      

      <p>한 패키지 객체는 한 명의 사용자에게만 한정된다. 따라서 서로 다른 사용자는 각각 다른 객체를 참조하게 된다.
      test_instance 패키지의 예를 기준으로 다음과 같이 SQL 문장을 실행한다.</p>

      <pre class="programlisting">SQL&gt; BEGIN
    DBMS_OUTPUT.PUT_LINE('초기 값 = ' || test_instance.get_total_cnt);
    -- 패키지 객체인 total_cnt의 값을 바꾼다.
    test_instance.total_cnt := 3;
    DBMS_OUTPUT.PUT_LINE('바꾼 값 = ' || test_instance.get_total_cnt);
END;
/
Package is initialized
초기 값 = 0
바꾼 값 = 3

PSM completed
SQL&gt; </pre>

      <p>이러한 과정을 수행하고 나서 다른 콘솔 창을 실행하여 다시 같은 사용자로 접속한다.</p>

      <pre class="programlisting">SQL&gt; BEGIN
       DBMS_OUTPUT.PUT_LINE(test_instance.get_total_cnt);
     END;
/
Package is initialized
0

PSM completed
SQL&gt; </pre>

      <p>이전에 total_cnt의 값을 0에서 3으로 바꾼 것과는 상관없이 초기값 0이 그대로 유지되고 있는 것을 확인할 수
      있다.</p>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3639"/>6.4. 패키지 서브 프로그램 중복 선언<a id="d5e3641" class="indexterm"/><a id="d5e3643" class="indexterm"/></h2></div></div></div>
    

    <p>패키지의 서브 프로그램은 중복 선언을 할 수 있다. 다음은 패키지 서브 프로그램의 중복 선언에 대한 예이다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>calculator 패키지의 선언부</p>

        <pre class="programlisting">CREATE PACKAGE calculator IS
    ...
    FUNCTION add (x NUMBER, y NUMBER) RETURN NUMBER;
    FUNCTION add (x NUMBER, y VARCHAR2) RETURN NUMBER;
    ...
END;</pre>
      </li><li>
        <p>calculator 패키지의 구현부</p>

        <pre class="programlisting">CREATE PACKAGE BODY calculator IS
    ...
    FUNCTION add (x NUMBER, y NUMBER) RETURN NUMBER IS
    BEGIN
        RETURN x + y;
    END;
    FUNCTION add (x NUMBER, y VARCHAR2) RETURN NUMBER IS
    BEGIN
        RETURN x + to_number(y);
    END;
END;</pre>
      </li></ul></div>

    <p/>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3655"/>6.5. SERIALLY RESUABLE 패키지<a id="d5e3657" class="indexterm"/></h2></div></div></div>
    

    <p>SERIALLY RESUABLE 패키지는 패키지 객체(Instance)의 상태가 서버 호출 동안 유지된다. 사용할 때마다
    패키지 객체가 초기화되며 이전 서버 호출에서 변경한 패키지의 상태는 유지되지 않는다.</p>

    <p>다음은 SERIALLY RESUABLE 패키지 예제이다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>sr_pkg 패키지의 선언부</p>

        <pre class="programlisting">CREATE PACKAGE sr_pkg IS
    PRAGMA SERIALLY_REUSABLE;
    n NUMBER := 1;
    FUNCTION f1 RETURN NUMBER;
END;</pre>
      </li><li>
        <p>sr_pkg 패키지의 구현부</p>

        <pre class="programlisting">CREATE PACKAGE BODY sr_pkg IS
    PRAGMA SERIALLY_REUSABLE;
    FUNCTION f1 RETURN NUMBER IS
    BEGIN
        RETURN sr_pkg.n;
    END;
END;</pre>
      </li></ul></div>

    <p/>

    <div class="literallayout"><p/></div>

    <p>다음은 sr_pkg 패키지를 수행한 결과이다.</p>

    <pre class="programlisting">SQL&gt; BEGIN
       sr_pkg.n := 10;
       DBMS_OUTPUT.PUT_LINE(sr_pkg.n);
     END;
/
10

PSM completed
SQL&gt;

BEGIN
   DBMS_OUTPUT.PUT_LINE(sr_pkg.n);
 END;
/
1

PSM completed
SQL&gt;  </pre>

    <p>위 결과에서 보듯이 SERIALLY_REUSABLE 패키지의 경우 패키지 객체(Instance)의 상태가 서버 호출 동안만
    유지된다.</p>

    <p>다음은 SQL 문을 통해 sr_pkg 패키지에 접근하는 경우 예제이다.</p>

    <pre class="programlisting">SQL&gt; SELECT sr_pkg.f1() FROM DUAL;
/

TBR-15240: Unable to access the SERIALLY REUSABLE 'SR_PKG' package.
SQL&gt; </pre>

    <p>SERIALLY_REUSABLE 패키지를 SQL 문을 통해서 접근하려고 하면 오류가 발생한다.</p>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3678"/>6.6. 시스템 패키지<a id="d5e3680" class="indexterm"/></h2></div></div></div>
    

    <p><span>tbPSM</span>에서는 사용자의 편의를 위해 STANDARD,<span>DBMS_LOB,</span> DBMS_OUTPUT, UTL_RAW 패키지 등의
    <span><strong class="guibutton">시스템 패키지</strong></span>를 제공한다.</p>

    <div class="literallayout"><p/></div>

    <p><span><strong class="guibutton">STANDARD</strong></span> 패키지는 <span>tbPSM</span>에서 사용하는 모든 타입과 예외 상황, 시스템 서브 프로그램을
    정의한다.<a id="d5e3690" class="indexterm"/> 만약 사용자의 실수로 이 패키지가 삭제되거나 내용이 변경된다면 <span>tbPSM</span> 프로그램의 수행 자체가 실패하거나 잘못된 결과를 출력할 수 있으므로
    주의해야 한다.</p>

    <p>STANDARD 패키지를 직접 수정하지 않고, 사용자의 편의에 따라 같은 이름의 서브 프로그램이나 패키지를 생성할 수
    있는데, 이러한 경우 우선순위에 따라 항상 사용자 패키지나 서브 프로그램이 우선권을 가지게 된다. 따라서 STANDARD 패키지를
    다시 사용하려면 STANDARD.XXX 형식으로 생성하면 된다.</p>

    <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
      <p><span>DBMS_LOB, </span>DBMS_OUTPUT,
      UTL_RAW 패키지에 대한 자세한 내용은 "<span>Tibero</span> <span>tbPSM</span> 참조 안내서"를 참고한다.</p>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_subprogram.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_sql_execution.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제5장 서브 프로그램 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제7장 SQL 문장의 실행</td></tr></table></div><div xmlns="" align="center"/></body></html>