<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제12장 분산 트랜잭션</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero 관리자 안내서"/><link rel="up" href="index.html" title="Tibero 관리자 안내서"/><link rel="prev" href="chapter_backuprecovery.html" title="제11장 백업과 복구"/><link rel="next" href="chapter_standby_cluster.html" title="제13장 Tibero Standby Cluster"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제12장 분산 트랜잭션</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_backuprecovery.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_standby_cluster.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_07"/>제12장 분산 트랜잭션</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_07.html#d5e9307">12.1. XA</a></span></dt><dt><span class="section"><a href="chapter_07.html#d5e9338">12.2. Two-phase commit mechanism</a></span></dt><dt><span class="section"><a href="chapter_07.html#d5e9392">12.3. XA의 In-doubt 트랜잭션 처리</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_07.html#sect_dba_2pc_pending">12.3.1. DBA_2PC_PENDING 뷰</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_07.html#d5e9431">12.4. 데이터베이스 링크</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_07.html#d5e9437">12.4.1. 데이터베이스 링크 생성, 제거</a></span></dt><dt><span class="section"><a href="chapter_07.html#d5e9473">12.4.2. 원격 데이터베이스 연결</a></span></dt><dt><span class="section"><a href="chapter_07.html#sect_gateway">12.4.3. 게이트웨이</a></span></dt><dt><span class="section"><a href="chapter_07.html#d5e10104">12.4.4. 데이터베이스 링크 사용</a></span></dt><dt><span class="section"><a href="chapter_07.html#d5e10116">12.4.5. Global Consistency</a></span></dt><dt><span class="section"><a href="chapter_07.html#d5e10123">12.4.6. 데이터베이스 링크 In-doubt 트랜잭션 처리</a></span></dt><dt><span class="section"><a href="chapter_07.html#d5e10139">12.4.7. 데이터베이스 링크 정보 조회</a></span></dt></dl></dd></dl></div>
  

  <p>하나의 데이터베이스 인스턴스 내에서 한 트랜잭션으로 묶인 SQL 문장이 모두 커밋되거나 롤백되듯이 네트워크로 연결된 여러 개의
  데이터베이스 인스턴스가 참여하는 트랜잭션에서도 각각 다른 데이터베이스 인스턴스에서 수행한 SQL 문장이 모두 동시에 커밋되거나 롤백될 수
  있는 방법이 필요하다.</p>

  <p>이렇게 여러 개의 노드 또는 다른 종류의 데이터베이스가 참여하는 하나의 트랜잭션을 <span><strong class="guibutton">분산
  트랜잭션(Distributed Transaction)</strong></span>이라고 한다. <span>Tibero</span>에서는 분산 트랜잭션을 처리하기 위해 <span><strong class="guibutton">XA</strong></span>와 <span><strong class="guibutton">데이터베이스
  링크(DBLink)</strong></span>를 통해 지원한다.<a id="d5e9305" class="indexterm"/></p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e9307"/>12.1. XA<a id="d5e9309" class="indexterm"/></h2></div></div></div>
    

    <p><span>Tibero</span>는 X/Open DTP(Distributed Transaction
    Processing) 규약의 XA를 지원한다. XA는 2PC(Two-phase commit)를 이용하여 분산 트랜잭션을
    처리한다.</p>

    <p>다음은 XA가 어떻게 동작하는지를 나타내는 그림이다.</p>

    <div class="figure"><a id="figure_admin_xa01"/><p class="title"><b>[그림 12.1] XA의 동작(AP, TM, DB의 상호 작용)</b></p><div class="figure-contents">
      

      <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="368"><tr><td align="left"><img src="resources/adm_xa01.png" align="top" width="368" alt="XA의 동작(AP, TM, DB의 상호 작용)"/></td></tr></table></div>
    </div></div><br class="figure-break"/>

    <div class="orderedlist"><ol type="1" compact="compact"><li>
        <p>일반적으로 XA는 트랜잭션 매니저(TM: Transaction Manager, 이하 TM)에 의해 코디네이트된다.
        가장 먼저 애플리케이션 프로그램(AP: Application Program, 이하 AP)<a id="d5e9322" class="indexterm"/>은 TM에 분산 트랜잭션의 시작을 알린다.<a id="d5e9324" class="indexterm"/><a id="d5e9326" class="indexterm"/></p>
      </li><li>
        <p>TM은 AP의 요청을 받고 어떤 데이터베이스의 노드가 해당 분산 트랜잭션에 참여하는지 확인한다. 그 다음 각
        데이터베이스 노드에 분산 트랜잭션의 시작을 알린다. 각 데이터베이스 노드에 분산 트랜잭션의 시작을 알릴 때 TM은 내부에
        고유한 트랜잭션 ID(이하 XID)를 만들어서 함께 전달한다. 그러면 각 데이터베이스 노드는 이 XID와 관련된 분산
        트랜잭션을 시작한다. 앞으로 AP로부터 들어오는 요청은 해당 분산 트랜잭션에 대한 작업이라고 인식한다.<a id="d5e9330" class="indexterm"/></p>
      </li><li>
        <p>AP는 각 데이터베이스에 SQL 문장을 전달함으로써 필요한 작업을 진행한다. 이때 각 데이터베이스는 전달 받은
        요청을 해당 XID와 관련된 작업이라고 인지하고 SQL 문장을 실행한다.</p>
      </li><li>
        <p>모든 작업이 완료되면 AP는 TM에 분산 트랜잭션의 종료를 알린다.</p>

        <p>TM은 해당 XID로 분산 트랜잭션에 참여했던 각 데이터베이스 노드에 커밋과 롤백을 동시에 하도록 지시한다. 일부
        데이터베이스는 커밋을 하고, 일부 데이터베이스는 롤백을 하는 상황이 벌어지지 않도록 TM은
        <span><strong class="guibutton">Two-phase commit mechanism</strong></span>을 통해 수행한다.</p>
      </li></ol></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e9338"/>12.2. Two-phase commit mechanism<a id="d5e9340" class="indexterm"/></h2></div></div></div>
    

    <p>Two-phase commit mechanism은 분산 컴퓨팅 환경에서 트랜잭션에 참여하는 모든 데이터베이스가 정상적으로
    수정되었음을 보장하는 두 단계 커밋 프로토콜이다. 분산 트랜잭션에 참여한 모든 데이터베이스가 모두 함께 커밋되거나 롤백되는 것을
    보장한다.</p>

    <p>Two-phase commit mechanism은 다음과 같이 두 단계로 작업이 이루어진다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>First Phase(또는 prepare phase)<a id="d5e9347" class="indexterm"/> <a id="d5e9349" class="indexterm"/></p>

        <p>First Phase는 각 데이터베이스 노드에 커밋을 하기 위한 준비 요청 단계이다.</p>

        <p>다음은 First Phase가 실행되는 과정이다.</p>

        <div class="orderedlist"><ol type="1" compact="compact"><li>
            <p>TM은 각 데이터베이스 노드에 커밋을 준비하라는 <span><strong class="guibutton">prepare</strong></span>
            메시지를 보낸다.</p>
          </li><li>
            <p>요청을 받은 각 데이터베이스는 커밋을 준비한다. 커밋을 하기 위한 준비 작업에는 필요한 리소스에
            잠금(Lock)을 설정하거나 로그 파일을 저장하는 작업 등이 있다.</p>
          </li><li>
            <p>각 데이터베이스는 커밋 준비 여부에 따라 TM에 성공 또는 실패 여부를 알린다. 커밋 준비가 모두 끝나면
            prepare가 성공한 것이고, 커밋 준비를 실패하면 prepare가 실패한 것이다.</p>
          </li></ol></div>
      </li><li>
        <p>Second Phase(또는 commit phase)<a id="d5e9363" class="indexterm"/> <a id="d5e9365" class="indexterm"/></p>

        <p>TM은 참여한 모든 데이터베이스 노드로부터 <span><strong class="guibutton">prepare</strong></span>의 완료 메시지를
        받을 때까지 대기한다. 이 단계에서는 전달 받은 <span><strong class="guibutton">prepare</strong></span>의 메시지에 따라 해당
        결과가 다르다.</p>

        <div class="informaltable">
          <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th>설명</th></tr></thead><tbody><tr><td align="left">롤백</td><td>한 데이터베이스 노드라도 <span><strong class="guibutton">prepare ok</strong></span> 메시지를 받지
                않으면 이 트랜잭션은 커밋할 수 없다고 판단하고, 모든 데이터베이스 노드에
                <span><strong class="guibutton">롤백</strong></span> 메시지를 보내 해당 작업을 롤백한다.<a id="d5e9383" class="indexterm"/></td></tr><tr><td align="left">커밋</td><td>모든 데이터베이스 노드로부터 <span><strong class="guibutton">prepare ok</strong></span> 메시지를
                받으면 다시 모든 데이터베이스 노드에 <span><strong class="guibutton">커밋</strong></span> 메시지를 보내고 모든 작업을
                커밋한다.<a id="d5e9390" class="indexterm"/></td></tr></tbody></table>
        </div>
      </li></ul></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e9392"/>12.3. XA의 In-doubt 트랜잭션 처리</h2></div></div></div>
    

    <p>Two-phase commit mechanism에 의해 첫 번째 prepare 메시지를 받으면 데이터베이스는 분산
    트랜잭션에 해당하는 리소스를 잠금 처리하거나 로그를 남김으로써 커밋할 준비를 한다. 그런데
    <span><strong class="guibutton">prepare</strong></span>까지 마친 상태에서 네트워크의 이상으로 다음 메시지(커밋 또는 롤백)를 받지
    못하는 경우가 발생할 수 있다.</p>

    <p>데이터베이스는 해당 트랜잭션을 커밋해야 할지 롤백해야 할지 판단할 수 없다. 따라서 다음 메시지가 올 때까지
    <span><strong class="guibutton">prepare</strong></span>된 리소스에 잠금 처리를 한 채로 기다리게 되는데 이러한 경우를
    <span><strong class="guibutton">In-doubt 트랜잭션</strong></span>이라고 한다.<a id="d5e9399" class="indexterm"/></p>

    <p>일반적으로 네트워크 또는 TM 측의 문제가 해결된다면 복구되는 즉시 TM은 In-doubt 트랜잭션에 커밋 또는 롤백
    메시지를 다시 보낸다. 하지만 In-doubt 트랜잭션이 잡고 있는 리소스가 급하게 반환 되어야 하는 상황이 발생한다면 DBA는
    임의로 In-doubt 트랜잭션을 커밋 또는 롤백시킴으로써 해당 리소스를 반환할 수 있다. 이러한 경우는 DBA의 판단에 의해
    결정되므로 이후에 TM으로부터 전달되는 커밋 또는 롤백 메시지가 DBA가 결정한 판단과 다르다면 전체 분산 트랜잭션이 일부 커밋되거나
    롤백되는 현상이 발생할 수 있다. 따라서 전체 분산 트랜잭션의 일관성을 위해 TM의 다음 요청을 기다려야 한다.</p>

    <p>이러한 문제를 감수하더라도 In-doubt 트랜잭션을 처리해야 하는 경우가 발생한다면 <a href="chapter_07.html#sect_dba_2pc_pending" title="12.3.1. DBA_2PC_PENDING 뷰">DBA_2PC_PENDING 뷰</a>를 이용하여 이를
    해결한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_dba_2pc_pending"/>12.3.1. DBA_2PC_PENDING 뷰<a id="d5e9406" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">DBA_2PC_PENDING 뷰</strong></span>는 현재 정체되고 있는 XA 트랜잭션
      브랜치(XA Transaction Branch)의 정보를 보여주는 뷰이다.<a id="d5e9410" class="indexterm"/></p>

      <p>다음은 XA 트랜잭션 브랜치의 정보를 조회하는 예이다. 본 예제에서는 XID와 FAIL_TIME 정보를 이용하여 커밋과
      롤백을 수행할 브랜치를 선택한다.</p>

      <div class="example"><a id="d5e9413"/><p class="title"><b>[예 12.1] DBA_2PC_PENDING 뷰 조회</b></p><div class="example-contents">
        

        <pre class="programlisting">SQL&gt; <span><strong class="guibutton">SELECT LOCAL_TRAN_ID, XID, STATUS FROM DBA_2PC_PENDING;</strong></span>

LOCAL_TRAN_ID
-------------------------------------
XID
-------------------------------------
STATUS         
---------------
2.16.18
1.1000.1000
PREPARED       

1 selected.</pre>
      </div></div><br class="example-break"/>

      <p>DBA는 다음과 같이 원하는 XA 트랜잭션 브랜치에 커밋 명령을 실행할 수 있다. 그러면 해당 XA 트랜잭션 브랜치에서
      잡고 있던 리소스는 반환되고 해당 트랜잭션은 커밋된다.</p>

      <pre class="programlisting">SQL&gt; commit force '2.16.18';

Commit succeeded.            </pre>

      <p>DBA는 강제 커밋(commit force)을 통해 롤백할 수 있다.</p>

      <pre class="programlisting">SQL&gt; rollback force '2.16.18';

Rollback succeeded.            </pre>

      <p>TM에 의한 정식 커밋이 아니고 DBA의 임의의 결정으로 커밋을 실행하면 해당 XA 트랜잭션 브랜치의 정보는 그대로
      남아 있는다.</p>

      <p>다음과 같이 <span><strong class="guibutton">FORCE_TIME</strong></span>에 DBA가 강제로 커밋한 시간이 남아 있음을
      알 수 있다.</p>

      

      <pre class="programlisting">SQL&gt; <span><strong class="guibutton">SELECT LOCAL_TRAN_ID, XID, STATUS FROM DBA_2PC_PENDING;</strong></span>

LOCAL_TRAN_ID
-------------------------------------
XID
-------------------------------------
STATUS         
---------------

1.1000.1000
FORCED_COMMIT  


1 selected            </pre>

      <p>해당 XA 트랜잭션 브랜치의 정보는 TM이 <span><strong class="guibutton">xa_forget</strong></span>을 이용하여 더
      이상 XA 트랜잭션 브랜치 정보가 필요 없다고 판단하면 해당 정보를 제거한다. 자원 관리자(RM: Resource Manager,
      이하 RM)에서는 TM의 요청이 있기 전까지는 XA 트랜잭션 브랜치의 정보를 제거하지 않는다.</p>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e9431"/>12.4. 데이터베이스 링크<a id="d5e9433" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">데이터베이스 링크</strong></span>는 원격 데이터베이스의 데이터를 마치 로컬 데이터베이스의
    데이터처럼 접근할 수 있는 방법을 제공한다. 데이터베이스 링크를 사용하면 원격 데이터베이스의 데이터에 대한 접근, 수정이 용이하며
    손쉽게 분산 트랜잭션을 처리할 수 있다. 분산 트랜잭션은 트랜잭션의 원자성을 보장하기 위해 XA와 마찬가지로 Two-phase
    commit mechanism을 사용한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9437"/>12.4.1. 데이터베이스 링크 생성, 제거</h3></div></div></div>
      

      <p>데이터베이스 링크는 다음과 같은 접근 권한에 따라 생성 및 제거 방법이 다르다.</p>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e9441"/>Public DBLink<a id="d5e9442" class="indexterm"/></h4>

      <p>데이터베이스 링크를 생성한 사용자와 다른 사용자들도 데이터베이스 링크를 이용할 수 있다. Public DBLink를
      생성하기 위해서는 <span><strong class="guibutton">create public database link</strong></span> 권한이 있어야
      한다.<a id="d5e9446" class="indexterm"/></p>

      <p>다음은 Public DBLink를 생성하는 예이다.</p><pre class="programlisting">create public database link public_<span>tibero</span> using 'remote_2';</pre><p>위의
      예에서 using 절 이후의 'remote_2'는 연결할 데이터베이스를 가리키는 이름으로 <span>tbdsn</span>.tbr 파일에 해당 데이터베이스의 연결 정보가 저장되어 있어야
      한다.</p>

      <p>다음은 Public DBLink를 제거하는 예이다. Public DBLink는 <span><strong class="guibutton">drop public
      database link</strong></span> 권한을 가진 사용자만 제거할 수 있다.<a id="d5e9454" class="indexterm"/></p>

      <pre class="programlisting">drop public database link public_<span>tibero</span>;</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9459"/>Private DBLink<a id="d5e9460" class="indexterm"/></h4>

      <p>데이터베이스 링크를 생성한 사용자만 데이터베이스 링크를 사용할 수 있다. Private DBLink를 생성하기 위해서는
      <span><strong class="guibutton">create database link</strong></span> 권한이 있어야 한다.<a id="d5e9464" class="indexterm"/></p>

      <p>다음은 Private DBLink를 생성하는 예이다.</p><pre class="programlisting">create database link remote_<span>tibero</span> using 'remote_1';</pre><p>위의
      예에서는 remote_1은 데이터베이스에 연결하는 remote_<span>tibero</span>라는 이름의 데이터베이스 링크를 생성한다. 이 데이터베이스 링크는 Private DBLink이므로 생성한 사용자
      외에는 사용할 수 없다.</p>

      <p>다음은 Private DBLink를 제거하는 예이다. Private DBLink는 생성한 사용자만 제거할 수
      있다.</p>

      <pre class="programlisting">drop database link remote_<span>tibero</span>;</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9473"/>12.4.2. 원격 데이터베이스 연결</h3></div></div></div>
      

      <p>원격 데이터베이스와의 연결에 사용하는 계정을 설정하는 방법은 다음과 같이 두 가지가 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">설정 방법</th><th>설명</th></tr></thead><tbody><tr><td align="left">지정한 계정</td><td>지정한 ID와 패스워드를 사용해 원격 데이터베이스에 접속한다. 단, 지정한 ID와 패스워드를 가진
              계정이 원격 데이터베이스에 존재해야 한다. 어떤 사용자가 사용하더라도 데이터베이스 링크를 생성할 때에는 지정한
              ID와 패스워드를 사용해야 한다. 패스워드는 작은따옴표(' ') 사이에 패스워드가 입력된 경우에만 유효하다. 예를
              들어 아래 예제에서 "password"로 패스워드가 입력된 경우에는 데이터베이스 링크 생성에 실패하게
              된다.</td></tr><tr><td align="left">현재 연결된 계정</td><td><p>현재 질의를 수행한 사용자의 ID와 패스워드를 사용해 원격 데이터베이스에 접속한다.
              데이터베이스 링크를 사용하는 사용자의 ID와 패스워드가 원격 데이터베이스에 동일하게 존재해야
              한다.</p><p>계정을 지정하지 않으면 기본으로 현재 연결된 계정으로 접속하도록 설정된다. 따라서
              데이터베이스 링크를 사용하는 사용자별로 다른 ID와 패스워드를 사용한다.</p></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>원격 데이터베이스에 연결하기 위한 계정은 CREATE SESSION 등의 권한을 가져야 하며, 데이터베이스 링크를 통해
      원격 데이터베이스의 연결에 사용된 계정의 권한을 로컬 사용자가 획득하게 되므로 권한 관리에 유의해야 한다. 특히 Public
      DBLink의 경우에는 모든 로컬 사용자가 원격 데이터베이스에 대한 권한을 갖기 때문에 주의하여 사용해야 한다.</p>

      <p>다음은 지정한 계정을 이용하는 데이터베이스 링크의 생성 예이다.</p>

      <pre class="programlisting">create database link remote_<span>tibero</span> connect to user1
identified by 'password' using 'remote_1';</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 현재 연결된 계정을 이용하는 데이터베이스 링크의 생성 예이다.</p>

      <pre class="programlisting">create database link remote_<span>tibero</span> using 'remote_1';</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_gateway"/>12.4.3. 게이트웨이</h3></div></div></div>
      

      <p>데이터베이스 링크를 통해 질의를 수행할 때 데이터베이스 링크의 대상이 <span>Tibero</span>가 아닌 다른 DBMS라면 각각의 DBMS를 위한 게이트웨이를 통해 데이터베이스 링크를 수행할 수
      있다.</p>

      <p><span>Tibero</span> 서버는 다른 DBMS에 필요한 질의를 해당 게이트웨이에
      전달한다. 게이트웨이는 원격 DBMS에 접속하여 <span>Tibero</span> 서버로부터 전달 받은 질의를 수행하고 그 결과를 다시 <span>Tibero</span> 서버로 전송한다. 다른 DBMS로의 데이터베이스 링크 기능을 사용하는 경우에는 해당 DBMS에 대한
      게이트웨이 바이너리와 설정 파일이 필요하다.</p>

      <p>본 절에서는 DBMS 벤더별로 게이트웨이의 종류를 설명하고, 게이트웨이와 <span>Tibero</span> 서버가 같은 머신에 존재하는 경우와 다른 머신에 존재하는 경우를 알아본다. 또한 게이트웨이에서 제공하는 옵션
      및 로깅도 설명한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="sect_gateway_xa"/>DBMS 벤더별 게이트웨이<a id="d5e9513" class="indexterm"/></h4>

      <p>다음은 <span>Tibero</span>에서 데이터베이스 링크 기능을 지원하고 있는 다른 DBMS의
      종류와 게이트웨이 바이너리명이다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col width="100" align="left"/><col width="80" align="left"/><col/></colgroup><thead><tr><th align="left">DBMS 벤더명</th><th align="left"><p>게이트웨이 </p><p>바이너리명</p></th><th align="left"><p>프로그래밍 </p><p>언어</p></th><th>DBMS 버전</th></tr></thead><tbody><tr><td align="left">Oracle</td><td align="left">gw4orcl</td><td align="left">C</td><td><p>Oracle 9i, 10g, 11g, 12c, 18c,
              19c</p><p><span><strong class="guibutton">[참고]</strong></span></p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>Oracle 12c 이상 버전의 경우는 64-bit OS에서만 지원한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>Oracle 19c 게이트웨이의 경우 Linux 계열 머신은 지원하지 않는다.</p>
                  </li></ul></div></td></tr><tr><td align="left">DB2</td><td align="left">gw4db2</td><td align="left">C</td><td>DB2 V8, DB2 9, DB2 9.5</td></tr><tr><td align="left">MS-SQL SERVER</td><td align="left"><span>tbgateway</span>.jar</td><td align="left">Java</td><td>MS-SQL SERVER 2000, 2005, 2008</td></tr><tr><td align="left">Adaptive Server Enterprise(Sybase)</td><td align="left"><span>tb</span>gateway.jar</td><td align="left">Java</td><td>Sybase SQL Server 10.0.2 or later</td></tr><tr><td align="left">GREENPLUM</td><td align="left"><span>tb</span>gateway.jar</td><td align="left">Java</td><td>GREENPLUM or PostgreSQL</td></tr><tr><td align="left">MySQL</td><td align="left"><span>tb</span>gateway.jar</td><td align="left">Java</td><td>MySQL or MariaDB</td></tr></tbody></table>
      </div>

      <p>각각의 게이트웨이 바이너리는 DBMS의 버전에 따라 다를 수 있기 때문에 버전에 맞는 게이트웨이 바이너리를 사용할 것을
      권장한다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
          <p>1. DB2 게이트웨이의 경우 HP PA-RISC 머신은 지원하지 않는다.</p>

          <p>2. MySQL 게이트웨이의 경우 mysql-connector-java 5.1.19 이상의 버전 사용해야
          한다.</p>

          <p>3. 게이트웨이를 통해 Oracle의 프러시저를 수행하는 경우 해당 프러시저 내에서 local commit을
          수행할 수 없다.</p>
        </div>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9583"/>게이트웨이 프로세스 생성 방식</h4>

      <p>게이트웨이는 연결할 DBMS가 제공하는 라이브러리가 필요하다. 라이브러리를 <span>Tibero</span> 서버가 설치된 곳에서 사용할 수 있다면 <span>Tibero</span> 서버와 같은 머신 내에서 게이트웨이 프로세스를 생성하여 데이터베이스 링크 기능을 수행할 수 있다. 생성된
      게이트웨이 프로세스는 해당 데이터베이스 링크를 사용하는 세션이 닫힐 때 종료된다.</p>

      <p>다음은 Oracle 서버와 연결하는 데이터베이스 링크를 사용하기 위해 <span>tbdsn</span>.tbr 파일을 설정하는 예이다.</p>

      <p>&lt;&lt;<span>tbdsn</span>.tbr&gt;&gt;</p>

      <pre class="programlisting">ora_dblink=(
            (GATEWAY=(PROGRAM=gw4orcl)
                     (TARGET=orcl)
                     (TX_MODE=GLOBAL))
)</pre>

      <p>다음은 DB2 서버와 연결하는 데이터베이스 링크를 사용하기 위해 <span>tbdsn</span>.tbr 파일을 설정하는 예이다.</p>

      <p>&lt;&lt;<span>tbdsn</span>.tbr&gt;&gt;</p>

      <pre class="programlisting">db2_dblink=(
            (GATEWAY=(PROGRAM=gw4db2)
                     (TARGET=sample)
                     (TX_MODE=GLOBAL))
)</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">PROGRAM</td><td><p>게이트웨이 바이너리 위치에 대한 절대 경로이다.</p><p>게이트웨이 바이너리가
              $<span>TB_</span>HOME/client/bin 디렉터리에 있는 경우 바이너리명만
              명시할 수 있다.</p></td></tr><tr><td align="left">CONFIG</td><td>게이트웨이 설정 파일 위치에 대한 절대 경로이다.</td></tr><tr><td align="left">TARGET</td><td><p>DBMS별로 다음과 같이 의미하는 것이 다르다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>Oracle 서버 : 네트워크 서비스명이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>DB2 서버 : 데이터베이스명이다.</p>
                  </li></ul></div></td></tr><tr><td align="left">TX_MODE</td><td><p>글로벌 트랜잭션(Global Transaction) 또는 로컬 트랜잭션(Local
              Transaction)으로 처리할지의 여부를 설정한다.</p><p>글로벌 트랜잭션은 커밋을 요청할 때
              Two-phase 커밋으로 동작하고, 로컬 트랜잭션은 Two-phase 커밋으로 동작하지
              않는다.</p><p>TX_MODE의 값은 처리 여부에 따라 다음과 같이 설정할 수
              있다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>GLOBAL : 글로벌 트랜잭션인 경우</p>
                  </li><li style="list-style-type: circle">
                    <p>LOCAL : 로컬 트랜잭션인 경우</p>
                  </li></ul></div></td></tr><tr><td align="left">CHARACTER_SET</td><td>게이트웨이의 문자 집합을 재설정할 때 설정한다. <span>Tibero</span> 서버에서 지원하는 문자 집합을 사용할 수
              있다.</td></tr><tr><td align="left">SKIP_CHAR_CONV</td><td><p>게이트웨이의 초기화 파라미터 SKIP_CHAR_CONV 값을 재설정한다.
              </p><p>Y 혹은 y로 설정된 경우에 게이트웨이의 SKIP_CHAR_CONV의 값이 Y로 재설정되고,
              다른 값으로 설정된 경우에 게이트웨이의 SKIP_CHAR_CONV의 값이 N으로 재설정된다.
              </p><p>TARGET 서버가 Oracle 서버인 경우에만 설정 가능하다. SKIP_CHAR_CONV에
              대한 자세한 사항은 <a href="chapter_07.html#sect_c_gateway" title="12.4.3. 게이트웨이 설정(ORACLE, DB2)???TITLE???">게이트웨이 설정(ORACLE,
              DB2)</a>을 참고한다. </p></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9646"/>멀티 스레드 서버 방식<a id="d5e9647" class="indexterm"/></h4>

      <p>사용자는 <span>Tibero</span> 서버와 같은 머신 또는 원격에 있는 머신에서 게이트웨이를 멀티
      스레드 서버 방식으로 시작할 수 있다. <span>Tibero</span> 서버의 세션은 <span>tbdsn</span>.tbr 파일에 명시된 접속 정보를 통해 게이트웨이와 TCP/IP 통신을
      한다. 멀티 스레드 서버 방식의 게이트웨이는 <span>Tibero</span> 서버의 세션으로부터 요청이 오면 미리 생성된 워킹 스레드 중 하나가 해당 요청을 처리한다. 특히 Java
      프로그래밍 언어를 사용하는 게이트웨이는 멀티 스레드 서버 방식만을 지원한다.</p>

      <p>다음은 각 벤더별 서버와 연결하는 데이터베이스 링크를 사용하기 위해 <span>tbdsn</span>.tbr 파일을 설정하는 예와 항목에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>Oracle 서버</p>

          <pre class="programlisting">ora_link_remote=(
                 (GATEWAY=(LISTENER=(HOST=12.34.56.78)
                                    (PORT=9999))
                          (TARGET=orcl)
                          (TX_MODE=GLOBAL))
)     </pre>
        </li><li>
          <p>DB2 서버</p>

          <pre class="programlisting">db2_link_remote=(
                 (GATEWAY=(LISTENER=(HOST=12.34.56.78)
                                    (PORT=9999))
                          (TARGET=sample)
                          (TX_MODE=GLOBAL))
)     </pre>
        </li><li>
          <p>MS-SQL 서버</p>

          <p/>

          <pre class="programlisting">mssql_link_remote=(
                   (GATEWAY=(LISTENER=(HOST=12.34.56.78)
                                      (PORT=9093))
                            (TARGET=12.34.56.87:1433:master)
                            (TX_MODE=LOCAL))
)</pre>
        </li><li>
          <p>Sybase ASE 서버</p>

          <pre class="programlisting">ase_link_remote=(
                 (GATEWAY=(LISTENER=(HOST=12.34.56.78)
                                    (PORT=9093))
                          (TARGET=12.34.56.87:5000:master)
                          (TX_MODE=LOCAL))
)</pre>
        </li><li>
          <p>GREENPLUM 서버</p>

          <pre class="programlisting">gp_link_remote=(
                 (GATEWAY=(LISTENER=(HOST=12.34.56.78)
                                    (PORT=9093))
                          (TARGET=12.34.56.87:5432:mydb)
                          (TX_MODE=LOCAL))
)</pre>
        </li><li>
          <p>MySQL 서버</p>

          <pre class="programlisting">mysql_link_remote=(
                 (GATEWAY=(LISTENER=(HOST=12.34.56.78)
                                    (PORT=9093))
                          (TARGET=12.34.56.87:3306:mydb)
                          (TX_MODE=LOCAL))
)</pre>
        </li></ul></div>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">LISTENER</td><td><p>게이트웨이의 접속 정보이다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>HOST : 원격에 있는 머신에서 게이트웨이가 존재하는 호스트의 IP 주소를
                    설정한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>PORT : 원격에 있는 머신에서 게이트웨이가 존재하는 호스트의 포트 번호를
                    설정한다.</p>
                  </li></ul></div></td></tr><tr><td align="left">TARGET</td><td><p>DBMS별로 다음과 같이 의미하는 것이 다르다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>Oracle 서버: 네트워크 서비스명이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>DB2 서버 : 데이터베이스명이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>MS-SQL 서버 : 서버의 연결 정보(IP:PORT:DATABASE
                    NAME)이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>Sybase ASE 서버 : 서버의 연결 정보(IP:PORT:DATABASE
                    NAME)이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>GREENPLUM 서버 : 서버의 연결 정보(IP:PORT:DATABASE
                    NAME)이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>MySQL 서버 : 서버의 연결 정보(IP:PORT:DATABASE
                    NAME)이다.</p>
                  </li></ul></div></td></tr><tr><td align="left">TX_MODE</td><td><p>글로벌 트랜잭션(Global Transaction) 또는 로컬 트랜잭션(Local
              Transaction)으로 처리할지의 여부를 설정한다.</p><p>글로벌 트랜잭션은 커밋을 요청할 때
              Two-phase 커밋으로 동작하고, 로컬 트랜잭션은 Two-phase 커밋으로 동작하지
              않는다.</p><p>TX_MODE의 값은 처리 여부에 따라 다음과 같이 설정할 수
              있다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>GLOBAL : 글로벌 트랜잭션인 경우</p>
                  </li><li style="list-style-type: circle">
                    <p>LOCAL : 로컬 트랜잭션인 경우</p>
                  </li></ul></div></td></tr><tr><td align="left">CHARACTER_SET</td><td>게이트웨이의 문자 집합을 재설정할 때 설정한다. <span>Tibero</span> 서버에서 지원하는 문자 집합을 사용할 수 있다.
              C 언어를 사용하는 게이트웨이인 경우에만 설정 가능하다.</td></tr><tr><td align="left">SKIP_CHAR_CONV</td><td><p>게이트웨이의 초기화 파라미터 SKIP_CHAR_CONV의 값을 재설정할 때
              설정한다.</p><p>Y 혹은 y로 설정된 경우에 게이트웨이의 SKIP_CHAR_CONV의 값이 Y로
              재설정되고, N 혹은 n으로 설정된 경우에 게이트웨이의 SKIP_CHAR_CONV의 값이 N으로
              재설정된다.</p><p>TARGET 서버가 Oracle 서버인 경우에만 설정 가능하다.
              SKIP_CHAR_CONV에 대한 자세한 사항은 <a href="chapter_07.html#sect_c_gateway" title="12.4.3. 게이트웨이 설정(ORACLE, DB2)???TITLE???">게이트웨이
              설정(ORACLE, DB2)</a>을 참고한다. </p></td></tr><tr><td align="left">BYTES_CHARSET</td><td><p>TARGET 서버와 게이트웨이 사이의 문자 집합 변환에 사용되는 게이트웨이의 문자 집합을
              게이트웨이의 초기화 파라미터 ENCODING의 값과 다른 문자 집합으로 재설정할 때 설정한다. <span>Tibero</span> 서버에서 지원하는 문자 집합을 사용할 수
              있다.</p><p><span>Tibero</span> 서버가 한글을 지원하지 않는 문자 집합과 한글
              데이터를 동시에 사용하고 있는 특수한 경우에 사용한다. Java 프로그래밍 언어를 사용하는 게이트웨이인 경우에만
              설정 가능하다. </p></td></tr></tbody></table>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      <p>원격에 있는 게이트웨이를 사용하기 위해서는 먼저 원격에 있는 게이트웨이를 실행시켜야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>Oracle 서버</p>

          <pre class="programlisting">$ gw4orcl</pre>

          <p>Oracle과 DB2 서버용 게이트웨이의 경우 -q 옵션을 통해 기존에 수행 중인 게이트웨이를 종료할 수
          있다.</p>

          <pre class="programlisting">$ gw4orcl -q</pre>
        </li><li>
          <p>MS-SQL 서버</p>

          <pre class="programlisting">$ <span>tb</span>gw  </pre>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e9755"/>게이트웨이 관련 디렉터리 구조(ORACLE, DB2)<a id="d5e9756" class="indexterm"/></h4>

      <p>게이트웨이는 기본적으로 <span>TBGW</span>_HOME 환경변수를 통해 설정 파일을 읽고 로그 파일을
      기록한다.</p>

      <p><span>TBGW</span>_HOME 환경변수가 설정되어 있지 않은 경우에는 기본값은
      '${<span>TB_</span>HOME}/client/gateway'이다. Windows 환경에서는
      기본값이 '%<span>TB_</span>HOME%\client\gateway'로 설정된다.</p>

      <p>게이트웨이가 사용하는 설정 파일과 로그 파일이 존재하는 디렉터리 구조는 다음과 같다.</p>

      <pre class="programlisting">$<span>TBGW</span>_HOME
    |--- DBMS 벤더명
            |--- config
            |      |--- <span>tbgw</span>.cfg
            |--- log
                  |--- 게이트웨이의 로그 파일</pre>

      <p>위의 디렉터리 구조에서 $<span>TBGW</span>_HOME이라고 보이는 부분은 시스템 환경에 맞게 바꿔서 읽어야
      한다.</p>

      <div class="variablelist"><dl><dt><span class="term"><span><strong class="guibutton">DBMS 벤더명/config</strong></span></span></dt><dd>
            <p><span>tbgw</span>.cfg라는 게이트웨이 설정 파일이 있다. 사용자가 게이트웨이와
            관련된 설정 값을 변경하고 싶을 때 생성하며, 위의 디렉터리 구조에 맞게 위치시킨다.</p>
          </dd><dt><span class="term"><span><strong class="guibutton">DBMS 벤더명/log</strong></span></span></dt><dd>
            <p>게이트웨이와 관련된 로그 파일이 있다. 로그 파일은 DBMS 벤더명에 맞춰 생성된다.</p>

            <p>다음은 DBMS 벤더별 로그 파일이다.</p>

            <div class="informaltable">
              <table border="1"><colgroup><col width="100" align="left"/><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">DBMS 벤더명</th><th align="left">로그 파일명</th><th>리스너의 로그명</th></tr></thead><tbody><tr><td align="left">Oracle</td><td align="left">gw4orcl.log</td><td>gw4orcl_lsnr.log</td></tr><tr><td align="left">DB2</td><td align="left">gw4db2.log</td><td>gw4db2_lsnr.log</td></tr></tbody></table>
            </div>

            <p/>
          </dd></dl></div>

      <div class="literallayout"><p/></div>

      <h4><a id="sect_c_gateway"/>게이트웨이 설정(ORACLE, DB2)<a id="d5e9804" class="indexterm"/></h4>

      <p><span>tbgw</span>.cfg 파일에 초기화 파라미터의 설정 값을 명시함으로써 게이트웨이와
      관련된 설정을 변경할 수 있다.</p>

      <p>다음은 게이트웨이를 설정하는 예이다.</p>

      <p>&lt;&lt;<span>tbgw</span>.cfg&gt;&gt;</p>

      <pre class="programlisting">LOG_DIR=${<span class="emphasis"><em><span>TBGW</span>_HOME</em></span>}/{<span class="emphasis"><em>DBMS 벤더명</em></span>}/log
LOG_LVL=2
LISTENER_PORT=9999
MAX_LOG_SIZE=20k
FETCH_SIZE=32k</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">옵션</th><th>설명</th></tr></thead><tbody><tr><td align="left"><code class="filename">CHARACTER_SET</code></td><td>게이트웨이의 문자집합을 설정한다. 이 값이 설정되지 않은 경우 <span>TB_NLS_</span>LANG 환경변수에 정의된 값을 사용한다. (기본값:
              MSWIN949)</td></tr><tr><td align="left"><code class="filename">FETCH_SIZE</code></td><td>데이터베이스에 질의 처리를 할 때 한 번에 가져오는 데이터의 크기를 설정한다. (기본값: 32KB,
              최댓값: 64KB)</td></tr><tr><td align="left"><code class="filename">IGNORE_WARNING</code></td><td><p>원격 데이터베이스에서 발생한 경고 메시지를 무시할지 여부를 설정한다.
              </p><p>(기본값: N)</p></td></tr><tr><td align="left"><code class="filename">IP_VERSION</code></td><td><p>리스너가 사용하는 IP 프로토콜을 명시하기 위해 사용한다.
              </p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>4 : IPv4를 사용하는 경우 설정 값이다. (기본값)</p>
                  </li><li style="list-style-type: circle">
                    <p>6 : IPv6를 사용하는 경우 설정 값이다. 대상 DBMS가 Oracle인 경우에만 IPv6
                    사용이 가능하다.</p>
                  </li></ul></div></td></tr><tr><td align="left"><code class="filename">LOG_DIR</code></td><td><p>게이트웨이의 로그 파일을 저장할 경로를 설정한다. </p><p>(기본값:
              ${<span>TBGW</span>_HOME}/{<span class="emphasis"><em>DBMS
              벤더명</em></span>}/log)</p></td></tr><tr><td align="left"><code class="filename">LOG_LVL</code></td><td><p>로그 파일에 남길 로그 레벨을 설정한다. (기본값:
              2)</p><p><span><strong class="guibutton">[참고]</strong></span></p><p>게이트웨이
              프로세스가 이미 실행 중인 경우 게이트웨이 실행 명령어에 "-l [0~6 사이의 값]" 옵션을 주어 동적으로 로그
              레벨 변경이 가능하다. </p><pre class="programlisting">gw4orcl -l 4</pre></td></tr><tr><td align="left"><code class="filename">MAX_LOG_BACKUP_SIZE</code></td><td><p>로그 백업 기능을 사용하는 경우 백업 로그 파일들의 최대 크기이다.
              </p><p>(기본값: 0, 단위: Byte)</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>값이 0인 경우 백업된 로그 파일들의 크기 제한이 없다.</p>
                  </li><li style="list-style-type: circle">
                    <p>값을 명시한 경우 백업 로그 파일들의 크기의 합이 설정된 최대 크기를 초과하면 오래된 순서로
                    로그 파일을 지운다.</p>
                  </li></ul></div></td></tr><tr><td align="left"><code class="filename">MAX_LOG_SIZE</code></td><td><p>로그 파일의 최대 크기이다. (기본값: 0, 단위:
              Byte)</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>값이 0인 경우 로그 파일의 최대 크기를 설정하는 데 제한이 없다.</p>
                  </li><li style="list-style-type: circle">
                    <p>값을 명시한 경우 로그 파일이 설정된 최대 크기를 초과하면 로그 파일을 백업한다.</p>
                  </li></ul></div></td></tr><tr><td align="left"><code class="filename">ORACLE_FETCH_SIZE</code></td><td>Oracle용 게이트웨이에만 사용 가능한 옵션이다. Oracle에 질의 처리를 할 때, 한 번에
              가져오는 데이터의 크기이다. FETCH_SIZE보다 우선으로 적용된다. (기본값: 32KB, 최댓값:
              1MB)</td></tr><tr><td align="left"><code class="filename">QUERY_WITH_UR</code></td><td>DB2용 게이트웨이에만 사용 가능한 옵션이다. 쿼리에 WITH UR 구문을 추가할지 여부를 설정한다.
              (기본값: N)</td></tr><tr><td align="left"><code class="filename">SKIP_CHAR_CONV</code></td><td><p>Oracle용 게이트웨이에만 사용 가능한 옵션이다. Oracle에서 한글을 지원하지 않는
              문자 집합과 한글 데이터를 동시에 사용하고 있는 특수한 경우에 사용된다. </p><p>값이 Y인 경우
              Oracle 데이터베이스에 있는 데이터를 문자 집합 변환 없이 가져온다. (기본값: N)</p></td></tr><tr><td align="left"><code class="filename">VALIDATION_IDLE_TIME</code></td><td><p>Oracle용 게이트웨이에만 사용 가능한 옵션이다. (기본값: 0, 단위:
              초)</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>0이 아닌 값을 설정할 경우 설정한 만큼의 시간 간격마다 OCI Ping을 수행하여
                    Target 서버와의 Connection을 유지한다. (최댓값: 2,678,400)</p>
                  </li><li style="list-style-type: circle">
                    <p>값이 0인 경우 OCI Ping을 수행하지 않는다.</p>
                  </li></ul></div></td></tr></tbody></table>
      </div>

      <p>다음은 게이트웨이를 리스너 모드로 사용할 때 설정할 수 있는 옵션이다.</p>

      <p/>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left"><code class="filename">LISTENER_PORT</code></td><td>IPv4를 사용하거나 IPv6를 사용하는 경우 그에 대한 리스너 포트 번호를 설정한다. 설정한 포트
              번호의 값으로 포트가 오픈되며, 설정값+1의 추가 포트가 Statement Cancel을 처리하기 위해 오픈된다.
              (기본값: 9999)</td></tr><tr><td align="left"><code class="filename">MIN_POOL_SIZE</code></td><td>동시에 접속 가능한 최소 세션 개수를 설정한다. (기본값: 10)</td></tr><tr><td align="left"><code class="filename">MAX_POOL_SIZE</code></td><td>동시에 접속 가능한 최대 세션 개수를 설정한다. (기본값: 100, 최댓값: 1024)</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9935"/>게이트웨이 관련 디렉터리 구조(MS-SQL, Sybase ASE, GREENPLUM,
      MySQL)<a id="d5e9936" class="indexterm"/></h4>

      <p>사용자는 ${<span>TB_</span>HOME}/client/bin에 있는 <span>tb</span>JavaGW.zip 파일을 설치할 디렉터리에 복사한 후 압축을 해제한다.
      기본적으로 타깃 데이터베이스에 대한 JDBC 드라이버 파일(Sybase: jconn3.jar, MS-SQL:
      sqljdbc.jar, GREENPLUM: postgresql-8.4-701.jdbc3.jar)은 제공하지 않는다. 따라서
      사용자는 해당 서버의 JDBC 드라이버 파일을 구한 후 LIB 디렉터리에 복사해야 한다. 일반적으로 해당 서버의 홈페이지에서
      다운로드 받을 수 있다.</p>

      <p>게이트웨이가 사용하는 설정 파일과 로그 파일이 존재하는 디렉터리 구조는 다음과 같다.</p>

      <pre class="programlisting">설치 디렉터리
    |--- <span>tbJavaGW</span>
            |--- <span>tbgw</span>
            |--- jgw.cfg
            |--- jgwlog.properties
            |--- jgw_service.bat
            |--- prunsrv.exe
            |--- lib
                  |--- <span>tbgateway</span>.jar
                  |--- commons-collections.jar
                  |--- commons-daemon-1.0.6.jar
                  |--- commons-pool.jar
                  |--- log4j-1.2.15.jar
                  |--- jconn3.jar
                  |--- sqljdbc.jar
                  |--- postgresql-8.4-701.jdbc3.jar
            |--- log
                  | --- 게이트웨이의 로그 파일</pre>

      <div class="variablelist"><dl><dt><span class="term"><span><strong class="guibutton"><span>tbJavaGW</span>/<span>tbgw</span></strong></span></span></dt><dd>
            <p>Java 게이트웨이를 실행시키는 스크립트 파일이다.</p>
          </dd><dt><span class="term"><span><strong class="guibutton"><span>tbJavaGW</span>/jgw.cfg</strong></span></span></dt><dd>
            <p>게이트웨이 설정 파일이다. 사용자가 게이트웨이와 관련된 설정 값을 변경하고 싶을 때 생성하며 위의 디렉터리
            구조에 맞게 위치시킨다.</p>
          </dd><dt><span class="term"><span><strong class="guibutton"><span>tbJavaGW</span>/jgwlog.properties</strong></span></span></dt><dd>
            <p>로그에 대한 설정 파일이다. 로그 파일의 크기와 로그 레벨 등을 설정할 수 있다. 자세한 형식은 LOG4J를
            참고한다.</p>
          </dd><dt><span class="term"><span><strong class="guibutton"><span>tbJavaGW</span>/jgw_service.bat</strong></span></span></dt><dd>
            <p>Windows 환경에서 게이트웨이를 서비스로 사용할 수 있다. 서비스에 등록/삭제를 해주는 실행 파일이다.
            이 파일을 실행하기 위해선 <span>tbJavaGW</span>/prunsrv.exe 파일이 반드시 있어야
            한다.</p>
          </dd><dt><span class="term"><span><strong class="guibutton"><span>tbJavaGW</span>/prunsrv.exe</strong></span></span></dt><dd>
            <p>Windows 환경에서 게이트웨이를 서비스에 등록/삭제를 해주는 실행 파일이다. <span>tbJavaGW</span>/jgw_service.bat 파일을 실행하기 위해서
            반드시 필요한 파일이다. 이 파일은 기본으로 제공되지 않으며 Apache Commons의 Daemon에서 다운받을 수
            있다.</p>
          </dd><dt><span class="term"><span><strong class="guibutton"><span>tbJavaGW</span>/lib</strong></span></span></dt><dd>
            <p>Java 게이트웨이에서 사용하는 JAR 파일이 있는 디렉터리이다. 타깃 데이터베이스의 JDBC 드라이버도
            해당 디렉터리에 있어야 한다.</p>
          </dd><dt><span class="term"><span><strong class="guibutton"><span>tbJavaGW</span>/log</strong></span></span></dt><dd>
            <p>게이트웨이와 관련된 로그 파일이 생성된다.</p>
          </dd></dl></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e9993"/>게이트웨이 설정(MS-SQL SERVER, Sybase ASE, GREENPLUM,
      MySQL)<a id="d5e9994" class="indexterm"/></h4>

      <p>jgw.cfg 파일에 초기화 파라미터의 설정 값을 명시함으로써 게이트웨이와 관련된 설정을 변경할 수 있다.</p>

      <p>다음은 게이트웨이를 설정하는 예이다.</p>

      <p>&lt;&lt;jgw.cfg&gt;&gt;</p>

      <pre class="programlisting">DATABASE=SQL_SERVER
LISTENER_PORT=9093
INIT_POOL_SIZE=10
MAX_POOL_SIZE=1000
ENCODING=MSWIN949
MAX_LONGVARCHAR=4K
MAX_LONGRAW=4K</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">초기화 파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left"><code class="filename">DATABASE</code></td><td><p>타깃 데이터베이스를 설정한다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>SQL_SERVER : MS-SQL SERVER (기본값)</p>
                  </li><li style="list-style-type: circle">
                    <p>ASE : Sybase ASE</p>
                  </li><li style="list-style-type: circle">
                    <p>GREENPLUM : GREENPLUM</p>
                  </li><li style="list-style-type: circle">
                    <p>MYSQL : MySQL</p>
                  </li></ul></div></td></tr><tr><td align="left"><code class="filename">LISTENER_PORT</code></td><td>리스너의 포트 번호를 설정한다. 일반적인 요청의 처리를 위해 설정한 번호의 포트를 사용하며,
              Statement cancel 등의 제어 요청 처리를 위해 설정에 1을 더한 번호의 포트를 추가로 사용한다.
              (기본값: 9093)</td></tr><tr><td align="left"><code class="filename">INIT_POOL_SIZE</code></td><td><p>게이트웨이가 시작할 때 미리 생성할 워킹 스레드의 개수를 설정한다.
              </p><p>(기본값: 10)</p></td></tr><tr><td align="left"><code class="filename">MAX_POOL_SIZE</code></td><td><p>게이트웨이가 최대로 생성할 수 있는 워킹 스레드의 개수를 설정한다.
              </p><p>(기본값: 100)</p></td></tr><tr><td align="left"><code class="filename">MAX_CURSOR_CACHE_SIZE</code></td><td>워킹 스레드 당 최대로 캐시 가능한 커서의 개수를 설정한다. (기본값: 100)</td></tr><tr><td align="left"><code class="filename">ENCODING</code></td><td><p><span>Tibero</span> 서버의 세션에 문자열을 전달할 때 사용할
              인코딩을 설정한다. 단, <span>Tibero</span> 서버의 문자 집합과 일치시켜야 한다.
              </p><p>설정할 수 있는 문자 집합은 다음과 같다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>ASCII</p>
                  </li><li style="list-style-type: circle">
                    <p>EUC-KR</p>
                  </li><li style="list-style-type: circle">
                    <p>MSWIN949 (기본값)</p>
                  </li><li style="list-style-type: circle">
                    <p>UTF-8</p>
                  </li><li style="list-style-type: circle">
                    <p>UTF-16</p>
                  </li><li style="list-style-type: circle">
                    <p>SHIFT-JIS</p>
                  </li></ul></div></td></tr><tr><td align="left"><code class="filename">MAX_LONGVARCHAR</code></td><td><p>게이트웨이는 LONG, CLOB 타입의 데이터를 일정 간격을 정하여 가져오는
              방식(Deferred 형태)을 지원하지 않는다. CHAR나 VARCHAR 타입처럼 한 번에 읽어 오게 되는데 그때
              읽어올 수 있는 최대 크기를 설정한다.</p><p>(기본값: 4KB, 최댓값:
              32KB)</p></td></tr><tr><td align="left"><code class="filename">MAX_LONGRAW</code></td><td><p>게이트웨이는 LONG RAW, BLOB 타입의 데이터를 일정 간격을 정하여 가져오는 방식을
              지원하지 않는다. RAW처럼 한 번에 읽어 오게 되는데 그때 읽어올 수 있는 최대 크기를 설정한다.
              </p><p>(기본값: 4KB, 최댓값: 32KB)</p></td></tr><tr><td align="left"><code class="filename">TARGET_DB_FETCH_SIZE</code></td><td><p>TARGET DB에서 한 번에 FETCH해 올 row 수를 설정한다. (기본값:
              32)</p><p>MySQL의 경우 -2147483648(interger.MIN_VALUE)로 설정하면
              1 row씩, 그 외의 값이면 모든 row를 한 번에 FETCH해온다.</p></td></tr><tr><td align="left"><code class="filename">VALIDATION_QUERY</code></td><td><p>게이트웨이에서 타깃 데이터베이스로의 연결이 유효한지 확인하기 위한 SQL 문장을 지정한다.
              이 값이 설정되어 있다면 다음의 경우에 연결 확인 과정이 수행된다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p><span>Tibero</span> 서버로부터 연결 확인 요청이 오는
                    경우</p>
                  </li><li style="list-style-type: circle">
                    <p>동일한 연결 내에서 마지막 수행 이후 VALIDATION_IDLE_TIME 설정에 지정된
                    시간동안 새로운 요청이 오지 않는 경우</p>
                  </li></ul></div></td></tr><tr><td align="left"><code class="filename">VALIDATION_IDLE_TIME</code></td><td><p>마지막 요청 이후 연결 유효 확인을 수행할 때까지의 대기 시간을 설정한다. 단위는
              밀리초이며, 0은 무제한을 의미한다. (기본값: 0, 최솟값:
              60000)</p><p>VALIDATION_QUERY 항목이 설정되어 있는 경우에만 함께
              적용된다.</p></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e10099"/>게이트웨이 바이너리의 버전</h4>

      <p>게이트웨이 바이너리의 버전은 다음과 같은 명령을 실행하여 확인할 수 있다.</p>

      <pre class="programlisting">$ gw4orcl -v

<span>tbGateway</span> for oracle : Release 4 Trunk (Build 31190)

Linux <span>Tibero</span>_Linux 2.6.22-16-generic #1 SMP Mon Nov 24 17:50:35
   GMT 2008 x86_64 GNU/Linux version (little-endian)</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e10104"/>12.4.4. 데이터베이스 링크 사용</h3></div></div></div>
      

      <p>데이터베이스 링크를 통해 접근할 수 있는 데이터베이스 객체의 종류는 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>테이블(LOB 타입의 컬럼에는 접근할 수 없다.)</p>
        </li><li>
          <p>뷰</p>
        </li><li>
          <p>시퀀스</p>
        </li></ul></div>

      <p>데이터베이스 링크를 통해 Oracle의 LONG 타입 컬럼을 접근할 때 LONG 타입의 컬럼은 항상 마지막 컬럼으로
      설정하여 접근해야 한다. 데이터베이스 링크를 사용할 수 있는 SQL 문장은 SELECT, INSERT, UPDATE, DELETE
      이다. 단, SELECT 문에서 FOR UPDATE 절은 사용할 수 없다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e10116"/>12.4.5. Global Consistency<a id="d5e10118" class="indexterm"/></h3></div></div></div>
      

      <p>Homogeneous DB Link로 구성된 분산 트랜잭션은 <span><strong class="guibutton">Global
      Consistency</strong></span>를 제공한다. 이를 위해 분산 트랜잭션에 참여한 데이터베이스 간에 TSN을 동기화하는
      작업을 한다. TSN을 동기화하는 작업은 데이터베이스 사이에 메시지를 교환할 때 이루어지며, 커밋할 때에는 모든 노드의
      Commit TSN을 동일하게 동기화해야 한다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e10123"/>12.4.6. 데이터베이스 링크 In-doubt 트랜잭션 처리</h3></div></div></div>
      

      <p>정체되고 있는 TX에 대한 처리는 XA의 경우와 동일하다. 본 절에서는 Two-phase commit
      mechanism에서 XA와의 차이점을 설명한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e10127"/>commit point site<a id="d5e10128" class="indexterm"/></h4>

      <p>데이터베이스 링크를 사용한 분산 트랜잭션에서는 트랜잭션에 참여한 노드 중에서 commit point site를
      선정한다.</p>

      <p>commit point site는 Two-phase commit을 시작할 때 설정하며 세션 트리를 따라가며 가장 큰
      commit point strength를 가진 노드를 선택한다. 각 데이터베이스는 commit point strength를
      가지는데 이 값은 초기화 파라미터 <code class="filename">COMMIT_POINT_STRENGTH</code>로 설정할 수
      있다.</p>

      <p>commit point site는 Two-phase commit의 prepare phase에서 prepare를 하지
      않는다. 대신 모든 노드가 prepare를 한 이후에 commit point site를 바로 커밋한다. 그 이후에 다른 노드들은
      commit phase를 실행한다.</p>

      <p>데이터베이스 링크에서 이와 같이 수정된 Two-phase commit을 사용하는 이유는 Global
      consistency를 보장하기 위해 생기는 오버헤드를 줄이기 위해서이다. 데이터베이스 링크에서 Global
      consistency를 보장하기 위해서는 모든 노드의 Commit TSN을 동일하게 해야 한다. Commit TSN은
      prepare phase까지 완료한 노드 중 가장 큰 TSN으로 결정하고 commit phase에서 결정된 TSN을 사용해 커밋을
      한다.</p>

      <p>commit phase 전에는 Commit TSN을 모르기 때문에 다른 트랜잭션에서 해당 트랜잭션의 수정 정보의 조회
      여부를 결정할 수 없다. 다른 트랜잭션에서 prepare된 TX가 수정한 내용에 접근하는 경우 다음과 같은 에러가 발생한다.
      </p><pre class="programlisting">TBR-21019: lock held by in-doubt distributed transaction.</pre><p>데이터베이스
      링크를 사용할 때 prepare 상태에서 정체가 발생하는 경우 해당 데이터에 접근할 수 없기 때문에 In-doubt 트랜잭션으로
      인한 문제가 발생된다.</p>

      <p>이와 같은 문제를 경감하기 위해 트랜잭션에 참여한 노드 중 한 노드는 prepare phase를 거치지 않고,
      트랜잭션이 in-doubt 상태가 되더라도 commit point site는 위와 같이 데이터를 접근하지 못하는 상황을 방지할 수
      있도록 하였다. 따라서 commit point strength는 데이터 접근성이 많이 필요한 데이터베이스일수록 큰 값을 설정해야
      한다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e10139"/>12.4.7. 데이터베이스 링크 정보 조회<a id="d5e10141" class="indexterm"/></h3></div></div></div>
      

      <p><span>Tibero</span>에서는 생성한 데이터베이스 링크의 정보를 제공하기 위해 다음
      표에 나열된 정적 뷰를 제공하고 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">정적 뷰</th><th>설명</th></tr></thead><tbody><tr><td align="left">DBA_DB_LINKS<a id="d5e10155" class="indexterm"/><a id="d5e10158" class="indexterm"/></td><td><span>Tibero</span> 내의 모든 데이터베이스 링크의 정보를 보여주는
              뷰이다. DBA만 사용할 수 있는 뷰이다.</td></tr><tr><td align="left">ALL_DB_LINKS<a id="d5e10164" class="indexterm"/><a id="d5e10167" class="indexterm"/></td><td>현재 사용자가 이용할 수 있는 모든 데이터베이스 링크의 정보를 보여주는 뷰이다.</td></tr><tr><td align="left">USER_DB_LINKS<a id="d5e10172" class="indexterm"/><a id="d5e10175" class="indexterm"/></td><td>현재 사용자가 생성한 데이터베이스 링크의 정보를 보여주는 뷰이다.</td></tr></tbody></table>
      </div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>정적 뷰에 대한 자세한 내용은 "<span>Tibero</span> 참조 안내서"를 참고한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e10182"/>V$DBLINK<a id="d5e10183" class="indexterm"/></h4>

      <p>동적 뷰 V$DBLINK는 해당 세션에서 원격 데이터베이스에 연결된 데이터베이스 링크의 정보를 보여주는
      뷰이다.</p>

      <p>사용자가 데이터베이스 링크를 통해 질의를 수행하면 원격 데이터베이스에 연결을 생성하고, 해당 질의 또는 트랜잭션이
      종료되어도 연결을 해제하지 않고 계속 유지된다. 즉, 같은 데이터베이스 링크를 사용했을 때 발생하는 연결의 비용을 줄이기
      위함이다. 이렇게 생성된 연결은 세션이 종료 또는 명시적으로 연결을 종료할 때까지 계속 유지된다.</p>

      <p>다음은 remote_<span>tibero</span>를 통해 SELECT 문을 수행한 후 V$DBLINK를 통해 연결
      정보를 조회하는 예이다.</p>

      <pre class="programlisting">SQL&gt; select * from employee@remote_<span>tibero</span>;

 ID     NAME
--- ---------
  1      KIM
  2      LEE
  3     HONG

3 rows selected.

SQL&gt; select * from V$DBLINK;

DB_LINK         OWNER_ID   OPEN_CURSORS   IN_TRANSACTION  HETEROGENEOUS
-------------  ----------  ------------   --------------  -------------
REMOTE_<span>TIBERO</span>         15             0    YES             NO

COMMIT_POINT_STRENGTH
---------------------
                  1

1 row selected.</pre>

      <p>현재 remote_<span>tibero</span>의 소유자의 ID는 15번이고, 현재 열려 있는 커서는 없으며
      트랜잭션을 수행하고 있다. 동일한 <span>Tibero</span> 서버에 대한 데이터베이스 링크이며, 원격 데이터베이스의
      commit point strength는 1이다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 데이터베이스 링크 기능을 종료하는 예이다.</p><pre class="programlisting">SQL&gt; alter session close database link remote_<span>tibero</span>;<span><strong class="guibutton">
TBR-12056: database link is in use.</strong></span>                       <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>

SQL&gt; <span><strong class="guibutton">commit;</strong></span>                                              <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
Commit succeeded.

SQL&gt; <span><strong class="guibutton">alter session close database link remote_<span>tibero</span>;</strong></span>     <em class="lineannotation"><span class="lineannotation">... ③ ...</span></em>
Session altered.

SQL&gt; select * from <span><strong class="guibutton">V$DBLINK</strong></span>;                              <em class="lineannotation"><span class="lineannotation">... ④ ...</span></em>

DB_LINK          OWNER_ID   OPEN_CURSORS   IN_TRANSACTION  HETEROGENEOUS
--------------  ----------  ------------   --------------  -------------

COMMIT_POINT_STRENGTH
---------------------

0 row selected.     </pre><p>① 데이터베이스 링크 기능을 종료하려는 시도가 실패한 이유는 해당
      데이터베이스 링크를 사용한 트랜잭션이 아직 수행 중이기 때문이다.</p>

      <p>② commit 문을 통해 해당 트랜잭션을 종료한다.</p>

      <p>③ 다시 데이터베이스 링크 기능의 종료를 시도한다.</p>

      <p>④ 정상적으로 데이터베이스 링크가 종료되며 이를 확인하는 방법은 V$DBLINK를 통해 확인할 수 있다.</p>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_backuprecovery.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_standby_cluster.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제11장 백업과 복구 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제13장 <span>Tibero</span> Standby Cluster</td></tr></table></div><div xmlns="" align="center"/></body></html>