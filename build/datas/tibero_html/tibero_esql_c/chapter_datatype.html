<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제2장 데이터 타입</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="up" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="prev" href="chapter_introduce.html" title="제1장 tbESQL/C 소개"/><link rel="next" href="ch03.html" title="제3장 기본 프로그래밍"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제2장 데이터 타입</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_introduce.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="ch03.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_datatype"/>제2장 데이터 타입</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_datatype.html#d5e653">2.1. 개요</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#sect_datatype">2.2. <span>Tibero</span> 데이터 타입</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#sect_tbesql_c_datatype">2.3. <span>tbESQL</span>/C 데이터 타입</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_datatype.html#sect_datatype_corre">2.3.1. 데이터 타입 대응</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#sect_datatype_convert">2.3.2. 데이터 타입 변환</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#d5e1077">2.3.3. 데이터 변수 사용</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#sect_rowid">2.3.4. ROWID</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#sect_varchar">2.3.5. VARCHAR</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#sect_struct">2.3.6. 구조체</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#d5e1259">2.3.7. 포인터</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#sect_indicator">2.3.8. 지시자</a></span></dt><dt><span class="section"><a href="chapter_datatype.html#sect_datatype_equivalencing">2.3.9. 데이터 타입 동격화</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 <span>tbESQL</span>/C 프로그램에서 사용하는 데이터 타입을 알아보고 데이터 타입 간의 대응을
  설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e653"/>2.1. 개요</h2></div></div></div>
    

    <p><span>tbESQL</span>/COBOL 프로그램에서 데이터 타입은 <span>tbESQL</span>/C 문장에 값을 입력하고, 질의 결과를 얻기 위해 사용한다.</p>

    <p><span>tbESQL</span>/C는 다음과 같이 두 가지 타입을 지원한다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p><a href="chapter_datatype.html#sect_datatype" title="2.2. Tibero 데이터 타입"><span>Tibero</span>의 데이터 타입</a></p>

        <p>데이터베이스에 저장된 데이터에 접근할 때 사용한다.</p>
      </li><li>
        <p><a href="chapter_datatype.html#sect_tbesql_c_datatype" title="2.3. tbESQL/C 데이터 타입"><span>tbESQL</span>/C의 데이터 타입</a></p>

        <p>애플리케이션 프로그램에서 데이터를 조작할 때 사용한다.</p>
      </li></ul></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_datatype"/>2.2. <span>Tibero</span> 데이터 타입</h2></div></div></div>
    

    <p>본 절에서는 <span>Tibero</span>에서 디폴트로 제공하는 데이터 타입을 간략히 설명한다. 이러한
    데이터 타입은 데이터베이스의 스키마 객체를 생성하는 데 사용하는 것으로 <span>tbESQL</span>/C 프로그램 내에서도 모든 데이터 타입에 대응되는 변수를 사용할 수
    있다.</p>

    <div class="literallayout"><p/></div>

    <p>다음은 <span>Tibero</span>의 데이터 타입이다.<a id="d5e680" class="indexterm"/></p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="130" align="left"/><col width="200" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th align="left">데이터 타입</th><th>설명</th></tr></thead><tbody><tr><td align="left">문자형<a id="d5e695" class="indexterm"/></td><td align="left">CHAR, VARCHAR, NCHAR, NVARCHAR, RAW, LONG, LONG RAW</td><td>문자열을 표현하는 데이터 타입이다.</td></tr><tr><td align="left">숫자형<a id="d5e701" class="indexterm"/></td><td align="left">NUMBER, INTEGER, FLOAT, BINARY_FLOAT, BINARY_DOUBLE</td><td>정수나 실수의 숫자를 저장하는 데이터 타입이다.</td></tr><tr><td align="left">날짜형<a id="d5e707" class="indexterm"/></td><td align="left">DATE, TIME, TIMESTAMP</td><td>시간이나 날짜를 저장하는 데이터 타입이다.</td></tr><tr><td align="left">대용량 객체형<a id="d5e713" class="indexterm"/></td><td align="left">BLOB, CLOB</td><td>LOB 타입을 의미한다. 다른 데이터 타입이 지원하는 최대 길이(8KB 이하)보다 훨씬 큰 길이를 가질 수
            있는 객체이다. 4GB까지 가능하다.</td></tr><tr><td align="left">내재형<a id="d5e719" class="indexterm"/></td><td align="left">ROWID</td><td>사용자가 명시적으로 선언하지 않아도 <span>Tibero</span>가 자동으로 삽입되는 로우마다 포함하는 컬럼의 타입이다.</td></tr></tbody></table>
    </div>

    <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
      <p>자세한 내용은 "<span>Tibero</span> SQL 참조 안내서"를 참고한다.</p>
    </div>

    <p/>

    <div class="literallayout"><p/></div>

    <p>다음은 각 데이터 타입에 대한 세부 설명이다.</p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="130" align="left"/><col/></colgroup><thead><tr><th align="left">데이터 타입</th><th>설명</th></tr></thead><tbody><tr><td align="left">CHAR<a id="d5e740" class="indexterm"/></td><td>일반 문자열을 저장하는 데이터 타입이다. (예: CHAR(10))</td></tr><tr><td align="left">VARCHAR<a id="d5e745" class="indexterm"/></td><td>일반 문자열을 저장하는 데이터 타입이다. (예: VARCHAR(10))</td></tr><tr><td align="left">NCHAR<a id="d5e750" class="indexterm"/></td><td>유니코드 문자열을 저장하기 위한 데이터 타입이다. 타입의 길이는 다국어 문자 집합에 따라 달라진다. (예:
            NCHAR(10))</td></tr><tr><td align="left">NVARCHAR<a id="d5e755" class="indexterm"/></td><td>유니코드 문자열을 저장하기 위한 데이터 타입이다. 타입의 길이는 다국어 문자 집합에 따라 달라진다. (예:
            NVARCHAR(10))</td></tr><tr><td align="left">RAW<a id="d5e760" class="indexterm"/></td><td>임의의 바이너리 데이터를 저장하는 데이터 타입이다. (예: RAW(10))</td></tr><tr><td align="left">LONG<a id="d5e765" class="indexterm"/></td><td>VARCHAR 타입을 확장한 데이터 타입이다. VARCHAR 타입과 마찬가지로 문자열이 저장된다. 테이블
            내에 한 칼럼에만 선언할 수 있으며, 최대 2GB까지 선언할 수 있다. (예: LONG)</td></tr><tr><td align="left">LONG RAW<a id="d5e770" class="indexterm"/></td><td>RAW 타입을 확장한 데이터 타입이다. RAW 타입과 마찬가지로 바이너리 데이터가 저장된다. 테이블 내에
            한 칼럼에만 선언할 수 있으며, 최대 2GB까지 선언할 수 있다. (예: LONG RAW)</td></tr><tr><td align="left">NUMBER<a id="d5e775" class="indexterm"/></td><td><p>정수 또는 실수를 저장하는 타입이다.</p><p>NUMBER 타입을 선언할 때
            정밀도와 스케일을 함께 선언할 수 있다.<a id="d5e780" class="indexterm"/><a id="d5e782" class="indexterm"/></p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                  <p>정밀도 : 데이터 값의 전체 자릿수</p>
                </li><li style="list-style-type: circle">
                  <p>스케일 : 소수점 이하 자릿수</p>
                </li></ul></div></td></tr><tr><td align="left"><p>INTEGER<a id="d5e792" class="indexterm"/></p><p>FLOAT<a id="d5e795" class="indexterm"/></p></td><td>기본적으로는 NUMBER 타입이다. 단, NUMBER 타입과는 다르게 정밀도와 스케일을 선언할 때 범위에
            한계를 둔다. NUMBER 타입의 값은 <span>Tibero</span>에서 가변 길이로 저장되며, 실제 값과 정밀도, 스케일에 따라 그 길이가 달라진다.</td></tr><tr><td align="left">BINARY_FLOAT<a id="d5e801" class="indexterm"/></td><td><p>실수나 정수를 표현하고, 32비트로 저장하는 단일 정밀도 데이터
            타입이다.</p><p>음양으로 절댓값이 1.17549E-38보다 크거나 같고, 3.40282E+38보다 작은
            수를 표현할 수 있다.</p></td></tr><tr><td align="left">BINARY_DOUBLE<a id="d5e808" class="indexterm"/></td><td><p>실수나 정수를 표현하고, 64비트로 저장하는 단일 정밀도 데이터
            타입이다.</p><p>음양으로 절댓값이 2.22507485850720E-308보다 크거나 같고,
            1.79769313486231E+308보다 작은 수를 표현할 수 있다.</p></td></tr><tr><td align="left"><p>DATE<a id="d5e816" class="indexterm"/></p><p>TIME<a id="d5e819" class="indexterm"/></p><p>TIMESTAMP<a id="d5e822" class="indexterm"/></p></td><td><p>특정 날짜와 시간을 나타내는 데이터 타입이다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                  <p>DATE : 특정 날짜</p>
                </li><li style="list-style-type: circle">
                  <p>TIME : 특정 시간</p>
                </li><li style="list-style-type: circle">
                  <p>TIMESTAMP : 특정 날짜와 시간</p>
                </li></ul></div></td></tr><tr><td align="left">BLOB<a id="d5e835" class="indexterm"/></td><td><p>임의의 바이너리 데이터를 데이터베이스에 저장하는 데이터 타입이다.</p><p>한
            테이블의 여러 컬럼에 선언할 수 있다.</p></td></tr><tr><td align="left">CLOB<a id="d5e842" class="indexterm"/></td><td><p>읽을 수 있는 문자열을 데이터베이스에 저장하는 데이터 타입이다.</p><p>한
            테이블의 여러 컬럼에 선언할 수 있다.</p></td></tr><tr><td align="left">ROWID<a id="d5e849" class="indexterm"/></td><td>데이터베이스 내의 각 로우를 식별하기 위해 <span>Tibero</span> 시스템이 각 로우마다 자동으로 부여하는 데이터 타입이다. 각 로우가 저장된 물리적인 위치를
            포함한다.</td></tr></tbody></table>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_tbesql_c_datatype"/>2.3. <span>tbESQL</span>/C 데이터 타입<a id="d5e856" class="indexterm"/></h2></div></div></div>
    

    <p>본 절에서는 <span>tbESQL</span>/C의 데이터 타입을 설명한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_datatype_corre"/>2.3.1. 데이터 타입 대응</h3></div></div></div>
      

      <p><span>Tibero</span>에서 제공하는 데이터 타입을 <span>tbESQL</span>/C 프로그램에서 그대로 사용할 수는 없다. <span>tbESQL</span>/C에는 <span>Tibero</span>의 각 데이터 타입에 대응되는 <span>tbESQL</span>/C의 데이터 타입이 정의되어 있다.</p>

      <p><span>tbESQL</span>/C의 데이터 타입은 대체로 C 프로그래밍 언어의 데이터 타입과
      동일하다. 또한 각 <span>Tibero</span>의 데이터 타입에 대응되는 <span>tbESQL</span>/C의 데이터 타입은 하나 이상일 수도 있다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 <span>Tibero</span>의 데이터 타입에 대응되는 <span>tbESQL</span>/C의 데이터 타입이다.<a id="d5e877" class="indexterm"/></p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="190" align="left"/><col width="170" align="left"/><col/></colgroup><thead><tr><th align="left"><span>Tibero</span>의 데이터 타입</th><th align="left"><span>tbESQL</span>/C의 데이터 타입</th><th>설명</th></tr></thead><tbody><tr><td rowspan="3" align="left">CHAR, VARCHAR<a id="d5e895" class="indexterm"/><a id="d5e897" class="indexterm"/></td><td align="left">char</td><td>하나의 문자</td></tr><tr><td align="left">char[n]</td><td>길이 n의 문자열</td></tr><tr><td align="left">varchar[n]</td><td>길이 n의 문자열</td></tr><tr><td rowspan="2" align="left">RAW<a id="d5e909" class="indexterm"/></td><td align="left">unsigned char[n]</td><td>길이 n의 바이너리 데이터</td></tr><tr><td align="left">varchar[n]</td><td>길이 n의 바이너리 데이터</td></tr><tr><td rowspan="2" align="left">NUMBER<a id="d5e918" class="indexterm"/></td><td align="left">int, short, long</td><td>정수 데이터</td></tr><tr><td align="left">float, double</td><td><p>실수 데이터</p><p>(데이터가 삽입될 때 이미 정해진 컬럼의 정밀도 및
              스케일을 초과할 수 있다.)</p></td></tr><tr><td rowspan="4" align="left">DATE, TIME, TIMESTAMP<a id="d5e929" class="indexterm"/><a id="d5e931" class="indexterm"/><a id="d5e933" class="indexterm"/></td><td align="left">char[n]</td><td>길이 n의 문자열로 변환</td></tr><tr><td align="left">varchar[n]</td><td>길이 n의 문자열로 변환</td></tr><tr><td align="left">unsigned char[n]</td><td>길이 n의 바이너리 데이터</td></tr><tr><td align="left">varchar[n]</td><td>길이 n의 문자열 또는 바이너리 데이터</td></tr><tr><td rowspan="2" align="left">ROWID<a id="d5e948" class="indexterm"/></td><td align="left">unsigned char[n]</td><td>길이 n의 문자열로 변환</td></tr><tr><td align="left">varchar[n]</td><td>길이 n의 문자열로 변환</td></tr></tbody></table>
      </div>

      <p><span>tbESQL</span>/C의 데이터 타입 중 <span><strong class="guibutton">VARCHAR
      타입</strong></span>은 <span>Tibero</span>의 데이터 타입 중에 VARCHAR 타입을 비롯한 여러 가지
      타입에 대응하기 위해 새롭게 정의된 타입이다.</p>

      <p><span>tbESQL</span>/C 프로그램에서는 각 데이터 타입 간의 변환을 지원한다. 예를 들어
      VARCHAR 타입의 문자열이 정수를 표현하고 있는 내용이라면, 그 값을 int 타입의 변수에 저장할 수 있다.</p>

      <p>또한 실제로 DATE, TIME, TIMESTAMP 타입과 ROWID 타입에 바로 대응되는 타입은 없으며, 항상 변환
      과정을 거쳐서 저장해야 한다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>VARCHAR 타입의 자세한 내용은 <a href="chapter_datatype.html#sect_varchar" title="2.3.5. VARCHAR">“2.3.5. VARCHAR”</a>를
        참고한다.</p>
      </div>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_datatype_convert"/>2.3.2. 데이터 타입 변환</h3></div></div></div>
      

      <p><span>tbESQL</span>/C 프로그램에서는 <span>Tibero</span> 데이터 타입 각각에 대응되는 타입 이외에 다른 데이터 타입을 사용할 수 있다. 예를 들면 데이터베이스의
      NUMBER 타입의 컬럼 값을 저장하기 위해 <span>tbESQL</span>/C 프로그램에서는 출력 변수로 VARCHAR 타입을 사용할 수 있다.
      이와 반대로, NUMBER 타입 프로그램 변수의 값을 VARCHAR 타입의 컬럼에 저장할 수도 있다.</p>

      <p><span>tbESQL</span>/C 프로그램을 프리컴파일하면 입/출력 변수의 데이터 타입이 프로그램
      내에 함께 포함된다. 이렇게 포함된 데이터 타입을 기준으로 데이터의 값이 입/출력될 때 컬럼 타입과 비교하여 필요한 경우에는
      데이터 타입의 변환을 수행한다. 만약 데이터 타입의 변환이 불가능한 경우에는 에러를 반환한다.</p>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e976"/>변환 가능한 데이터 타입</h4>

      <p>다음은 <span>Tibero</span> 데이터 타입으로부터 변환 가능한 <span>tbESQL</span>/C 데이터 타입이다. 자세한 내용은 <a href="chapter_datatype.html#sect_datatype_corre" title="2.3.1. 데이터 타입 대응">“2.3.1. 데이터 타입 대응”</a>에 일부 내용이 포함되어 있다.<a id="d5e981" class="indexterm"/></p>

      <p/>

      <div class="informaltable">
        <table border="1"><colgroup><col width="220" align="left"/><col width="190" align="left"/><col/></colgroup><thead><tr><th align="left"><span>Tibero</span>의 데이터 타입</th><th align="left"><span>tbESQL</span>/C의 데이터 타입</th><th>설명</th></tr></thead><tbody><tr><td rowspan="2" align="left">NUMBER<a id="d5e998" class="indexterm"/></td><td align="left">int, short, long</td><td>정수 데이터</td></tr><tr><td align="left">float, double</td><td>실수 데이터</td></tr><tr><td rowspan="2" align="left">CHAR, VARCHAR<a id="d5e1007" class="indexterm"/><a id="d5e1009" class="indexterm"/></td><td align="left">char</td><td>문자 데이터</td></tr><tr><td align="left">char[n], varchar[n]</td><td>문자열 데이터</td></tr><tr><td align="left">DATE, TIME, TIMESTAMP<a id="d5e1018" class="indexterm"/><a id="d5e1020" class="indexterm"/><a id="d5e1022" class="indexterm"/></td><td align="left">char[n], varchar[n]</td><td>날짜형 데이터</td></tr><tr><td align="left">ROWID<a id="d5e1028" class="indexterm"/></td><td align="left">unsigned char[n], varchar[n]</td><td>ROWID 데이터</td></tr></tbody></table>
      </div>

      <p><span>tbESQL</span>/C 데이터 타입으로부터 <span>Tibero</span> 데이터 타입으로 변환할 때에도 위의 변환 관계가 적용된다. 예를 들어 <span>tbESQL</span>/C 프로그램의 int 타입의 변수 값을 VARCHAR 타입 컬럼에
      저장할 수 있으며, VARCHAR 타입 값을 이용하여 ROWID에 대한 질의를 수행할 수 있다.</p>

      <p>다음은 데이터 타입의 변환을 수행하는 예이다.</p>

      <div class="example"><a id="ex_datatype"/><p class="title"><b>[예 2.1] 데이터 타입의 변환</b></p><div class="example-contents">
        

        

        <pre class="programlisting">VARCHAR sal_str[8];
VARCHAR emp_date[20];
...
EXEC SQL SELECT SALARY, EMP_DATE
    INTO :sal_str, :emp_date
    FROM EMP
    WHERE EMPNO = 20;

printf("salary = %s\n", sal_str.arr);
printf("emp_date = %s\n", emp_date.arr);</pre>
      </div></div><br class="example-break"/>

      <p>위의 <a href="chapter_datatype.html#ex_datatype" title="[예 2.1] 데이터 타입의 변환">[예 2.1]</a>을 실행하면 다음과 같은 내용이 출력된다.</p>

      <pre class="programlisting">salary = 35000
emp_date = 2001-12-01</pre>

      <p>데이터 타입을 변환할 때에는 데이터 값의 범위와 내용에 유의해야 한다. 데이터 값의 범위는 그 값을 저장할 장소가
      충분히 포함할 수 있는 한도 내이어야 한다.</p>

      <p>데이터 값의 범위와 관련된 예를 들면 <span>tbESQL</span>/C 프로그램의 short 타입의 변수에 short 타입의 범위를
      넘어서는 값인 문자열 "327680"을 변환하거나, 마찬가지로 VARCHAR(3)의 타입을 갖는 컬럼에 그 범위를 넘어서는 값인
      65535를 변환할 수 없다.</p>

      <p>데이터의 내용에 관한 예를 들면 데이터베이스 컬럼에 저장된 "ABCDE" 문자열을 프로그램 short 타입의 변수에
      변환할 수 없으며, 프로그램 변수에 저장된 "가나다" 문자열을 DATE 타입의 컬럼에 변환할 수 없다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1048"/>내장 함수를 이용한 데이터 타입의 변환</h4>

      <p><span>Tibero</span> <span><strong class="guibutton">내장 함수</strong></span>를 이용하여
      데이터 타입의 변환을 실행할 수도 있다. 그러한 함수로는 <span><strong class="guibutton">TO_CHAR</strong></span>,
      <span><strong class="guibutton">TO_DATE</strong></span>, <span><strong class="guibutton">TO_NUMBER</strong></span> 등이
      있다.<a id="d5e1055" class="indexterm"/><a id="d5e1057" class="indexterm"/><a id="d5e1059" class="indexterm"/></p>

      <p>다음은 TO_CHAR 함수를 이용하여 실수 데이터를 문자 데이터로 변환하여 출력하는 예이다.</p>

      <div class="example"><a id="ex_to_char"/><p class="title"><b>[예 2.2] TO_CHAR 함수를 이용한 데이터 타입의 변환</b></p><div class="example-contents">
        

        

        <pre class="programlisting">VARCHAR sal_str[16];
...
EXEC SQL SELECT TO_CHAR(SALARY, '$99,999.99')   <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
    INTO :sal_str                               <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>  
    FROM EMP
    WHERE EMPNO = 20;

printf("salary = %s\n", sal_str.arr);           <em class="lineannotation"><span class="lineannotation">... ③ ...</span></em></pre>
      </div></div><br class="example-break"/>

      <p>① 실수 데이터를 담고 있는 변수 SALARY를 TO_CHAR 함수를 통해 형식 문자열('$99,999.99')을
      지정하여 문자 데이터로 변환한다.</p>

      <p>② VARCHAR 타입 변수 sal_str에 저장한다.</p>

      <p>③ printf 문을 통해 sal_str 변수를 출력한다.</p>

      <p>위의 <a href="chapter_datatype.html#ex_to_char" title="[예 2.2] TO_CHAR 함수를 이용한 데이터 타입의 변환">[예 2.2]</a>을 실행하면 다음과 같은 내용이 출력된다.</p>

      <pre class="programlisting">salary = $35,000.00</pre>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>데이터 타입을 변환하는 내장 함수에 대한 자세한 내용은 "<span>Tibero</span> SQL 참조 안내서"를 참고한다.</p>
      </div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1077"/>2.3.3. 데이터 변수 사용</h3></div></div></div>
      

      <p>C 프로그래밍 언어의 변수와는 달리 <span>tbESQL</span>/C 프로그램에서 데이터베이스 작업과 관련된 변수는 모두
      <span><strong class="guibutton">DECLARE 영역</strong></span> 내에 선언되어야 한다.<a id="d5e1082" class="indexterm"/></p>

      <p>다음은 DECLARE 영역 내에 선언된 변수의 예이다.</p>

      <pre class="programlisting"><span><strong class="guibutton">EXEC SQL BEGIN DECLARE SECTION;</strong></span>
VARCHAR ename[24];
int salary;
VARCHAR addr[32];
int empno;
<span><strong class="guibutton">EXEC SQL END DECLARE SECTION;</strong></span></pre>

      <p>위의 예에서 알 수 있듯이 DECLARE 영역은 <span><strong class="guibutton">'EXEC SQL BEGIN DECLARE
      SECTION;'</strong></span>으로 시작하고 <span><strong class="guibutton">'EXEC SQL END DECLARE
      SECTION;'</strong></span>으로 끝난다.</p>

      <p>VARCHAR 타입은 일반적인 CHAR 배열 타입과 유사하게 선언한다. CHAR 타입과는 달리 배열이 아닌 형태로는
      선언이 불가능하다. 프리컴파일 과정을 거치면 VARCHAR 타입은 <span>tbESQL</span>/C에서 정의한 구조체 타입으로 변환된다.</p>

      <div class="literallayout"><p/></div>

      <p>DECLARE 영역 내에 선언된 변수는 C 프로그래밍 언어의 변수와 동일한 방법으로 프로그램 내에서 사용된다. 하지만
      <span>tbESQL</span>/C 문장 내에서의 변수는 <span>tbESQL</span>/C 문장과의 구별을 위하여 반드시 콜론(:) 뒤에 와야 한다. 이렇게
      콜론(:) 뒤에 사용된 <span>tbESQL</span>/C 문장 내의 변수를 <span><strong class="guibutton">입/출력
      변수</strong></span>라고 한다.<a id="d5e1099" class="indexterm"/></p>

      <p>다음은 <span>tbESQL</span>/C 문장 내에서 사용된 입력 변수와 출력 변수에 대한
      예이다.</p>

      <pre class="programlisting">empno = 20;
EXEC SQL SELECT ENAME, SALARY, ADDR
    INTO :ename, :salary, :addr
    FROM EMP
    WHERE EMPNO = :empno;

printf("salary = %d\n", salary);</pre>

      <p>위의 예에서는 SELECT 문장을 실행하기 위해 먼저 입력 변수 empno의 값을 읽어와 <span>tbESQL</span>/C 문장을 완성한다. 그리고 나서, SELECT 문장을 실행하고 실행
      결과로 반환된 로우의 각 컬럼 값이 출력 변수 ename, salary, addr에 할당된다. 출력 변수 ename,
      salary, addr은 C 프로그래밍 언어의 변수와 마찬가지로 사용될 수 있다.</p>

      <p>만약 SELECT 문장의 실행 결과로 반환된 로우가 없거나 둘 이상의 로우가 반환되면 에러가 발생한다. 이러한 경우
      에러를 처리하는 루틴이 미리 정의되어 있으면 그 루틴을 실행하게 되고, 그렇지 않으면 프로그램을 종료한다.</p>

      <div class="literallayout"><p/></div>

      <p><span>tbESQL</span>/C 프로그램의 SQL 문장 내에는 변수 이외에 상수 또는 함수를
      사용할 수는 없다. 따라서 다음은 잘못된 소스 코드이다.</p>

      <pre class="programlisting">#define MAX_SALARY 50000
...
char *get_ename(...);
...
EXEC SQL INSERT INTO EMP(ENAME, SALARY)
    VALUES (:get_ename(), :MAX_SALARY);</pre>

      <p>위의 소스 코드는 사용자 정의 함수 get_ename과 상수 MAX_SALARY를 사용했으므로 잘못된
      예이다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_rowid"/>2.3.4. ROWID</h3></div></div></div>
      

      <p>ROWID 타입은 로우의 물리적인 위치 정보를 포함하는 데이터 타입이다. <span>tbESQL</span>/C에서는 <span><strong class="guibutton">ROWID</strong></span>를 위한
      별도의 데이터 타입을 제공하지 않는다. <span><strong class="guibutton">unsigned char </strong></span>타입 또는 VARCHAR
      타입을 이용해 데이터 타입을 변환하여 사용해야 한다.<a id="d5e1118" class="indexterm"/></p>

      <p>ROWID 타입의 값은 다음의 그림과 같이 4부분으로 구성된다.</p>

      <div class="figure"><a id="figure_pic_rowid"/><p class="title"><b>[그림 2.1] ROWID의 구성</b></p><div class="figure-contents">
        

        <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="700"><tr><td align="left"><img src="resources/img_esql_03.png" align="top" width="700" alt="ROWID의 구성"/></td></tr></table></div>
      </div></div><br class="figure-break"/>

      <p>문자열 변수에 저장되는 ROWID 값은 전체 18bytes를 가지므로, 문자열 변수의 길이는 NULL 값을 포함하여
      최소한 19bytes가 되어야 한다. <span>Tibero</span>의 데이터베이스에서는 다른 형태로 저장된다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>ROWID 타입에 대한 자세한 내용은 "<span>Tibero</span> SQL 참조 안내서"를 참고한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 ROWID 타입을 사용하는 예이다.</p>

      <div class="example"><a id="ex_rowid"/><p class="title"><b>[예 2.3] ROWID 타입의 사용</b></p><div class="example-contents">
        

        

        <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
unsigned char rowid[20];
EXEC SQL END DECLARE SECTION;

...

EXEC SQL SELECT ROWID, ...
    INTO :rowid, ...
    FROM EMP
    WHERE EMPNO = :empno;

printf("rowid = %s\n", rowid);</pre>
      </div></div><br class="example-break"/>

      <p>ROWID의 값은 이처럼 출력 변수로 사용될 뿐만 아니라 SELECT 문장의 WHERE 절이나 INSERT 문장에서
      입력 변수로 사용될 수도 있다.</p>

      <p/>

      <p>위의 <a href="chapter_datatype.html#ex_rowid" title="[예 2.3] ROWID 타입의 사용">[예 2.3]</a>을 실행하면 다음과 같은 내용이 출력된다.</p>

      <pre class="programlisting">rowid = AAAABkAAUAAAAD6AAA</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_varchar"/>2.3.5. VARCHAR<a id="d5e1143" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">VARCHAR 타입</strong></span>은 <span>Tibero</span>의 데이터 타입의 VARCHAR 타입을 <span>tbESQL</span>/C 프로그램에서 사용하기 위해 새롭게 정의한 데이터 타입이다.
      VARCHAR 타입은 RAW, DATE, ROWID 타입에도 대응하여 사용할 수 있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1150"/>VARCHAR 타입 변수 선언</h4>

      <p>VARCHAR 타입 변수 선언은 C 프로그래밍 언어에서 char 타입의 배열 변수를 선언하는 것과 동일하다. 한번에
      하나의 변수만 선언할 수도 있고, 여러 변수를 함께 선언할 수도 있다. 이때 배열의 크기를 반드시 지정해 주어야 하며, CHAR
      타입처럼 문자 하나만 저장하는 용도로는 사용할 수 없다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 VARCHAR 타입 변수를 선언하는 예이다.</p>

      <div class="example"><a id="ex_dec_varchar"/><p class="title"><b>[예 2.4] VARCHAR 타입 변수 선언</b></p><div class="example-contents">
        

        

        <pre class="programlisting">VARCHAR username[16];
VARCHAR ename[20], addr[24]; </pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>다음은 VARCHAR 타입 변수가 잘못 선언된 경우의 예이다.</p>

      <div class="example"><a id="dec_VARCHAR_ERR"/><p class="title"><b>[예 2.5] VARCHAR 타입의 잘못된 변수 선언</b></p><div class="example-contents">
        

        

        <pre class="programlisting">VARCHAR ch, dname[];</pre>
      </div></div><br class="example-break"/>

      <p>변수 <span><strong class="guibutton">ch</strong></span>의 경우 VARCHAR 타입은 CHAR 타입처럼 문자 하나만 저장하는
      용도로 사용할 수 없는데, 마치 CHAR 타입의 변수를 선언하는 것처럼 선언했기 때문에 잘못되었다. 변수
      <span><strong class="guibutton">dname</strong></span>의 경우 VARCHAR 타입 변수를 선언할 때에는 반드시 배열의 크기를
      정해주어야 하는데, 크기를 정하는 부분을 공란으로 두었기 때문에 잘못되었다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      <p>위의 <a href="chapter_datatype.html#ex_dec_varchar" title="[예 2.4] VARCHAR 타입 변수 선언">[예 2.4]</a>에서 선언된 VARCHAR 타입 변수는 프리컴파일러를
      통하여 다음과 같은 구조체 타입의 변수로 변환된다.</p>

      <div class="example"><a id="ex_struct_varchar"/><p class="title"><b>[예 2.6] VARCHAR 타입이 변환된 구조체</b></p><div class="example-contents">
        

        

        <pre class="programlisting">struct
{
    unsigned short len;
    unsigned char arr[16];
} username;</pre>

        <p/>

        <div class="literallayout"><p/></div>

        
      </div></div><br class="example-break"/>

      <h4><a id="d5e1174"/>VARCHAR 타입 변수의 참조와 일관성</h4>

      <p>VARCHAR 타입 변수를 선언할 때를 제외하고, VARCHAR 타입 변수를 사용하기 위해서는 프리컴파일러가 변환한
      구조체의 문법을 따라야 한다.</p>

      <p>예를 들어 위의 <a href="chapter_datatype.html#ex_dec_varchar" title="[예 2.4] VARCHAR 타입 변수 선언">[예 2.4]</a>에서 선언한 username을 출력하고자
      한다면, 프리컴파일러에 의해 변환된 <a href="chapter_datatype.html#ex_struct_varchar" title="[예 2.6] VARCHAR 타입이 변환된 구조체">[예 2.6]</a>의 구조체를 출력하는 문법에
      맞춰 다음과 같이 코드를 작성해야 한다.</p>

      <pre class="programlisting">printf("%s\n", username.arr);</pre>

      <p>위의 예에서 username의 내용을 출력하기 위해서 구조체의 멤버 변수를 참조하는 방법과 마찬가지로 점(.)을 사용한
      것을 알 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>VARCHAR 구조체 내의 변수 len과 arr은 입력 변수일 때 또는 출력 변수일 때 상관없이 항상 일관성을 유지해야
      한다. 즉, 다음과 같은 조건을 만족해야 한다.</p>

      <div class="example"><a id="ex_var_condition"/><p class="title"><b>[예 2.7] VARCHAR 변수의 일관성</b></p><div class="example-contents">
        

        

        <pre class="programlisting">strlen(username.arr) == username.len</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>VARCHAR 타입 변수가 입력 변수로 사용되었는지, 출력 변수로 사용되었는지에 따라서 위의 조건을 만족시키기 위한
      방법은 다르다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">VARCHAR 타입 변수</th><th>설명</th></tr></thead><tbody><tr><td align="left">입력 변수<a id="d5e1198" class="indexterm"/></td><td>입력 변수로 사용된 경우 <span>tbESQL</span>/C 프로그램 내에 조건을 유지시키는 코드를 작성해야
              한다. 조건을 만족하지 않는다면 <span>tbESQL</span>/C 라이브러리에서는 len 변수를 우선적으로
              참조한다.</td></tr><tr><td align="left">출력 변수<a id="d5e1205" class="indexterm"/></td><td>출력 변수로 사용된 경우 <span>tbESQL</span>/C 라이브러리 내에서 자동으로 조건을
              유지시킨다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1210"/>NULL 값의 처리<a id="d5e1211" class="indexterm"/></h4>

      <p>VARCHAR 타입 변수의 값이 NULL인 경우에는 프리컴파일러를 통해 변환된 구조체 내의 변수 arr과 len의 값은
      다음과 같다.</p>

      <pre class="programlisting">arr == ""
len == 0</pre>

      <div class="literallayout"><p/></div>

      <p>VARCHAR 타입 변수의 값이 <span><strong class="guibutton">NULL</strong></span>일 때 VARCHAR 타입 변수가 입력
      변수로 사용되었는지, 출력 변수로 사용되었는지에 따라 변환된 구조체 내의 멤버 변수 arr과 len의 값은 다르다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">VARCHAR 타입 변수</th><th>설명</th></tr></thead><tbody><tr><td align="left">입력 변수<a id="d5e1228" class="indexterm"/></td><td><p>입력 변수인 경우에는 len 변수에 0을 할당하는 코드를 작성해야
              한다.</p><p>arr 문자열의 길이가 0이 아니더라도 len 변수를 먼저 참조하므로 NULL로
              인식한다.</p></td></tr><tr><td align="left">출력 변수<a id="d5e1235" class="indexterm"/></td><td>출력 변수인 경우에는 arr과 len의 값을 <span>tbESQL</span>/C 라이브러리에서 자동으로 설정해준다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 VARCHAR 타입의 출력 변수 addr의 값으로 NULL이 반환되었는지 검토하여 출력하는 예이다.</p>

      <pre class="programlisting">VARCHAR addr[32];

...

EXEC SQL SELECT ADDR INTO <span><strong class="guibutton">:addr</strong></span>
    FROM EMP
    WHERE EMPNO = 20;

printf("addr = %s\n", (addr.len &gt; 0) ? (addr.arr) : ("(NULL)"));</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_struct"/>2.3.6. 구조체</h3></div></div></div>
      

      <p><span>tbESQL</span>/C 프로그램에서도 C 프로그래밍 언어의
      <span><strong class="guibutton">구조체</strong></span>를 사용할 수 있다.<a id="d5e1248" class="indexterm"/></p>

      <p><span>tbESQL</span>/C 프로그램의 SELECT 문장에서는 질의 결과로 반환되는 컬럼의
      개수만큼 INTO 절에 출력 변수를 명시해야 한다. 이런 경우에 INTO 절에 명시될 다수의 출력 변수를 한데 묶어 구조체를
      만들고, INTO 절에 이 구조체 변수 하나만 명시해 프로그램을 간소화할 수 있다.</p>

      <p>구조체 변수를 사용할 때에 SELECT 문장의 결과 로우 내의 컬럼의 순서와 구조체 변수 내의 변수의 순서가 같아야
      한다는 것에 유의한다.</p>

      <p>다음은 세 개의 출력 변수를 포함하는 구조체를 사용한 예이다.</p>

      <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;

struct
{
    VARCHAR ename[24];
    int salary;
    VARCHAR addr[32];
} emp;

...

EXEC SQL END DECLARE SECTION;

...

EXEC SQL SELECT ENAME, SALARY, ADDR
    INTO :emp
    FROM EMP
    WHERE EMPNO = :empno;</pre>

      <div class="literallayout"><p/></div>

      <p>구조체 변수는 INSERT 문장 등에서 입력 변수로 사용될 수도 있다. 이때에도 출력 변수와 동일하게 하나의 구조체
      변수만 사용할 수 있으며, 구조체 내부에 삽입하려는 컬럼과 같은 순서로 변수가 정의되어 있어야 한다.</p>

      <p>다음은 세 개의 컬럼에 값을 삽입하는 예이다.</p>

      <pre class="programlisting">strcpy(emp.ename.arr, "Smith");
emp.salary = 35000;
strcpy(emp.addr.arr, "Los Angeles");
emp.addr.len = strlen(emp.addr.arr);

EXEC SQL INSERT INTO EMP(ENAME, SALARY, ADDR) VALUES (:emp);</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1259"/>2.3.7. 포인터<a id="d5e1261" class="indexterm"/></h3></div></div></div>
      

      <p><span>tbESQL</span>/C 프로그램 내의 입/출력 변수에 대하여 C 프로그래밍 언어의
      <span><strong class="guibutton">포인터</strong></span>를 사용할 수 있다. 예를 들어 다음의 프로그램 코드와 같이 SELECT 문장의
      INTO 절에 일반 변수가 아닌 포인터 변수를 사용할 수 있다.</p>

      <div class="example"><a id="ex_pointer"/><p class="title"><b>[예 2.8] 포인터 변수의 사용</b></p><div class="example-contents">
        

        

        <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
int salary, <span><strong class="guibutton">*ptr_salary</strong></span> = NULL;   <em class="lineannotation"><span class="lineannotation"> ... ① ...</span></em>
...
EXEC SQL END DECLARE SECTION;

...

<span><strong class="guibutton">ptr_salary = &amp;salary;</strong></span>              <em class="lineannotation"><span class="lineannotation">... ② ...</span></em> 

EXEC SQL SELECT SALARY, ...
    INTO <span><strong class="guibutton">:ptr_salary</strong></span>, ...         <em class="lineannotation"><span class="lineannotation"> ... ③ ...</span></em>
    FROM EMP WHERE EMPNO = 5;</pre>
      </div></div><br class="example-break"/>

      <p>① 포인터 변수 ptr_salary를 선언한다.</p>

      <p>② 변수 salary의 주소를 ptr_salary에 할당한다.</p>

      <p>③ 포인터 변수 ptr_salary를 SELECT 문장의 INTO 절에 출력 변수로 사용한다.</p>

      <div class="literallayout"><p/></div>

      <p>위의 <a href="chapter_datatype.html#ex_pointer" title="[예 2.8] 포인터 변수의 사용">[예 2.8]</a>과 같은 <span>tbESQL</span>/C 프로그램이 프리컴파일 과정을 거치면 SQL 문장 내의 입/출력
      변수는 모두 포인터 타입의 변수로 변환된다. <span>tbESQL</span>/C 라이브러리는 포인터 변수의 데이터 타입에 맞춰 입/출력 데이터
      값을 적절하게 할당해 준다.</p>

      <div class="literallayout"><p/></div>

      <p><span>tbESQL</span>/C 프로그램에는 C 프로그래밍 언어에서처럼 일반 변수를 포인터 변수로
      변환하기 위한 연산자(&amp;)를 넣어서는 안 된다. 따라서 다음은 잘못된 프로그램 코드이다.</p>

      <pre class="programlisting">EXEC SQL SELECT SALARY, ...
    INTO :&amp;salary, ...
    FROM EMP WHERE EMPNO = 5;</pre>

      <div class="literallayout"><p/></div>

      <p>구조체 변수에 대한 포인터 변수도 사용할 수 있다.</p>

      <p>다음은 구조체 포인터 변수를 사용하는 예이다.</p>

      <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;

struct
{
    VARCHAR ename[24];
    int salary;
    VARCHAR addr[32];
} emp, <span><strong class="guibutton">*ptr_emp</strong></span> = NULL;           <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>       

...

EXEC SQL END DECLARE SECTION;

...

<span><strong class="guibutton">ptr_emp = &amp;emp;</strong></span>                   <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>

EXEC SQL SELECT ENAME, SALARY, ADDR
    INTO <span><strong class="guibutton">:ptr_emp</strong></span>                 <em class="lineannotation"><span class="lineannotation">... ③ ...</span></em>
    FROM EMP
    WHERE EMPNO = :empno;        </pre>

      <p>① 구조체 타입의 변수 emp와 구조체 타입의 포인터 변수 ptr_emp를 선언한다.</p>

      <p>② 구조체 변수 emp의 주소를 포인터 변수 ptr_emp에 저장한다.</p>

      <p>③ 포인터 변수 ptr_emp를 SELECT 문장의 INTO 절에서 출력 변수로 사용한다. 이때 &amp; 연산자를
      사용하지 않고, 일반 입/출력 변수를 사용할 때와 동일하게 콜론(:)만을 사용한다는 점에 주의해야 한다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_indicator"/>2.3.8. 지시자<a id="d5e1302" class="indexterm"/><a id="d5e1304" class="indexterm"/></h3></div></div></div>
      

      <p>일반 프로그램과 달리 <span>tbESQL</span>/C 프로그램에서만 사용되는 변수로
      <span><strong class="guibutton">지시자</strong></span>(INDICATOR) 변수가 있다. <span>tbESQL</span>/C 문장을 통해 데이터베이스와 <span>tbESQL</span>/C 프로그램 간에 데이터를 주고받을 때 지시자 변수는 전달된 데이터에
      대한 정보를 저장하고 있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1312"/>지시자 변수의 선언</h4>

      <p>지시자 변수는 short 타입을 가지며, 반드시 <span><strong class="guibutton">DECLARE 영역</strong></span> 안에
      선언되어야 한다.</p>

      <p>SELECT 문장에 사용된 지시자 변수는 INTO 절에서 INDICATOR 키워드와 콜론(:) 다음에 오거나,
      INDICATOR 없이 데이터 변수 바로 뒤에 콜론(:)과 함께 올 수도 있다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 SELECT 문장에서 출력 변수와 지시자 변수가 사용된 예이다.</p>

      <div class="example"><a id="ex_indicator_out"/><p class="title"><b>[예 2.9] 출력 변수와 지시자 변수</b></p><div class="example-contents">
        

        

        <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
short ename_ind, addr_ind;
...
EXEC SQL END DECLARE SECTION;

...

EXEC SQL SELECT ENAME, ADDR
    INTO <span><strong class="guibutton">:ename</strong></span> INDICATOR <span><strong class="guibutton">:ename_ind</strong></span>, <span><strong class="guibutton">:addr</strong></span> INDICATOR <span><strong class="guibutton">:addr_ind</strong></span>
    FROM EMP
    WHERE EMPNO = :empno;</pre>

        <p>위의 예에서는 출력 변수 ename에 대응되는 지시자 변수로 ename_ind가 사용되었고, 출력 변수 addr에
        대응되는 지시자 변수로는 addr_ind가 사용되었다.</p>

        <div class="literallayout"><p/></div>
      </div></div><br class="example-break"/>

      <p>INDICATOR 키워드를 명시하지 않고 다음과 같이 작성해도 위의 <a href="chapter_datatype.html#ex_indicator_out" title="[예 2.9] 출력 변수와 지시자 변수">[예 2.9]</a>의 문장과 동일한 의미를 갖는다.</p>

      <pre class="programlisting">EXEC SQL SELECT ENAME, ADDR
    INTO :ename:ename_ind, :addr:addr_ind
    FROM EMP
    WHERE EMPNO = :empno;</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 출력 변수와 함께 사용된 지시자 변수 값의 의미를 정리한 표이다. <span>tbESQL</span>/C 프로그램에서는 필요한 경우 지시자 변수의 값을 검토하여 그 값에
      따른 처리를 해야 한다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="130" align="left"/><col/></colgroup><thead><tr><th align="left">지시자 변수의 값</th><th>설명</th></tr></thead><tbody><tr><td align="left">0</td><td>데이터 값이 성공적으로 저장되었다.</td></tr><tr><td align="left">-1</td><td>데이터 값이 NULL이다.</td></tr><tr><td align="left">&gt; 0</td><td>문자열 데이터 변수에 저장된 값이 잘린(truncated) 값이다. 지시자 변수에 주어진 값은 실제
              데이터베이스에 저장된 문자열의 길이이다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 INSERT 문장에서 입력 변수와 함께 지시자 변수를 사용한 예이다.</p>

      <div class="example"><a id="ex_indicator_in"/><p class="title"><b>[예 2.10] 입력 변수와 지시자 변수</b></p><div class="example-contents">
        

        

        <pre class="programlisting">VARCHAR ename[24];
VARCHAR addr[36];

short addr_ind;
int empno;

...

strcpy(ename.arr, "Jaochim");
ename.len = strlen(ename.arr);
strcpy(addr.arr, "New York");
addr.len = strlen(addr.arr);

addr_ind = -1;
empno = 25;

EXEC SQL INSERT INTO EMP (ENAME, ADDR, EMPNO)
    VALUES (:ename, <span><strong class="guibutton">:addr</strong></span> INDICATOR <span><strong class="guibutton">:addr_ind</strong></span>, :empno);</pre>

        <p>위의 예에서는 입력 변수로 ename, addr, empno가 사용되었으며, 입력 변수 addr에 대응되는 지시자
        변수로 addr_ind가 사용되었다.</p>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>INDICATOR 키워드를 명시하지 않고 다음과 같이 작성해도 위의 <a href="chapter_datatype.html#ex_indicator_in" title="[예 2.10] 입력 변수와 지시자 변수">[예 2.10]</a>의 문장과 동일한 의미를 갖는다.</p>

      <pre class="programlisting">EXEC SQL INSERT INTO EMP (ENAME, ADDR, EMPNO)
    VALUES (:ename, <span><strong class="guibutton">:addr:addr_ind</strong></span>, :empno);</pre>

      <p>위의 예에서는 INDICATOR 키워드를 생략하고 입력 변수 addr 뒤에 지시자 변수 addr_ind를 바로 붙여서
      명시하였다.</p>

      <div class="literallayout"><p/></div>

      <p>지시자 변수 값이 -1인 경우에는 입력 변수의 값이 NULL이라는 의미이다. 이때 입력 변수에 저장된 실제 값은
      무시된다. 따라서 지시자 변수의 값이 -1인 경우 앞의 INSERT 문장은 다음과 같이 고쳐 써도 된다.</p>

      <pre class="programlisting">EXEC SQL INSERT INTO EMP (ENAME, ADDR, EMPNO)
    VALUES (:ename, <span><strong class="guibutton">NULL</strong></span>, :empno);</pre>

      <p>지시자 변수 값이 -1인 경우는 입력 변수 addr의 값이 NULL이라는 것이므로 입력 변수와 지시자 변수를 명시할
      필요 없이 NULL만 명시해도 된다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 입력 변수와 함께 사용된 지시자 변수 값의 의미를 정리한 표이다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="130" align="left"/><col/></colgroup><thead><tr><th align="left">지시자 변수의 값</th><th>설명</th></tr></thead><tbody><tr><td align="left">-1</td><td>데이터 값이 NULL이다.</td></tr><tr><td align="left">&gt;= 0</td><td>입력 변수에 저장된 값을 그대로 사용한다.</td></tr></tbody></table>
      </div>

      <p>지시자 변수를 사용하지 않고 <span>tbESQL</span>/C 프로그램을 작성할 수도 있지만, SQL 문장의 질의 결과로
      반환되는 값에 대해 충분히 알고 있지 않다면 지시자 변수를 사용하여 검토하는 코드를 삽입하는 것이 좋다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1389"/>구조체 타입의 지시자</h4>

      <p>SELECT 문의 INTO 절에 구조체 변수와 지시자 변수를 함께 사용하는 경우 지시자 변수 역시 마찬가지로 별도의
      구조체 변수로 구성해야 한다. 이러한 지시자 변수를 <span><strong class="guibutton">구조체 타입의 지시자(STRUCTURAL
      INDICATOR)</strong></span>라고 한다.<a id="d5e1392" class="indexterm"/><a id="d5e1394" class="indexterm"/> 구조체 타입의 지시자도 출력 구조체 변수를 구성하는 것과 마찬가지로 질의 결과 컬럼과 같은 순서로
      지시자 변수가 와야 한다. 또한 모든 지시자 변수는 short 타입을 갖는다.</p>

      <p>다음은 구조체 타입의 지시자 변수를 사용하는 예이다.</p>

      <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;

struct
{
    VARCHAR ename[24];
    int salary;                          <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
    VARCHAR addr[32];
} emp;

struct
{
    short ename_ind;
    short sal_ind;                       <em class="lineannotation"><span class="lineannotation">... ② ...</span></em> 
    short addr_ind;
} <span><strong class="guibutton">emp_ind</strong></span>;

...

EXEC SQL END DECLARE SECTION;

...

EXEC SQL SELECT ENAME, SALARY, ADDR
    INTO :emp INDICATOR <span><strong class="guibutton">:emp_ind</strong></span>
    FROM EMP
    WHERE EMPNO = :empno;</pre>

      <p>① 컬럼 ENAME, SALARY, ADDR의 내용을 저장하기 위해서 구조체 타입의 변수로 emp를
      선언한다.</p>

      <p>② 구조체 변수를 SELECT 문장의 출력 변수로 사용하면서, 이에 대응되는 지시자 변수 emp_ind 역시 구조체
      변수로 선언한다. 구조체 변수 emp_ind를 정의할 때 구조체 내의 멤버 변수를 emp에 대응되게 정의하고, emp_ind의
      모든 멤버 변수를 short 타입으로 정의한다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_datatype_equivalencing"/>2.3.9. 데이터 타입 동격화</h3></div></div></div>
      

      <p>데이터 타입의 동격화(Datatype Equivalencing)는 <span>Tibero</span>가 입력 데이터의 해석 방법을 프로그래머가 원하는데로 변경시키는
      것이다. 선언된 하나 하나의 호스트 변수마다 동격화를 시킬 수 있고, <span>tbESQL</span>/C에서는 사용자 정의 데이터 타입을 외부 데이터 타입으로 한 번에
      변경시킬 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 데이터 타입 동격화를 위한 EXEC SQL TYPE 구문을 사용한 예이다.</p>

      <pre class="programlisting">EXEC SQL TYPE 사용자정의타입
    IS 외부데이터타입 [(길이)] [REFERENCE];

typedef char asciz[350];
EXEC SQL BEGIN DECLARE SECTION;
    EXEC SQL TYPE asciz IS STRING(350) REFERENCE;
    asciz   catalog_cd[100];    /* ARRAY 변수 정의 */
    asciz   factor_cd1;
EXEC SQL END DECLARE SECTION;</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 데이터 타입의 동격화 중 사용 가능한 외부 데이터 타입들이다.</p>

      <pre class="programlisting">EXEC SQL TYPE var1 IS
(STRING | VARRAW | LONG VARRAW | VARCHAR | LONG VARCHAR | RAW) REFERENCE;</pre>

      <p>다음은 데이터 타입 동격화를 위한 EXEC SQL VAR 구문을 사용한 예이다.</p>

      <pre class="programlisting">EXEC SQL VAR 사용자변수
    IS 외부데이터타입 [(길이)];

char raw_var[1000];
EXEC SQL VAR raw_var IS RAW(1000);</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 데이터 타입의 동격화 중 사용 가능한 외부 데이터 타입들이다.</p>

      <pre class="programlisting">EXEC SQL VAR var1 IS
(STRING | VARRAW | LONG VARRAW | VARCHAR | LONG VARCHAR | RAW);</pre>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_introduce.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch03.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제1장 <span>tbESQL</span>/C 소개 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제3장 기본 프로그래밍</td></tr></table></div><div xmlns="" align="center"/></body></html>