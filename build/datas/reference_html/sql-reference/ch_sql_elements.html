<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제2장 SQL 문장의 구성요소</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero SQL 참조 안내서"/><link rel="up" href="index.html" title="Tibero SQL 참조 안내서"/><link rel="prev" href="ch_sql_concept.html" title="제1장 SQL 소개"/><link rel="next" href="ch_sql_expressions.html" title="제3장 SQL 연산"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제2장 SQL 문장의 구성요소</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch_sql_concept.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="ch_sql_expressions.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="ch_sql_elements"/>제2장 SQL 문장의 구성요소</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="ch_sql_elements.html#sect_data_type">2.1. 데이터 타입</a></span></dt><dd><dl><dt><span class="section"><a href="ch_sql_elements.html#d5e741">2.1.1. 문자형</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e934">2.1.2. 숫자형</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e1105">2.1.3. 날짜형</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e1306">2.1.4. 간격형</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e1354">2.1.5. 대용량 객체형</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#sect_internal">2.1.6. 내재형</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#sect_userdefined">2.1.7. 사용자 정의형</a></span></dt></dl></dd><dt><span class="section"><a href="ch_sql_elements.html#sect_data_type_conv">2.2. 데이터 타입 변환</a></span></dt><dd><dl><dt><span class="section"><a href="ch_sql_elements.html#d5e1484">2.2.1. 명시적 타입 변환</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e1821">2.2.2. 암시적 타입 변환</a></span></dt></dl></dd><dt><span class="section"><a href="ch_sql_elements.html#sect_literals">2.3. 리터럴</a></span></dt><dd><dl><dt><span class="section"><a href="ch_sql_elements.html#d5e3456">2.3.1. 문자열 리터럴</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e3518">2.3.2. 숫자 리터럴</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e3613">2.3.3. 날짜형 리터럴</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e3806">2.3.4. 간격 리터럴</a></span></dt></dl></dd><dt><span class="section"><a href="ch_sql_elements.html#sect_format_string">2.4. 형식 문자열</a></span></dt><dd><dl><dt><span class="section"><a href="ch_sql_elements.html#sect_number_type_format">2.4.1. NUMBER 타입</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#sect_date_type_format">2.4.2. 날짜형 타입</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#sect_format_modifier">2.4.3. 형식 조절자</a></span></dt></dl></dd><dt><span class="section"><a href="ch_sql_elements.html#sect_2_4">2.5. 의사 컬럼</a></span></dt><dd><dl><dt><span class="section"><a href="ch_sql_elements.html#sect_rowid">2.5.1. ROWID</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e4542">2.5.2. ROWNUM</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e4584">2.5.3. LEVEL</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e4595">2.5.4. CONNECT_BY_ISLEAF</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e4605">2.5.5. CONNECT_BY_ISCYCLE</a></span></dt></dl></dd><dt><span class="section"><a href="ch_sql_elements.html#d5e4617">2.6. NULL</a></span></dt><dd><dl><dt><span class="section"><a href="ch_sql_elements.html#d5e4624">2.6.1. 함수에서의 NULL</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e4644">2.6.2. NULL에 대한 비교조건</a></span></dt></dl></dd><dt><span class="section"><a href="ch_sql_elements.html#d5e4669">2.7. 주석</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#sect_HINTS">2.8. 힌트</a></span></dt><dd><dl><dt><span class="section"><a href="ch_sql_elements.html#d5e4978">2.8.1. 질의 변형</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e5106">2.8.2. 최적화 방법</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e5146">2.8.3. 접근 방법</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e5362">2.8.4. 조인 순서</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e5402">2.8.5. 조인 방법</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e5667">2.8.6. 병렬 처리</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e5742">2.8.7. 실체화 뷰</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e5812">2.8.8. 기타</a></span></dt></dl></dd><dt><span class="section"><a href="ch_sql_elements.html#d5e6048">2.9. 스키마 객체</a></span></dt><dd><dl><dt><span class="section"><a href="ch_sql_elements.html#d5e6074">2.9.1. 테이블</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e6121">2.9.2. 인덱스</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e6173">2.9.3. 뷰</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e6205">2.9.4. 시퀀스</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e6317">2.9.5. 동의어</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#sect_SQL_schema_obj_name">2.9.6. 스키마 객체의 이름</a></span></dt><dt><span class="section"><a href="ch_sql_elements.html#d5e6416">2.9.7. 스키마 객체 관련 문법</a></span></dt></dl></dd></dl></div>
  

  

  

  

  <p>본 장에서는 SQL 표준에서 정의하고 있는 데이터 타입과 스키마 객체에 대해 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_data_type"/>2.1. 데이터 타입</h2></div></div></div>
    

    <p><span>Tibero</span>에서는 SQL
    표준에 기반한 여러 가지 데이터 타입<a id="d5e704" class="indexterm"/>을 제공한다.</p>

    <p>다음은 <span>Tibero</span>에서 제공하는
    데이터 타입<a id="d5e708" class="indexterm"/>이다.</p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th>데이터 타입</th></tr></thead><tbody><tr><td align="left">문자형</td><td>CHAR, VARCHAR, VARCHAR2, NCHAR, NVARCHAR, NVARCHAR2,
            RAW<span>, LONG, LONG RAW</span></td></tr><tr><td align="left">숫자형</td><td>NUMBER, INTEGER, FLOAT, BINARY_FLOAT, BINARY_DOUBLE</td></tr><tr><td align="left">날짜형</td><td>DATE, TIME, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP
            WITH LOCAL TIME ZONE</td></tr><tr><td align="left">간격형</td><td>INTERVAL YEAR TO MONTH, INTERVAL DAY TO SECOND</td></tr><tr><td align="left">대용량 객체형</td><td>CLOB, BLOB, XMLTYPE, JSON</td></tr><tr><td align="left">내재형</td><td>ROWID</td></tr><tr><td align="left">사용자 정의형</td><td>배열, 네스티드 테이블</td></tr></tbody></table>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e741"/>2.1.1. 문자형</h3></div></div></div>
      

      <p>문자형<a id="d5e744" class="indexterm"/>은 문자열을 표현하는 데이터 타입이다. 문자형에는 CHAR, VARCHAR, VARCHAR2,
      NCHAR, NVARCHAR, NVARCHAR2, RAW<span>, LONG, LONG RAW 타입</span> 등이
      있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e748"/>CHAR</h4>

      <p>CHAR 타입<a id="d5e750" class="indexterm"/><a id="d5e753" class="indexterm"/>은 문자열을 저장하는 데이터 타입이다. 항상 고정된 문자열 길이를 갖는다.</p>

      <pre class="programlisting">CHAR(size[BYTE|CHAR])</pre>

      <div class="literallayout"><p/></div>

      <p>CHAR 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문자열은 최대 2,000byte나 2,000자까지 선언할 수 있다. 변환된 문자열의 길이가 2,000byte나
          2,000자를 넘으면 에러가 발생한다.</p>

          <p><span>Tibero</span>에서는 CHAR 타입으로 정의한 컬럼에
          입력된 문자열을 데이터베이스의 문자 집합에 맞게 변환하여 저장한다. 이때 변환된 문자열은 2,000byte나 2,000자를
          초과해서는 안 된다.</p>
        </li><li>
          <p>문자열의 길이는 byte와 문자를 기준으로 지정할 수 있다.</p>

          <p>CHAR (10 BYTE), CHAR (10 CHAR)의 형태로 선언한다. 뒷부분에 아무런 옵션도 지정하지 않고
          CHAR(10)의 형태로 선언하면, byte로 문자열의 길이가 지정된다. 각각 BYTE로 선언할 경우엔
          2,000byte까지 저장할 수 있고, CHAR로 선언할 경우엔 2,000자까지 저장할 수 있다. 따라서 CHAR로
          문자열의 길이를 선언할 때 실제 컬럼의 길이는 데이터베이스가 사용하는 문자 집합에 따라 좌우된다. 즉, 한 문자가 몇
          byte로 표현되는지에 따라 그 길이가 달라진다.</p>
        </li><li>
          <p>SQL 문장에서 CHAR 타입의 값을 표현할 때에는 항상 작은따옴표(' ')를 사용한다.</p>
        </li><li>
          <p>문자열의 길이가 0인 값은 NULL로 인식된다.</p>
        </li></ul></div>

      <p/>

      <p>다음은 CHAR 타입을 설명하는 예이다.</p>

      <pre class="programlisting">PRODUCT_NAME CHAR(10)</pre>

      <p>위 예제에서 보듯이 PRODUCT_NAME 컬럼은 항상 10byte의 문자열 길이를 갖는다. 예를 들어
      <span><strong class="guibutton">'<span>Tibero</span>'</strong></span> 문자열이 입력되었다면, 네 개의 공백 문자가
      채워져서 <span><strong class="guibutton">'<span>Tibero</span>____'</strong></span> 문자열이 저장된다. 이처럼 선언된
      길이보다 짧은 문자열이 입력되면 남은 부분은 공백 문자(space)로 채워진다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e780"/>VARCHAR</h4>

      <p>VARCHAR 타입<a id="d5e782" class="indexterm"/><a id="d5e785" class="indexterm"/>도 CHAR 타입과 마찬가지로 문자열을 저장하는 데이터 타입이다. 단, CHAR 타입과 다른 점은 문자열
      길이가 일정하지 않은 가변 길이를 갖는다는 것이다.</p>

      <pre class="programlisting">VARCHAR(size[BYTE|CHAR])</pre>

      <div class="literallayout"><p/></div>

      <p>VARCHAR 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문자열은 최대 65,532byte나 65,532자까지 선언할 수 있다. 변환된 문자열의 길이가
          65,532byte나 65,532자를 넘으면 에러가 발생한다. <span>Tibero</span>에서는 VARCHAR 타입으로 정의한 컬럼에
          입력된 문자열을 데이터베이스의 문자 집합에 맞게 변환하여 저장한다. 이때 변환된 문자열은 65,532byte를 초과해서는
          안 된다.</p>
        </li><li>
          <p>문자열의 길이는 byte와 문자를 기준으로 지정할 수 있다.</p>

          <p>VARCHAR (10 BYTE), VARCHAR (10 CHAR)의 형태로 선언한다. 뒷부분에 아무런 옵션도
          지정하지 않고 VARCHAR(10)의 형태로 선언하면, byte로 문자열의 길이가 지정된다. 각각 BYTE로 선언할 경우엔
          65,532byte까지 저장할 수 있고, CHAR로 선언할 경우엔 65,532자까지 저장할 수 있다. 따라서 CHAR로
          문자열의 길이를 선언할 때 실제 컬럼의 길이는 데이터베이스가 사용하는 문자 집합에 따라 좌우된다. 즉, 한 문자가 몇
          byte로 표현되는지에 따라 그 길이가 달라진다.</p>
        </li><li>
          <p>SQL 문장에서 VARCHAR 타입의 값을 표현할 때에는 항상 작은따옴표(' ')를 사용한다.</p>
        </li><li>
          <p>문자열의 길이가 0인 값은 NULL로 인식된다.</p>
        </li></ul></div>

      <p/>

      <p>다음은 VARCHAR 타입을 설명하는 예이다.</p><pre class="programlisting">EMP_NAME VARCHAR(10)</pre>

      <p>위 예제에서 보듯이 EMP_NAME 컬럼은 10byte의 문자열 길이를 갖는다. 예를 들어
      <span><strong class="guibutton">'Peter'</strong></span> 문자열이 입력되었다면
      <span><strong class="guibutton">'Peter'</strong></span> 문자열이 저장된다. 다시 말해 EMP_NAME 컬럼의 문자열 길이는
      10byte로 선언되었지만 실제로 저장된 문자열 길이는 5byte이다. 이처럼 VARCHAR 타입은 선언된 문자열 길이의 범위
      내에서 입력된 문자열 길이와 동일한 길이를 갖는다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e808"/>VARCHAR2</h4>

      <p>VARCHAR2 타입<a id="d5e810" class="indexterm"/><a id="d5e813" class="indexterm"/>은 VARCHAR 타입과 완전히 동일하다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e816"/>NCHAR</h4>

      <p>NCHAR 타입<a id="d5e818" class="indexterm"/><a id="d5e821" class="indexterm"/>은 유니코드 문자열을 저장하기 위한 타입이다. 항상 고정된 문자열 길이를 갖는다.</p>

      <pre class="programlisting">NCHAR(size)</pre>

      <div class="literallayout"><p/></div>

      <p>NCHAR 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>기본적으로 CHAR 타입과 유사하지만, 문자열의 길이가 문자 기준이다.</p>

          <p>데이터베이스에 저장되는 타입의 길이는 다국어 문자 집합에 따라 달라진다. 예를 들어 UTF8인 경우엔 size의
          최대 3배, UTF16인 경우엔 size의 최대 2배가 된다.</p>
        </li><li>
          <p>NCHAR 타입의 문자열의 최대 길이는 2,000자이다.</p>
        </li><li>
          <p>SQL 문장에서 NCHAR 타입의 값을 표현할 때에는 항상 작은따옴표(' ')를 사용한다.</p>
        </li><li>
          <p>문자열의 길이가 0인 값은 NULL로 인식된다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e837"/>NVARCHAR</h4>

      <p>NVARCHAR 타입<a id="d5e839" class="indexterm"/><a id="d5e842" class="indexterm"/>은 NCHAR과 마찬가지로 유니코드 문자열을 저장하기 위한 타입이다. 단, NCHAR 타입과 다른 점은
      문자열 길이가 일정하지 않은 가변 길이를 갖는다는 것이다.</p>

      <pre class="programlisting">NVARCHAR(size)</pre>

      <div class="literallayout"><p/></div>

      <p>NVARCHAR 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>기본적으로 VARCHAR 타입과 유사하지만, 문자열의 길이가 문자 기준이다.</p>

          <p>데이터베이스에 저장되는 타입의 길이는 다국어 문자 집합에 따라 달라진다. 예를 들어 UTF8인 경우엔 size의
          최대 3배, UTF16인 경우엔 size의 최대 2배가 된다.</p>
        </li><li>
          <p>NVARCHAR 타입의 문자열의 최대 길이는 65,532자이다. 단, 65,532byte를 초과할 수
          없다.</p>
        </li><li>
          <p>SQL 문장에서 NVARCHAR 타입의 값을 표현할 때에는 항상 작은따옴표(' ')를 사용한다.</p>
        </li><li>
          <p>문자열의 길이가 0인 값은 NULL로 인식된다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e858"/>NVARCHAR2</h4>

      <p>NVARCHAR2 타입<a id="d5e860" class="indexterm"/><a id="d5e863" class="indexterm"/>은 NVARCHAR 타입과 완전히 동일하다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e866"/>RAW</h4>

      <p>RAW 타입<a id="d5e868" class="indexterm"/><a id="d5e871" class="indexterm"/>은 임의의 바이너리 데이터를 저장하는 데이터 타입이다. 이때 바이너리 데이터는 선언된 최대 길이 내에서
      임의의 길이를 갖는다.</p>

      <p>RAW 타입이 CHAR, VARCHAR 타입과 다른 점은 RAW 타입은 데이터 중간에 NULL 문자('\0')가 올 수
      있지만 CHAR, VARCHAR 타입은 그렇지 않다. 따라서 RAW 타입은 NULL 문자로 데이터의 끝을 나타낼 수 없으므로 항상
      길이 정보를 같이 저장한다.</p>

      <pre class="programlisting">RAW(size)</pre>

      <div class="literallayout"><p/></div>

      <p>RAW 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>최대 2,000byte까지 선언할 수 있다.</p>
        </li><li>
          <p>선언된 길이 내에서 가변 길이를 갖는다.</p>
        </li><li>
          <p>데이터 중간에 NULL 문자('\0')가 올 수 있다.</p>
        </li><li>
          <p>입출력을 수행할 때 RAW 타입의 데이터는 16진수로 표현된다.</p>

          <p>예를 들면 4byte의 데이터는 16진수로 '012345AB'로 표현되며 필요한 경우 맨 앞이 0으로 시작되어야
          한다.</p>
        </li></ul></div>

      

      <div class="literallayout"><p/></div>

      <h4><a id="d5e888"/>LONG</h4>

      <p>LONG 타입<a id="d5e890" class="indexterm"/><a id="d5e893" class="indexterm"/>은 VARCHAR 타입을 확장한 데이터 타입이다. VARCHAR 타입과 마찬가지로 문자열이
      저장된다.</p>

      <pre class="programlisting">LONG</pre>

      <div class="literallayout"><p/></div>

      <p>LONG 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>최대 2GB까지 선언할 수 있다.</p>
        </li><li>
          <p>테이블 내의 한 컬럼에만 선언할 수 있다.</p>
        </li><li>
          <p>LONG 타입의 컬럼에 대해서는 인덱스를 생성할 수 없다.</p>
        </li><li>
          <p>LONG 타입의 컬럼을 포함한 로우(Row)가 디스크에 저장될 때에는 다른 컬럼의 값과 함께 동일한 디스크
          블록에 저장되며, 길이에 따라 여러 디스크 블록에 걸쳐 저장될 수 있다.</p>
        </li><li>
          <p>LONG 타입의 데이터에 접근할 때는 항상 순차적으로만 접근할 수 있으며, 임의의 위치에 대해 연산은 할 수
          없다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e910"/>LONG RAW</h4>

      <p>LONG RAW 타입<a id="d5e912" class="indexterm"/><a id="d5e915" class="indexterm"/>은 RAW 타입을 확장한 데이터 타입이다. RAW 타입과 마찬가지로 바이너리 데이터가
      저장된다.</p>

      <pre class="programlisting">LONG RAW</pre>

      <div class="literallayout"><p/></div>

      <p>LONG RAW 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>최대 2GB까지 선언할 수 있다.</p>
        </li><li>
          <p>테이블 내의 한 컬럼에만 선언할 수 있다.</p>
        </li><li>
          <p>LONG RAW 타입의 컬럼에 대해서는 인덱스를 생성할 수 없다.</p>
        </li><li>
          <p>LONG RAW 타입의 컬럼을 포함한 로우가 디스크에 저장될 때에는 다른 컬럼의 값과 함께 동일한 디스크 블록에
          저장되며, 길이에 따라 여러 디스크 블록에 걸쳐 저장될 수 있다.</p>
        </li><li>
          <p>LONG RAW 타입의 데이터에 접근할 때는 항상 순차적으로만 접근할 수 있으며, 임의의 위치에 대해 연산은 할
          수 없다.</p>
        </li></ul></div>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e934"/>2.1.2. 숫자형</h3></div></div></div>
      

      <p>숫자형<a id="d5e937" class="indexterm"/>은 정수나 실수의 숫자를 저장하는 데이터 타입이다. 숫자형에는 NUMBER 타입, INTEGER 타입,
      FLOAT 타입, BINARY_FLOAT 타입, BINARY_DOUBLE 타입이 있다.</p>

      <p><span>Tibero</span>에서는
      ANSI에서 제정한 SQL 표준의 숫자 타입의 선언을 지원한다. 즉, INTEGER 타입 또는 FLOAT 타입으로 컬럼을
      선언하더라도 내부적으로 적절한 정밀도와 스케일을 설정하여 NUMBER 타입으로 변환해 준다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>본 안내서에서는 INTEGER 타입, FLOAT 타입에 대한 내용은 별도로 기술하지 않는다.</p>
      </div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e946"/>NUMBER</h4>

      <p>NUMBER 타입<a id="d5e948" class="indexterm"/><a id="d5e951" class="indexterm"/>은 정수 또는 실수를 저장하는 데이터 타입이다.</p>

      <p>NUMBER 타입이 표현할 수 있는 수의 범위는 음양으로 절댓값이
      1.0×10<sup>-130</sup>보다 크거나 같고,
      1.0×10<sup>126</sup>보다 작은 38자리의 수를 표현할 수 있으며 0과 ±무한대를
      포함한다.</p><div class="literallayout"><p/></div><p>NUMBER 타입은 선언할 때 다음과 같이 자릿수를 의미하는
      정밀도와 스케일을 함께 정의할 수 있다.</p>

      <pre class="programlisting">NUMBER[(precision[,scale])]</pre>

      <div class="informaltable"><a id="tbl_NUMBER_types_and_stored_values"/>
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th>설명</th></tr></thead><tbody><tr><td align="left">precision</td><td><p>정밀도<a id="d5e970" class="indexterm"/>는 유효숫자의 최대 자릿수이다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>가장 왼쪽의 0이 아닌 숫자부터 가장 오른쪽의 신뢰할 수 있는 숫자까지의 자리수를
                    의미한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>정밀도를 초과하는 자릿수의 데이터는 저장할 수 없다.</p>
                  </li><li style="list-style-type: circle">
                    <p>정밀도<a id="d5e980" class="indexterm"/>는 1 ~ 38까지 정의할 수 있다.</p>
                  </li></ul></div><p>정밀도는 애스터리스크(*)로도 선언할 수
              있다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>정밀도를 38로 선언한 것을 의미하며, 이 경우 스케일 값을 함께 선언한다.</p>
                  </li></ul></div></td></tr><tr><td align="left">scale</td><td><p>스케일<a id="d5e991" class="indexterm"/>은 소수점 아래 가장 오른쪽 유효숫자까지의 자릿수이다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>스케일은 생략할 수 있으며, 0으로 선언한 것과 동일하다. 이 경우 정수를
                    표현한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>마이너스의 스케일<a id="d5e999" class="indexterm"/>은 소수점 위의 자릿수이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>스케일을 초과하는 데이터는 반올림을 수행한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>스케일<a id="d5e1006" class="indexterm"/>은 -125 ~ 130까지 정의할 수 있다.</p>
                  </li></ul></div></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>정밀도와 스케일을 생략하여 선언한 경우 표현 가능한 최대 범위와 최대 정밀도 내에서 임의의 자릿수를 갖는 모든 데이터
      값을 지원한다. 최대 정밀도 38을 초과하는 데이터는 반올림을 수행한다.</p>

      <p>다음은 입력된 데이터가 NUMBER 타입의 정밀도와 스케일에 정의된 값에 따라 실제 데이터베이스에 어떤 형태로
      저장되는지를 보여준다.</p>

      <div class="informaltable"><a id="tbl_NUMBER_types_and_stored_values"/>
        <table border="1"><colgroup><col width="120" align="left"/><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">입력된 데이터</th><th align="left">NUMBER 타입 선언</th><th>실제 저장된 데이터</th></tr></thead><tbody><tr><td align="left">12,345.678</td><td align="left">NUMBER</td><td>12,345.678</td></tr><tr><td align="left">12,345.678</td><td align="left">NUMBER(*,3)</td><td>12,345.678</td></tr><tr><td align="left">12,345.678</td><td align="left">NUMBER(8,3)</td><td>12,345.678</td></tr><tr><td align="left">12,345.678</td><td align="left">NUMBER(8,2)</td><td>12,345.68</td></tr><tr><td align="left">12,345.678</td><td align="left">NUMBER(8)</td><td>12,346</td></tr><tr><td align="left">12,345.678</td><td align="left">NUMBER(8,-2)</td><td>12,300</td></tr><tr><td align="left">12,345.678</td><td align="left">NUMBER(3)</td><td>입력된 데이터의 자릿수가 정밀도를 초과했으므로 저장할 수 없다.</td></tr></tbody></table>
      </div>

      

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1051"/>BINARY_FLOAT 타입</h4>

      <p>BINARY_FLOAT 타입<a id="d5e1053" class="indexterm"/><a id="d5e1056" class="indexterm"/>은 실수나 정수를 표현하고, 32비트로 저장하는 단일 정밀도 데이터 타입이다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      <p>BINARY_FLOAT 타입은 음양으로 절댓값이 1.17549E-38보다 크거나 같고, 3.40282E+38보다 작은
      수를 표현할 수 있다.</p>

      <p>BINARY_FLOAT 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>특별값인 INF, -INF, NaN(Not A Number)을 지원한다.</p>
        </li><li>
          <p>사칙연산을 모두 지원한다.</p>
        </li><li>
          <p>비교 연산자를 지원한다. 단, NaN은 다른 모든 값보다 가장 큰 값으로 취급하고, 서로 다른 NaN과 NaN은
          같다.</p>
        </li><li>
          <p>각종 변환함수 및 수학함수를 지원한다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p/>

      <h4><a id="d5e1073"/>BINARY_DOUBLE 타입</h4>

      <p>BINARY_DOUBLE 타입<a id="d5e1075" class="indexterm"/><a id="d5e1078" class="indexterm"/>은 실수나 정수를 표현하고, 64비트로 저장하는 2배 정밀도 데이터 타입이다.</p>

      <p>BINARY_DOUBLE 타입은 음양으로 절댓값이 2.22507485850720E-308보다 크거나 같고,
      1.79769313486231E+308보다 작은 수를 표현할 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>BINARY_DOUBLE 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>특별값인 INF, -INF, NaN(Not A Number)을 지원한다.</p>
        </li><li>
          <p>사칙연산을 모두 지원한다.</p>
        </li><li>
          <p>비교 연산자를 지원한다. 단, NaN은 다른 모든 값보다 가장 큰 값으로 취급하고, 서로 다른 NaN과 NaN은
          같다.</p>
        </li><li>
          <p>각종 변환함수 및 수학함수를 지원한다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e1093"/>숫자형 타입의 우선순위</h4>

      <p><span>Tibero</span>에서는 서로 다른 숫자형 타입을 사용하는 연산에서 각 연산자를
      어떤 데이타 타입으로 변환할 지를 우선순위에 따라 결정한다. 세 타입 중에서 BINARY_DOUBLE이 가장 높은 우선순위를
      가지고, 다음으로 BINARY_FLOAT, 마지막으로 NUMBER 순이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>연산자 중 하나라도 BINARY_DOUBLE일 경우엔 모든 연산자를 BINARY_DOUBLE로
          변환한다.</p>
        </li><li>
          <p>연산자 중 BINARY_DOUBLE이 없고, 하나라도 BINARY_FLOAT일 경우엔 모든 연산자를
          BINARY_FLOAT으로 변환한다.</p>
        </li><li>
          <p>BINARY_FLOAT이나 BINARY_DOUBLE이 없는 경우엔 모든 연산자를 NUMBER로
          변환한다.</p>
        </li></ul></div>

      <p>다른 데이터 타입과의 관계에서는 날짜나 간격형 타입보다는 낮은 우선순위를 가지고, 나머지 모든 타입보다는 높은
      우선순위를 가진다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1105"/>2.1.3. 날짜형</h3></div></div></div>
      

      <p>날짜형<a id="d5e1108" class="indexterm"/>은 시간이나 날짜를 저장하는 데이터 타입이다. 날짜형에는 DATE 타입, TIME 타입,
      TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE 타입이
      있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1111"/>DATE</h4>

      <p>DATE 타입<a id="d5e1113" class="indexterm"/>은 특정 날짜와 초 단위까지의 시간을 표현하는 데이터 타입이다.</p>

      <pre class="programlisting">DATE</pre>

      <div class="literallayout"><p/></div>

      <p>DATE 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>연도, 월, 일, 시, 분, 초를 표현할 수 있다.</p>
        </li><li>
          <p>연도는 BC 9,999 ~ AD 9,999까지 표현할 수 있다.</p>
        </li><li>
          <p>시간은 24시간 단위로 표현된다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1127"/>TIME</h4>

      <p>TIME 타입<a id="d5e1129" class="indexterm"/>은 초 단위 소수점 9자리까지의 특정 시간을 표현하는 데이터 타입이다.</p>

      <pre class="programlisting">TIME [(fractional_seconds_precision)]</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">fractional_seconds_precision</td><td><p>초 단위의 소수점 자릿수이다. 0~9사이의 값을 사용할 수 있다.
              </p><p>(기본값: 6)</p></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>TIME 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>시, 분, 초, 10<sup>-9</sup>초를 표현할 수 있다.</p>
        </li><li>
          <p>시간은 24시간 단위로 표현된다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p/>

      <h4><a id="d5e1157"/>TIMESTAMP</h4>

      <p>TIMESTAMP 타입<a id="d5e1159" class="indexterm"/>은 날짜와 초 단위 소수점 9자리까지의 시간을 모두 표현하는 데이터 타입이다.</p>

      <pre class="programlisting">TIMESTAMP [(fractional_seconds_precision)]</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">fractional_seconds_precision</td><td><p>초 단위의 소수점 자릿수를 말한다. 0~9사이의 값을 사용할 수 있다.
              </p><p>(기본값: 6)</p></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p/>

      <p>TIMESTAMP 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>연도, 월, 일, 시, 분, 초, 10<sup>-9</sup>초를 표현할 수
          있다.</p>
        </li><li>
          <p>연도는 BC 9,999 ~ AD 9,999까지 표현 가능하다.</p>
        </li><li>
          <p>시간은 24시간 단위로 표현된다.</p>
        </li></ul></div>

      <p/>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1191"/>TIMESTAMP WITH TIME ZONE</h4>

      <p>TIMESTAMP WITH TIME ZONE 타입<a id="d5e1193" class="indexterm"/>은 TIMESTAMP 타입을 확장하여 시간대까지 표현하는 데이터 타입이다.</p>

      <pre class="programlisting">TIMESTAMP [(fractional_seconds_precision)] WITH TIME ZONE</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">fractional_seconds_precision</td><td><p>초 단위의 소수점 자릿수를 말한다. 0~9사이의 값을 사용할 수 있다.
              </p><p>(기본값: 6)</p></td></tr></tbody></table>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      <p>TIMESTAMP WITH TIME ZONE 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>연도, 월, 일, 시, 분, 초, 10<sup>-9</sup>초 등은
          TIMESTAMP 타입과 동일한 특징을 가진다.</p>
        </li><li>
          <p>각 시간 요소들을 UTC(Coordinated Universal Time) 시간으로 정규화해서
          저장한다.</p>
        </li><li>
          <p>지역 이름이나 오프셋으로 표현된 시간대를 포함하여 저장한다. 여기서 오프셋은 현재 지역의 시간과 UTC 시간과의
          차이를 말한다.</p>
        </li></ul></div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1224"/>TIMESTAMP WITH LOCAL TIME ZONE</h4>

      <p>TIMESTAMP WITH LOCAL TIME ZONE 타입<a id="d5e1226" class="indexterm"/>은 특정 세션의 시간대에 따라 다르게 시간정보를 표현하는 데이터 타입이다.</p>

      <pre class="programlisting">TIMESTAMP [(fractional_seconds_precision)] WITH LOCAL TIME ZONE</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">fractional_seconds_precision</td><td><p>초 단위의 소수점 자릿수이다. 0~9사이의 값을 사용할 수 있다.
              </p><p>(기본값: 6)</p></td></tr></tbody></table>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      <p>TIMESTAMP WITH LOCAL TIME ZONE 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>연도, 월, 일, 시, 분, 초, 10<sup>-9</sup>초 등은
          TIMESTAMP 타입과 동일한 특징을 가진다.</p>
        </li><li>
          <p>각 시간 요소들을 UTC(Coordinated Universal Time) 시간으로 정규화해서
          저장한다.</p>
        </li><li>
          <p>TIMESTAMP WITH TIME ZONE 타입과 달리 지역이름이나 오프셋을 저장하지 않고, 사용자에 의해
          조회될 때 세션의 시간대로 자동으로 바뀌어 반환된다.</p>
        </li></ul></div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1258"/>AT TIME ZONE 절을 사용하여 TIMEZONE 변환</h4>

      <p>AT TIME ZONE 절<a id="d5e1260" class="indexterm"/>을 사용하여 날짜형 데이터 타입의 시간대를 변환할 수있다.</p>

      <div class="literallayout"><p/></div>

      <p>AT TIME ZONE 절을 사용하는 경우 해당 절과 함께 다음 중 하나를 설정할 수 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p><div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/datetime_expression.png"/></div>
            </div>
        </li><li>
          <p>구성요소</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">구성요소</th><th>설명</th></tr></thead><tbody><tr><td align="left">datetime_value_expr</td><td>datetime_value_expr에는 날짜형 데이터 타입 컬럼 혹은 날짜형 데이터 타입의
                  표현식이 올 수있다. 현재 TIMESTAMP 혹은 TIMESTAMP WITH TIME ZONE 날짜형 데이터
                  타입만 허용된다.</td></tr><tr><td align="left">DBTIMEZONE</td><td>Tibero에 설정된 데이터베이스 시간대를 사용한다.</td></tr><tr><td align="left">SESSIONTIMEZONE</td><td>현재 세션의 시간대를 사용한다.</td></tr><tr><td align="left">time_zone_name</td><td>명시한 표준 시간대를 사용한다.</td></tr><tr><td align="left">expr</td><td>표현식이 유효한 시간대 형식의 문자열인 경우 해당 시간대를 사용한다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p>예제</p>

          <p>다음은 AT TIME ZONE 절에 time_zone_name을 명시하여 시간대 변환하는 예이다.</p>

          <pre class="programlisting">SQL&gt; SELECT TO_TIMESTAMP('20190908','YYYYMMDD') AT TIME ZONE ('UTC') FROM DUAL;

TO_TIMESTAMP('20190908','YYYYMMDD')ATTIMEZONE('UTC')
--------------------------------------------------------------------------------
2019/09/07 15:00:00.000000 UTC</pre>
        </li></ul></div>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1306"/>2.1.4. 간격형</h3></div></div></div>
      

      <p>간격형<a id="d5e1309" class="indexterm"/>은 시간이나 날짜 사이의 간격을 저장하는 데이터 타입이다. 간격형에는 INTERVAL YEAR TO
      MONTH 타입, INTERVAL DAY TO SECOND 타입이 있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1312"/>INTERVAL YEAR TO MONTH</h4>

      <p>INTERVAL YEAR TO MONTH 타입<a id="d5e1314" class="indexterm"/>은 연도와 월을 이용하여 시간 간격을 표현하는 데이터 타입이다.</p>

      <pre class="programlisting">INTERVAL YEAR [(year_precision)] TO MONTH</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">year_precision</td><td>연도 단위의 자릿수이다. (기본값: 2)</td></tr></tbody></table>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1331"/>INTERVAL DAY TO SECOND</h4>

      <p>INTERVAL DAY TO SECOND 타입<a id="d5e1333" class="indexterm"/>은 일, 시, 분, 초를 이용하여 시간 간격을 표현하는 데이터 타입이다.</p>

      <pre class="programlisting">INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">day_precision</td><td>일 단위의 자릿수이다. (기본값: 2)</td></tr><tr><td align="left">fractional_seconds_precision</td><td><p>초 단위의 소수점 자릿수이다. 0~9사이의 값을 사용할 수 있다.
              </p><p>(기본값: 6)</p></td></tr></tbody></table>
      </div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1354"/>2.1.5. 대용량 객체형</h3></div></div></div>
      

      

      <p>대용량 객체형<a id="d5e1357" class="indexterm"/>은 말 그대로 대용량의 객체를 저장하기 위해 <span>Tibero</span>에서 제공하는 가장 큰 데이터 타입이며, CLOB 타입과 BLOB 타입, XMLTYPE, JSON 타입이
      있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1361"/>CLOB</h4>

      <p>CLOB 타입<a id="d5e1363" class="indexterm"/><a id="d5e1366" class="indexterm"/>은 LONG 타입을 확장한 데이터 타입이다.</p>

      <div class="literallayout"><p/></div>

      <p>CLOB 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>데이터를 최대 4GB까지 저장할 수 있다.</p>
        </li><li>
          <p>테이블 내에서 하나 이상의 컬럼에 선언할 수 있다.</p>
        </li><li>
          <p>데이터에 접근할 때 LONG 타입과 달리 임의의 위치에서 접근할 수 있다.</p>
        </li><li>
          <p>CLOB 타입의 컬럼 값은 같은 테이블의 다른 타입으로 선언된 컬럼 값과 동일한 디스크 블록에 저장되지 않는다.
          디스크 블록 내의 로우는 별도의 디스크 블록에 저장된 CLOB 타입의 포인터만 저장하고 있다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1380"/>BLOB</h4>

      <p>BLOB 타입<a id="d5e1382" class="indexterm"/><a id="d5e1385" class="indexterm"/>은 LONG RAW 타입을 확장한 데이터 타입이며, 특징은 CLOB 타입과 유사하다.</p>

      <div class="literallayout"><p/></div>

      <p>BLOB 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>데이터를 최대 4GB까지 저장할 수 있다.</p>
        </li><li>
          <p>테이블 내에서 하나 이상의 컬럼에 선언할 수 있다.</p>
        </li><li>
          <p>데이터에 접근할 때 LONG RAW 타입과 달리 임의의 위치에서 접근할 수 있다.</p>
        </li><li>
          <p>BLOB 타입의 컬럼 값은 같은 테이블의 다른 타입으로 선언된 컬럼 값과 동일한 디스크 블록에 저장되지 않는다.
          디스크 블록 내의 로우는 별도의 디스크 블록에 저장된 BLOB 타입의 포인터만 저장하고 있다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e1399"/>XMLTYPE</h4>

      <p>XML(Extensible Markup Language)은 구조화되거나 그렇지 않은 모든 데이터를 표현하기 위해
      W3C(World Wide Web Consortium)에 의해 표준으로 제정된 형식이다. <span>Tibero</span>에서는 이 XML 데이터를
      저장하기 위해 XMLTYPE 타입<a id="d5e1402" class="indexterm"/><a id="d5e1405" class="indexterm"/>을 제공하며, 내부적으로 CLOB 형식으로 저장된다.</p>

      <div class="literallayout"><p/></div>

      <p>XMLTYPE 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>데이터를 CLOB의 최대 크기까지 저장할 수 있다.</p>
        </li><li>
          <p>테이블 내에서 하나 이상의 컬럼에 선언할 수 있다.</p>
        </li><li>
          <p>XML 데이터에 대한 접근, 추출, 질의를 수행할 때 사용한다.</p>
        </li></ul></div>

      <h4><a id="d5e1416"/>JSON</h4>

      <p>JSON(JavaScript Object Notation)은 KEY/VALUE 쌍으로 이루어진 데이터 오브젝트를
      전달하기 위해 사용하는 개방형 표준 포맷이다. <span>Tibero</span>에서는 이 JSON 데이터를
      저장 및 처리하기 위해 JSON 타입<a id="d5e1419" class="indexterm"/><a id="d5e1422" class="indexterm"/>을 제공하며, 내부적으로 BLOB 형식으로 저장된다.</p>

      <div class="literallayout"><p/></div>

      <p>JSON 타입은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>데이터를 BLOB의 최대 크기까지 저장할 수 있다.</p>
        </li><li>
          <p>테이블 내에서 하나 이상의 컬럼에 선언할 수 있다.</p>
        </li><li>
          <p>JSON 데이터에 대한 접근, 추출, 질의를 수행할 때 사용한다.</p>
        </li></ul></div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_internal"/>2.1.6. 내재형</h3></div></div></div>
      

      <p>내재형<a id="d5e1437" class="indexterm"/>은 사용자가 명시적으로 선언하지 않아도 <span>Tibero</span>가 삽입되는 로우마다
      자동으로 부여하는 데이터 타입이다. 내재형에는 ROWID 타입이 있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="sect_rowid"/>ROWID</h4>

      <p>ROWID<a id="d5e1443" class="indexterm"/><a id="d5e1446" class="indexterm"/>는 데이터베이스의 각 로우를 식별하기 위해, <span>Tibero</span>가 각 로우마다 자동으로
      부여하는 데이터 타입이다. 각 로우가 저장된 물리적인 위치를 포함하고 있다. ROWID에 대한 자세한 내용은 <a href="ch_sql_elements.html#sect_2_4" title="2.5. 의사 컬럼">“2.5. 의사 컬럼”</a>을 참고한다.</p>

      <pre class="programlisting">ROWID</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_userdefined"/>2.1.7. 사용자 정의형</h3></div></div></div>
      

      <p>사용자 정의형<a id="d5e1454" class="indexterm"/>은 사용자가 정의하여 사용하는 콜렉션 형태의 타입이다. <span>tbPSM</span>
      타입으로 사용가능하며, <span>Tibero</span> 서버에서 저장된다. 사용자 정의형에는 배열과 네스티드 테이블이
      있다. 자세한 내용은 "<span>Tibero</span> <span>tbPSM</span>
      안내서"를 참고한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="sect_userdefined_array"/>배열</h4>

      <p>배열<a id="d5e1463" class="indexterm"/><a id="d5e1466" class="indexterm"/>는 최대 배열 길이를 가지는 동일한 타입을 구성요소로 갖는 콜렉션 형태의 사용자 정의
      타입이다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="sect_userdefined_array"/>네스티드
      테이블</h4>

      <p>네스티드 테이블(Nested Table)<a id="d5e1473" class="indexterm"/><a id="d5e1476" class="indexterm"/>는 최대 배열 길이가 없는 동일한 타입을 구성요소로 갖는 콜렉션 형태의 사용자 정의
      타입이다.</p>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_data_type_conv"/>2.2. 데이터 타입 변환</h2></div></div></div>
    

    <p>다음은 <span>Tibero</span>에서 비교, 연산
    등을 위하여 데이터 타입을 어떻게 변환하는지 살펴본다. 데이터 타입은 사용자가 명시적으로 할 수도 있고, 필요에 의하여 암시적으로
    이루어지기도 한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1484"/>2.2.1. 명시적 타입 변환</h3></div></div></div>
      

      <p>사용자가 SQL 변환 함수를 직접 사용하여 타입을 변환할 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 타입 변환 함수목록이다(행은 변환 전 타입, 열은 변환 후 타입이다).</p>

      <p/>

      <p/>

      <p/>

      <p/>

      <div class="table"><a id="d5e1494"/><p class="title"><b>[표 2.1] 명시적 타입 변환 (1)</b></p><div class="table-contents">
          

          

          <table summary="명시적 타입 변환 (1)" border="1"><colgroup><col width="130" align="left"/><col/><col/><col/></colgroup><thead><tr><th align="left">from \ to</th><th><p>CHAR, </p><p>VARCHAR2, </p><p>NCHAR,
                </p><p>NVARCHAR2</p></th><th>NUMBER</th><th>날짜, 시간 및 인터벌</th></tr></thead><tbody><tr><td align="left"><p><span><strong class="guibutton">CHAR,
                </strong></span></p><p><span><strong class="guibutton">VARCHAR2,
                </strong></span></p><p><span><strong class="guibutton">NCHAR,
                </strong></span></p><p><span><strong class="guibutton">NVARCHAR2</strong></span></p></td><td><p>TO_CHAR, </p><p>TO_NCHAR</p></td><td>TO_NUMBER</td><td><p>TO_DATE, </p><p>TO_TIME,
                </p><p>TO_TIMESTAMP,</p><p>TO_TIMESTAMP_TZ,</p><p>TO_DSINTERVAL,</p><p>
                TO_YMINTERVAL</p></td></tr><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td><p>TO_CHAR, </p><p>TO_NCHAR</p></td><td>-</td><td><p>NUMTOYMINTERVAL,</p><p>
                NUMTODSINTERVAL</p></td></tr><tr><td align="left"><p><span><strong class="guibutton">날짜, 시간 및
                </strong></span></p><p><span><strong class="guibutton">인터벌</strong></span></p></td><td><p>TO_CHAR, </p><p>TO_NCHAR</p></td><td>X</td><td>-</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>RAWTOHEX</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>ROWIDTOCHAR</td><td>X</td><td>X</td></tr><tr><td align="left"><p><span><strong class="guibutton">LONG,
                </strong></span></p><p><span><strong class="guibutton">LONG
                RAW</strong></span></p></td><td>LONG_TO_CHAR</td><td>X</td><td>X</td></tr><tr><td align="left"><p><span><strong class="guibutton">CLOB,
                </strong></span></p><p><span><strong class="guibutton">NCLOB,
                </strong></span></p><p><span><strong class="guibutton">BLOB</strong></span></p></td><td><p>TO_CHAR, </p><p>TO_NCHAR</p></td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td><p>TO_CHAR, </p><p>TO_NCHAR</p></td><td>TO_NUMBER</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td><p>TO_CHAR, </p><p>TO_NCHAR</p></td><td>TO_NUMBER</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td><p>TO_CHAR</p></td><td>X</td><td>X</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p>

      <div class="table"><a id="d5e1609"/><p class="title"><b>[표 2.2] 명시적 타입 변환 (2)</b></p><div class="table-contents">
          

          

          <table summary="명시적 타입 변환 (2)" border="1"><colgroup><col width="130" align="left"/><col/><col/><col/><col/></colgroup><thead><tr><th align="left">from \ to</th><th>BINARY_DOUBLE</th><th>RAW</th><th>ROWID</th><th><p><span><strong class="guibutton">LONG,
                </strong></span></p><p><span><strong class="guibutton">LONG
                RAW</strong></span></p></th></tr></thead><tbody><tr><td align="left"><p><span><strong class="guibutton">CHAR,
                </strong></span></p><p><span><strong class="guibutton">VARCHAR2,
                </strong></span></p><p><span><strong class="guibutton">NCHAR,
                </strong></span></p><p><span><strong class="guibutton">NVARCHAR2</strong></span></p></td><td>TO_BINARY_DOUBLE</td><td>HEXTORAW</td><td>CHARTOROWID</td><td>LONG_TO_CHAR</td></tr><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>TO_BINARY_DOUBLE</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><p><span><strong class="guibutton">날짜, 시간 및
                </strong></span></p><p><span><strong class="guibutton">인터벌</strong></span></p></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>-</td><td>-</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>X</td><td>X</td><td>-</td><td>X</td></tr><tr><td align="left"><p><span><strong class="guibutton">LONG,
                </strong></span></p><p><span><strong class="guibutton">LONG
                RAW</strong></span></p></td><td>X</td><td>X</td><td>X</td><td>-</td></tr><tr><td align="left"><p><span><strong class="guibutton">CLOB,
                </strong></span></p><p><span><strong class="guibutton">NCLOB,
                </strong></span></p><p><span><strong class="guibutton">BLOB</strong></span></p></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p>

      <p/>

      <div class="table"><a id="d5e1715"/><p class="title"><b>[표 2.3] 명시적 타입 변환 (3)</b></p><div class="table-contents">
          

          

          <table summary="명시적 타입 변환 (3)" border="1"><colgroup><col width="130" align="left"/><col/><col/><col/><col/></colgroup><thead><tr><th align="left">from \ to</th><th><p><span><strong class="guibutton">CLOB,
                </strong></span></p><p><span><strong class="guibutton">NCLOB,
                </strong></span></p><p><span><strong class="guibutton">BLOB</strong></span></p></th><th>BINARY_FLOAT</th><th>BINARY_DOUBLE</th><th>JSON</th></tr></thead><tbody><tr><td align="left"><p><span><strong class="guibutton">CHAR,
                </strong></span></p><p><span><strong class="guibutton">VARCHAR2,
                </strong></span></p><p><span><strong class="guibutton">NCHAR,
                </strong></span></p><p><span><strong class="guibutton">NVARCHAR2</strong></span></p></td><td>TO_CLOB</td><td>TO_BINARY_FLOAT</td><td>TO_BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>X</td><td>TO_BINARY_FLOAT</td><td>TO_BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">날짜, 시간 및 인터벌</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>TO_BLOB</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><p><span><strong class="guibutton">LONG,
                </strong></span></p><p><span><strong class="guibutton">LONG
                RAW</strong></span></p></td><td>TO_LOB</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><p><span><strong class="guibutton">CLOB,
                </strong></span></p><p><span><strong class="guibutton">NCLOB,
                </strong></span></p><p><span><strong class="guibutton">BLOB</strong></span></p></td><td>TO_CLOB</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>X</td><td>TO_BINARY_FLOAT</td><td>TO_BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>X</td><td>TO_BINARY_FLOAT</td><td>TO_BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>X</td><td>X</td><td>-</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1821"/>2.2.2. 암시적 타입 변환</h3></div></div></div>
      

      <p>사용자가 명시적으로 타입을 변환하지 않더라도, 필요하다면 암시적으로 타입을 변환하여 준다.</p>

      <div class="literallayout"><p/></div>

      <p>암시적 타입 변환이 필요한 경우는 아래와 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>컬럼에 다른 타입의 데이터를 INSERT, UPDATE하는 경우</p>
        </li><li>
          <p>조건문에서 비교하는 양쪽 값이 다른 타입인 경우</p>
        </li></ul></div>

      <p>다음은 암시적 타입 변환 관계이다(행은 변환 전 타입, 열은 변환 후 타입이다).</p>

      <p/>

      <p/>

      <div class="table"><a id="d5e1835"/><p class="title"><b>[표 2.4] 암시적 타입 변환 (1)</b></p><div class="table-contents">
          

          

          <table summary="암시적 타입 변환 (1)" border="1"><colgroup><col width="120" align="left"/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th align="left"> </th><th>NUMBER</th><th>CHAR</th><th>VARCHAR2</th><th>RAW</th><th>DATE</th><th>TIME</th><th>TIMESTAMP</th></tr></thead><tbody><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>-</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CHAR</strong></span></td><td>O</td><td>-</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">VARCHAR2</strong></span></td><td>O</td><td>O</td><td>-</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>X</td><td>O</td><td>O</td><td>-</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">DATE</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>-</td><td>X</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">TIME</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>-</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>O</td><td>X</td><td>-</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL YEAR TO MONTH</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL DAY TO SECOND</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG RAW</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CLOB</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NCHAR</strong></span></td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">NVARCHAR2</strong></span></td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">NCLOB</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH TIMEZONE</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>O</td><td>X</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH LOCAL
                TIMEZONE</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>O</td><td>X</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>O</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>O</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p><div class="table"><a id="d5e2070"/><p class="title"><b>[표 2.5] 암시적 타입 변환 (2)</b></p><div class="table-contents">
          

          

          <table summary="암시적 타입 변환 (2)" border="1"><colgroup><col width="120" align="left"/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th align="left"> </th><th>INTERVAL YEAR TO MONTH</th><th>INTERVAL DAY TO SECOND</th><th>LONG</th><th>LONG RAW</th><th>BLOB</th><th>CLOB</th><th>ROWID</th></tr></thead><tbody><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>O</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CHAR</strong></span></td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">VARCHAR2</strong></span></td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>X</td><td>X</td><td>O</td><td>O</td><td>O</td><td>O</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">DATE</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIME</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL YEAR TO MONTH</strong></span></td><td>-</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL DAY TO SECOND</strong></span></td><td>X</td><td>-</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG</strong></span></td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG RAW</strong></span></td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>O</td><td>-</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CLOB</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>-</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>-</td></tr><tr><td align="left"><span><strong class="guibutton">NCHAR</strong></span></td><td>O</td><td>O</td><td>O</td><td>O</td><td>X</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">NVARCHAR2</strong></span></td><td>O</td><td>O</td><td>O</td><td>O</td><td>X</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">NCLOB</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>O</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH TIMEZONE</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH LOCAL
                TIMEZONE</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>X</td><td>X</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>O</td><td>O</td><td>X</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p><div class="table"><a id="d5e2305"/><p class="title"><b>[표 2.6] 암시적 타입 변환 (3)</b></p><div class="table-contents">
          

          

          <table summary="암시적 타입 변환 (3)" border="1"><colgroup><col width="120" align="left"/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th align="left"> </th><th>NCHAR</th><th>NVARCHAR2</th><th>NCLOB</th><th>TIMESTAMP WITH TIMEZONE</th><th>TIMESTAMP WITH LOCAL TIMEZONE</th><th>BINARY_FLOAT</th><th>BINARY_DOUBLE</th><th>JSON</th></tr></thead><tbody><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>O</td><td>O</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CHAR</strong></span></td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">VARCHAR2</strong></span></td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">DATE</strong></span></td><td>O</td><td>O</td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIME</strong></span></td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP</strong></span></td><td>O</td><td>O</td><td>X</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL YEAR TO MONTH</strong></span></td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL DAY TO SECOND</strong></span></td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG RAW</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">CLOB</strong></span></td><td>O</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td><td>O</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NCHAR</strong></span></td><td>-</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NVARCHAR2</strong></span></td><td>O</td><td>-</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NCLOB</strong></span></td><td>O</td><td>O</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH TIMEZONE</strong></span></td><td>O</td><td>O</td><td>X</td><td>-</td><td>O</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH LOCAL
                TIMEZONE</strong></span></td><td>O</td><td>O</td><td>X</td><td>O</td><td>-</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>-</td><td>O</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>O</td><td>-</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2566"/>타입비교</h4>

      <p>다음은 두 값에 대한 타입을 비교할 때 어느쪽 타입으로 맞춰서 비교하는지를 나타내는 표이다.</p>

      <p/>

      <div class="table"><a id="d5e2570"/><p class="title"><b>[표 2.7] 타입비교 (1)</b></p><div class="table-contents">
          

          

          <table summary="타입비교 (1)" border="1"><colgroup><col width="120" align="left"/><col/><col/><col/><col/></colgroup><thead><tr><th align="left"> </th><th>NUMBER</th><th>CHAR</th><th>VARCHAR2</th><th>RAW</th></tr></thead><tbody><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>NUMBER</td><td>NUMBER</td><td>NUMBER</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">CHAR</strong></span></td><td>NUMBER</td><td>CHAR</td><td>VARCHAR2</td><td>CHAR</td></tr><tr><td align="left"><span><strong class="guibutton">VARCHAR2</strong></span></td><td>NUMBER</td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>VARCHAR2</td><td>CHAR</td><td>VARCHAR2</td><td>RAW</td></tr><tr><td align="left"><span><strong class="guibutton">DATE</strong></span></td><td>X</td><td>DATE</td><td>DATE</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">TIME</strong></span></td><td>X</td><td>TIME</td><td>TIME</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP</strong></span></td><td>VARCHAR2</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL YEAR TO MONTH</strong></span></td><td>VARCHAR2</td><td>INTERVAL YEAR TO MONTH</td><td>INTERVAL YEAR TO MONTH</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL DAY TO SECOND</strong></span></td><td>VARCHAR2</td><td>INTERVAL DAY TO SECOND</td><td>INTERVAL DAY TO SECOND</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">LONG</strong></span></td><td>X</td><td>LONG</td><td>LONG</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">LONG RAW</strong></span></td><td>VARCHAR2</td><td>LONG</td><td>LONG</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">BLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CLOB</strong></span></td><td>X</td><td>CLOB</td><td>CLOB</td><td>CLOB</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>VARCHAR2</td><td>ROWID</td><td>ROWID</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">NCHAR</strong></span></td><td>NUMBER</td><td>NCHAR</td><td>NVARCHAR2</td><td>NCHAR</td></tr><tr><td align="left"><span><strong class="guibutton">NVARCHAR2</strong></span></td><td>NUMBER</td><td>NVARCHAR2</td><td>NVARCHAR2</td><td>NVARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">NCLOB</strong></span></td><td>X</td><td>NCLOB</td><td>NCLOB</td><td>NCLOB</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH TIMEZONE</strong></span></td><td>VARCHAR2</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH LOCAL
                TIMEZONE</strong></span></td><td>VARCHAR2</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>BINARY_FLOAT</td><td>BINARY_FLOAT</td><td>BINARY_FLOAT</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>BINARY_DOUBLE</td><td>BINARY_DOUBLE</td><td>BINARY_DOUBLE</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p><div class="table"><a id="d5e2736"/><p class="title"><b>[표 2.8] 타입비교 (2)</b></p><div class="table-contents">
          

          

          <table summary="타입비교 (2)" border="1"><colgroup><col width="120" align="left"/><col/><col/><col/><col/></colgroup><thead><tr><th align="left"> </th><th>DATE</th><th>TIME</th><th>TIMESTAMP</th><th>INTERVAL YEAR TO MONTH</th></tr></thead><tbody><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>X</td><td>X</td><td>VARCHAR2</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">CHAR</strong></span></td><td>DATE</td><td>TIME</td><td>TIMESTAMP</td><td>INTERVAL YEAR TO MONTH</td></tr><tr><td align="left"><span><strong class="guibutton">VARCHAR2</strong></span></td><td>DATE</td><td>TIME</td><td>TIMESTAMP</td><td>INTERVAL YEAR TO MONTH</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">DATE</strong></span></td><td>DATE</td><td>VARCHAR2</td><td>TIMESTAMP</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">TIME</strong></span></td><td>VARCHAR2</td><td>TIME</td><td>VARCHAR2</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP</strong></span></td><td>TIMESTAMP</td><td>VARCHAR2</td><td>TIMESTAMP</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL YEAR TO MONTH</strong></span></td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>INTERVAL YEAR TO MONTH</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL DAY TO SECOND</strong></span></td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>INTERVAL DAY TO SECOND</td></tr><tr><td align="left"><span><strong class="guibutton">LONG</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG RAW</strong></span></td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">BLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">NCHAR</strong></span></td><td>DATE</td><td>TIME</td><td>TIMESTAMP</td><td>INTERVAL YEAR TO MONTH</td></tr><tr><td align="left"><span><strong class="guibutton">NVARCHAR2</strong></span></td><td>DATE</td><td>TIME</td><td>TIMESTAMP</td><td>INTERVAL YEAR TO MONTH</td></tr><tr><td align="left"><span><strong class="guibutton">NCLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH TIMEZONE</strong></span></td><td>TIMESTAMP</td><td>VARCHAR2</td><td>TIMESTAMP WITH TIMEZONE</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH LOCAL
                TIMEZONE</strong></span></td><td>TIMESTAMP</td><td>VARCHAR2</td><td>TIMESTAMP WITH LOCAL TIMEZONE</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>X</td><td>X</td><td>VARCHAR2</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>X</td><td>X</td><td>VARCHAR2</td><td>VARCHAR2</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p><div class="table"><a id="d5e2902"/><p class="title"><b>[표 2.9] 타입비교 (3)</b></p><div class="table-contents">
          

          

          <table summary="타입비교 (3)" border="1"><colgroup><col width="120" align="left"/><col/><col/><col/><col/></colgroup><thead><tr><th align="left"> </th><th>INTERVAL DAY TO SECOND</th><th>LONG</th><th>LONG RAW</th><th>BLOB</th></tr></thead><tbody><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CHAR</strong></span></td><td>INTERVAL DAY TO SECOND</td><td>LONG</td><td>LONG</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">VARCHAR2</strong></span></td><td>INTERVAL DAY TO SECOND</td><td>LONG</td><td>LONG</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">DATE</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIME</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL YEAR TO MONTH</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL DAY TO SECOND</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG</strong></span></td><td>X</td><td>LONG</td><td>LONG</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG RAW</strong></span></td><td>VARCHAR2</td><td>LONG</td><td>LONG RAW</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>BLOB</td></tr><tr><td align="left"><span><strong class="guibutton">CLOB</strong></span></td><td>X</td><td>LONG</td><td>LONG</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>VARCHAR2</td><td>ROWID</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NCHAR</strong></span></td><td>INTERVAL DAY TO SECOND</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NVARCHAR2</strong></span></td><td>INTERVAL DAY TO SECOND</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NCLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH TIMEZONE</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH LOCAL
                TIMEZONE</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>VARCHAR2</td><td>X</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p><div class="table"><a id="d5e3068"/><p class="title"><b>[표 2.10] 타입비교 (4)</b></p><div class="table-contents">
          

          

          <table summary="타입비교 (4)" border="1"><colgroup><col width="120" align="left"/><col/><col/><col/><col/><col/></colgroup><thead><tr><th align="left"> </th><th>CLOB</th><th>ROWID</th><th>NCHAR</th><th>NVARCHAR2</th><th>NCLOB</th></tr></thead><tbody><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td>X</td><td>VARCHAR2</td><td>NUMBER</td><td>NUMBER</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CHAR</strong></span></td><td>CLOB</td><td>ROWID</td><td>NCHAR</td><td>NVARCHAR2</td><td>NCLOB</td></tr><tr><td align="left"><span><strong class="guibutton">VARCHAR2</strong></span></td><td>CLOB</td><td>ROWID</td><td>NCHAR</td><td>NVARCHAR2</td><td>NCLOB</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td>CLOB</td><td>VARCHAR2</td><td>NCHAR</td><td>NVARCHAR2</td><td>NCLOB</td></tr><tr><td align="left"><span><strong class="guibutton">DATE</strong></span></td><td>X</td><td>VARCHAR2</td><td>DATE</td><td>DATE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIME</strong></span></td><td>X</td><td>VARCHAR2</td><td>TIME</td><td>TIME</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP</strong></span></td><td>X</td><td>VARCHAR2</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL YEAR TO MONTH</strong></span></td><td>X</td><td>VARCHAR2</td><td>INTERVAL YEAR TO MONTH</td><td>INTERVAL YEAR TO MONTH</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL DAY TO SECOND</strong></span></td><td>X</td><td>VARCHAR2</td><td>INTERVAL DAY TO SECOND</td><td>INTERVAL DAY TO SECOND</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG</strong></span></td><td>LONG</td><td>ROWID</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG RAW</strong></span></td><td>LONG</td><td>VARCHAR2</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BLOB</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CLOB</strong></span></td><td>CLOB</td><td>ROWID</td><td>CLOB</td><td>CLOB</td><td>NCLOB</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td>ROWID</td><td>ROWID</td><td>ROWID</td><td>ROWID</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NCHAR</strong></span></td><td>CLOB</td><td>ROWID</td><td>NCHAR</td><td>NVARCHAR2</td><td>NCLOB</td></tr><tr><td align="left"><span><strong class="guibutton">NVARCHAR2</strong></span></td><td>CLOB</td><td>ROWID</td><td>NCHAR</td><td>NVARCHAR2</td><td>NCLOB</td></tr><tr><td align="left"><span><strong class="guibutton">NCLOB</strong></span></td><td>NCLOB</td><td>X</td><td>NCLOB</td><td>NCLOB</td><td>NCLOB</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH TIMEZONE</strong></span></td><td>X</td><td>VARCHAR2</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH LOCAL
                TIMEZONE</strong></span></td><td>X</td><td>VARCHAR2</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td>X</td><td>VARCHAR2</td><td>BINARY_FLOAT</td><td>BINARY_FLOAT</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td>X</td><td>VARCHAR2</td><td>BINARY_DOUBLE</td><td>BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p><div class="table"><a id="d5e3257"/><p class="title"><b>[표 2.11] 타입비교 (5)</b></p><div class="table-contents">
          

          

          <table summary="타입비교 (5)" border="1"><colgroup><col width="120" align="left"/><col width="60" align="left"/><col/><col/><col/><col/></colgroup><thead><tr><th align="left"> </th><th align="left">TIMESTAMP WITH TIMEZONE</th><th>TIMESTAMP WITH LOCAL TIMEZONE</th><th>BINARY_FLOAT</th><th>BINARY_DOUBLE</th><th>JSON</th></tr></thead><tbody><tr><td align="left"><span><strong class="guibutton">NUMBER</strong></span></td><td align="left">VARCHAR2</td><td>VARCHAR2</td><td>BINARY_FLOAT</td><td>BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CHAR</strong></span></td><td align="left">TIMESTAMP WITH TIMEZONE</td><td>TIMESTAMP WITH LOCAL TIMEZONE</td><td>BINARY_FLOAT</td><td>BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">VARCHAR2</strong></span></td><td align="left">TIMESTAMP WITH TIMEZONE</td><td>TIMESTAMP WITH LOCAL TIMEZONE</td><td>BINARY_FLOAT</td><td>BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">RAW</strong></span></td><td align="left">NCLOB</td><td>NCLOB</td><td>NCLOB</td><td>NCLOB</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">DATE</strong></span></td><td align="left">TIMESTAMP WITH TIMEZONE</td><td>TIMESTAMP WITH LOCAL TIMEZONE</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIME</strong></span></td><td align="left">VARCHAR2</td><td>VARCHAR2</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP</strong></span></td><td align="left">TIMESTAMP WITH TIMEZONE</td><td>TIMESTAMP WITH LOCAL TIMEZONE</td><td>VARCHAR2</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL YEAR TO MONTH</strong></span></td><td align="left">VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">INTERVAL DAY TO SECOND</strong></span></td><td align="left">VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG</strong></span></td><td align="left">X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">LONG RAW</strong></span></td><td align="left">VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BLOB</strong></span></td><td align="left">X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">CLOB</strong></span></td><td align="left">X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">ROWID</strong></span></td><td align="left">VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NCHAR</strong></span></td><td align="left">TIMESTAMP WITH TIMEZONE</td><td>TIMESTAMP WITH LOCAL TIMEZONE</td><td>BINARY_FLOAT</td><td>BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NVARCHAR2</strong></span></td><td align="left">TIMESTAMP WITH TIMEZONE</td><td>TIMESTAMP WITH LOCAL TIMEZONE</td><td>BINARY_FLOAT</td><td>BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">NCLOB</strong></span></td><td align="left">X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH TIMEZONE</strong></span></td><td align="left">TIMESTAMP WITH TIMEZONE</td><td>TIMESTAMP WITH TIMEZONE</td><td>VARCHAR2</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">TIMESTAMP WITH LOCAL
                TIMEZONE</strong></span></td><td align="left">TIMESTAMP WITH TIMEZONE</td><td>TIMESTAMP WITH LOCAL TIMEZONE</td><td>VARCHAR2</td><td>VARCHAR2</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_FLOAT</strong></span></td><td align="left">VARCHAR2</td><td>VARCHAR2</td><td>BINARY_FLOAT</td><td>BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">BINARY_DOUBLE</strong></span></td><td align="left">VARCHAR2</td><td>VARCHAR2</td><td>BINARY_DOUBLE</td><td>BINARY_DOUBLE</td><td>X</td></tr><tr><td align="left"><span><strong class="guibutton">JSON</strong></span></td><td align="left">X</td><td>X</td><td>X</td><td>X</td><td>JSON</td></tr></tbody></table>
        </div></div><p><br class="table-break"/></p>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_literals"/>2.3. 리터럴</h2></div></div></div>
    

    <p>리터럴(Literal)<a id="d5e3452" class="indexterm"/><a id="d5e3454" class="indexterm"/>은 상수 값을 나타내는 단어이다. 상수란 변수에 대응되는 개념으로 말 그대로 변하지 않는 값을 의미한다.
    문자열 리터럴은 작은따옴표를 사용하여 다른 스키마 객체와 구분한다. 리터럴은 SQL 문장에서 연산식이나 조건식의 일부로 사용할 수
    있다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3456"/>2.3.1. 문자열 리터럴</h3></div></div></div>
      

      <p><span><strong class="guibutton">문자열 리터럴</strong></span><a id="d5e3460" class="indexterm"/><a id="d5e3463" class="indexterm"/>은 문자열을 표현할 때 사용하는 리터럴이다.</p>

      <div class="literallayout"><p/></div>

      <p>문자열 리터럴은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>최대 4,000byte까지 선언할 수 있다.</p>
        </li><li>
          <p>연산식이나 조건식에 문자열 리터럴이 사용되면, 문자열 리터럴은 CHAR 타입으로 취급된다.</p>
        </li><li>
          <p>CHAR 타입의 데이터와 문자형 리터럴을 비교하는 경우 더 짧은 길이를 가진 데이터에 공백 문자를 삽입하여
          비교한다.</p>
        </li><li>
          <p>VARCHAR 타입의 데이터와 문자형 리터럴을 비교하는 경우 공백 문자를 삽입하지 않고 비교한다.</p>
        </li></ul></div>

      <p/>

      <div class="literallayout"><p/></div>

      <p>문자열 리터럴의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>문법</p><div class="informalfigure">
                <div xmlns="" class="mediaobject"><img src="resources/text.png"/></div>
              </div>
          </li><li>
            <p>구성요소</p>

            <div class="informaltable">
              <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">구성요소</th><th>설명</th></tr></thead><tbody><tr><td align="left">c</td><td>사용자의 문자 집합에 속한 문자이다.</td></tr><tr><td align="left">’</td><td><p>문자열 리터럴 안에서 이스케이프 부호(Escape Code)를 사용하려면 문자
                    양쪽에 작은따옴표(' ')를 붙여야 한다. </p><p>문자열 리터럴 안에 작은따옴표를
                    표현하려면 작은따옴표를 두 번 연속해서 사용해야 한다.</p><p>문자열 리터럴 안에
                    작은따옴표를 일반 문자 와 같이 취급하려면 q string을 사용하면 된다.
                    q'[[string]]'$,q'"[string]"'$,q'|[string]|'$ q'$[string]'$
                    으로 문자열 리터럴을 사용하면 [string] 내부의 작은따옴표는 일반 문자와 같이
                    취급된다.</p></td></tr></tbody></table>
            </div>
          </li><li>
            <p>예제</p>

            <p>다음은 문자열 리터럴의 예이다.</p>

            <pre class="programlisting">'<span>Tibero</span>'
'Database'
'2009/11/11'</pre>
          </li></ul></div>

      <p/>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3518"/>2.3.2. 숫자 리터럴</h3></div></div></div>
      

      <p><span><strong class="guibutton">숫자 리터럴</strong></span><a id="d5e3522" class="indexterm"/><a id="d5e3525" class="indexterm"/>은 정수 또는 실수를 표현할 때 사용하는 리터럴이다.</p>

      <div class="literallayout"><p/></div>

      <p>숫자 리터럴은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>정수 리터럴과 실수 리터럴이 있다.</p>
          </li><li>
            <p>NUMBER 타입이 표현할 수 있는 최대 38자리의 정밀도를 초과하는 경우 숫자 리터럴은 NUMBER 타입의
            최대 정밀도에 맞춘 후 나머지 수를 반올림 처리한다. 또한, NUMBER 타입이 표현할 수 있는 범위를 넘어서는 숫자
            리터럴이 입력되면 에러가 발생한다.</p>
          </li><li>
            <p>다음과 같은 부동 소수점 리터럴이 있다. </p><div class="informaltable">
                <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">리터럴</th><th>설명</th></tr></thead><tbody><tr><td align="left">BINARY_FLOAT_NAN</td><td>단일 정밀도 NaN(Not A Number)</td></tr><tr><td align="left">BINARY_FLOAT_INFINITY</td><td>단일 정밀도 양의 무한대</td></tr><tr><td align="left">BINARY_DOUBLE_NAN</td><td>2배 정밀도 NaN(Not A Number)</td></tr><tr><td align="left">BINARY_DOUBLE_INFINITY</td><td>2배 정밀도 양의 무한대</td></tr></tbody></table>
              </div>
          </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>숫자 리터럴의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p><div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/integer.png"/></div>
            </div><div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/number.png"/></div>
            </div>
        </li><li>
          <p>구성요소</p>

          <div class="informaltable">
              <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">구성요소</th><th>설명</th></tr></thead><tbody><tr><td align="left">digit</td><td>0 ~ 9 사이의 숫자 하나를 의미한다.</td></tr><tr><td align="left">+ / -</td><td>숫자 앞의 부호(양수 또는 음수)를 의미한다.</td></tr><tr><td align="left">.</td><td>소수점을 의미한다.</td></tr><tr><td align="left">e, E</td><td><p>과학적 기수법(Scientific Notation)<a id="d5e3598" class="indexterm"/>으로 표기할 때 사용한다.</p><p>예를 들어 8.33e-4는
                    0.000833을 8.33e+4는 83,300을 의미한다. e나 E 다음에 나오는 숫자는 지수를
                    나타낸다. 이때 지수는 -130 ~ 125 사이의 값이어야 한다.</p></td></tr><tr><td align="left">f, F</td><td>BINARY_FLOAT 타입을 나타내고, 32비트 부동 소수점 숫자이다.</td></tr><tr><td align="left">d, D</td><td>BINARY_DOUBLE 타입을 나타내고, 64비트 부동 소수점 숫자이다.</td></tr></tbody></table>
            </div>
        </li><li>
          <p>예제</p>

          <p>다음은 숫자 리터럴의 예이다.</p>

          <pre class="programlisting">123
+1.23
0.123
123e-123
-123</pre>

          <p>다음은 부동 소수점 리터럴의 예이다.</p>

          <pre class="programlisting">123f
+1.23F
0.123d
-123D</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3613"/>2.3.3. 날짜형 리터럴</h3></div></div></div>
      

      <p>날짜형 리터럴은 날짜와 시간 정보를 표현하는 리터럴이다. 날짜형 리터럴에는 DATE 리터럴, TIME 리터럴,
      TIMESTAMP 리터럴, TIMESTAMP WITH TIME ZONE 리터럴이 있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e3617"/>DATE</h4>

      <p>DATE 리터럴<a id="d5e3619" class="indexterm"/><a id="d5e3621" class="indexterm"/>은 날짜와 시간 정보를 표현하는 날짜형 리터럴이다.</p>

      <div class="literallayout"><p/></div>

      <p>DATE 리터럴은 다음과 같은 특징이 있다.</p><div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>특별한 속성</p>

            <p>세기, 년, 월, 일, 시, 분, 초의 특별한 속성이 있다.</p>
          </li><li>
            <p>날짜형 리터럴 변환</p>

            <p><span>Tibero</span>에서는 <a href="ch_sql_functions.html#sect_TO_DATE" title="4.2.173. TO_DATE">TO_DATE</a> <a id="d5e3635" class="indexterm"/><a id="d5e3638" class="indexterm"/>함수를 사용하여 날짜 값을 직접 지정하거나 문자 리터럴이나 숫자 리터럴로 표현된 날짜 값을
            DATE 리터럴로 변환할 수 있다. 이때 날짜를 리터럴로 표현하려면 그레고리안 달력을 사용한다.</p>

            <pre class="programlisting">TO_DATE('2005/01/01 12:38:20', 'YY/MM/DD HH24:MI:SS')</pre>

            <p>기본 날짜 형식은 'YYYY/MM/DD'이며 초기화 파라미터 파일에 <a id="d5e3643" class="indexterm"/>NLS_DATE_FORMAT 파라미터로 정의되어 있다. NLS_DATE_FORMAT은 날짜
            형식을 지정하는 파라미터이다.</p>

            <p>만일 시간 정보가 없는 값으로 DATE 리터럴을 표현해야 한다면 기본 시간은 자정 (HH24
            00:00:00, HH 12:00:00)이다. 또한, 날짜 정보가 없는 값으로 DATE 리터럴을 표현해야 한다면 기본
            날짜는 현재 시스템의 시간을 기준으로 달의 첫째 날로 지정된다.</p>

            <p>따라서 DATE 리터럴을 비교할 때는 리터럴의 시간정보가 포함된 에러인지 확인이 필요하다. 한쪽에만 시간
            정보가 있고 다른 쪽에는 시간 정보가 없을 경우 두 날짜가 같다고 비교하기 위해서는 시간 정보를 제거하고 비교해야
            하는데 이때 <a id="d5e3647" class="indexterm"/><a id="d5e3649" class="indexterm"/><a href="ch_sql_functions.html#sect_TRUNC_date" title="4.2.190. TRUNC(date)">TRUNC</a> 함수를
            사용하면 된다.</p>

            <p>다음은 TRUNC 함수를 사용한 예이다.</p>

            <pre class="programlisting">TO_DATE('2005/01/01', 'YY/MM/DD') =
      TRUNC(TO_DATE('2005/01/01 12:38:20', 'YY/MM/DD HH24:MI:SS'))</pre>
          </li><li>
            <p>ANSI 표현<a id="d5e3657" class="indexterm"/></p>

            <pre class="programlisting">DATE '2005-01-01'</pre>

            <div class="itemizedlist"><ul type="circle" compact="compact"><li>
                <p>시간 정보가 없다.</p>
              </li><li>
                <p>기본 형식은 'YYYY-MM-DD'이다.</p>
              </li><li>
                <p>구분자는 하이픈(-) 외에도 슬래시(/), 애스터리스크(*), 점(.) 등이 있다.</p>
              </li></ul></div>
          </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e3669"/>TIME</h4>

      <p>TIME 리터럴<a id="d5e3671" class="indexterm"/><a id="d5e3673" class="indexterm"/>은 시간 정보를 표현하는 날짜형 리터럴이다.</p>

      <div class="literallayout"><p/></div>

      <p>TIME 리터럴은 다음과 같은 특징이 있다.</p><div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>특별한 속성</p>

            <p>시, 분, 초, 소수점 아래의 초의 특별한 속성이 있다.</p>
          </li><li>
            <p>날짜형 리터럴 변환</p>

            <p><span>Tibero</span>에서는 <a href="ch_sql_functions.html#sect_TO_TIME" title="4.2.183. TO_TIME">TO_TIME</a> <a id="d5e3687" class="indexterm"/><a id="d5e3689" class="indexterm"/>함수를 사용하여 시간 값을 직접 지정하거나 문자 리터럴이나 숫자 리터럴로 표현된 시간 값을
            TIME 리터럴로 변환할 수 있다.</p>

            <pre class="programlisting">TO_TIME('12:38:20.123456789', 'HH24:MI:SSXFF')</pre>

            <p>기본 시간 형식은 초기화 파라미터 파일에 <a id="d5e3694" class="indexterm"/>NLS_TIME_FORMAT 파라미터로 정의되어 있다.</p>
          </li><li>
            <p>ANSI 표현<a id="d5e3698" class="indexterm"/></p>

            <pre class="programlisting">TIME '10:23:10.123456789'
TIME '10:23:10'
TIME '10:23'
TIME '10'</pre>

            <div class="itemizedlist"><ul type="circle" compact="compact"><li>
                <p>기본 형식은 'HH24:MI:SS.FF9'이다.</p>
              </li><li>
                <p>분 이하는 생략할 수 있다.</p>
              </li></ul></div>
          </li></ul></div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e3711"/>TIMESTAMP</h4>

      <p>TIMESTAMP 리터럴<a id="d5e3713" class="indexterm"/><a id="d5e3715" class="indexterm"/>은 DATE 리터럴을 확장한 날짜형 리터럴이다.</p>

      <div class="literallayout"><p/></div>

      <p>TIMESTAMP 리터럴은 다음과 같은 특징이 있다.</p><div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>특별한 속성</p>

            <p>'년, 월, 일'의 날짜와 '시, 분 ,초', '소수점 아래의 초'의 특별한 속성이 있다.</p>
          </li><li>
            <p>날짜형 리터럴 변환</p>

            <p><span>Tibero</span>에서는 <a href="ch_sql_functions.html#sect_TO_TIMESTAMP" title="4.2.184. TO_TIMESTAMP">TO_TIMESTAMP</a> <a id="d5e3729" class="indexterm"/><a id="d5e3731" class="indexterm"/>함수를 사용하여 문자열 리터럴이나 숫자 리터럴로 표현된 날짜 값을 TIMESTAMP 리터럴로
            변환할 수 있다.</p>

            <pre class="programlisting">TO_TIMESTAMP('09-Aug-01 12:07:15.50', 'DD-Mon-RR HH24:MI:SS.FF')</pre>

            <p>기본 TIMESTAMP 형식은 초기화 파라미터 파일에 <a id="d5e3736" class="indexterm"/>NLS_TIMESTAMP_FORMAT 파라미터로 정의되어 있다.
            NLS_TIMESTAMP_FORMAT은 TIMESTAMP 형식을 지정하는 파라미터이다.</p>
          </li><li>
            <p>ANSI 표현<a id="d5e3740" class="indexterm"/></p>

            <pre class="programlisting">TIMESTAMP '2005/01/31 08:13:50.112'
TIMESTAMP '2005/01/31 08:13:50'
TIMESTAMP '2005/01/31 08:13'
TIMESTAMP '2005/01/31 08'
TIMESTAMP '2005/01/31'</pre>

            <div class="itemizedlist"><ul type="circle" compact="compact"><li>
                <p>기본 형식은 'YYYY/MM/DD HH24:MI:SSxFF' 이다.</p>
              </li><li>
                <p>날짜 부분('YYYY/MM/DD') 이외에는 생략할 수 있다.</p>
              </li><li>
                <p>소수점 아래의 초('FF') 부분은 0~9자리까지 표현할 수 있다.</p>
              </li></ul></div>
          </li></ul></div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e3754"/>TIMESTAMP WITH TIME ZONE</h4>

      <p>TIMESTAMP WITH TIME ZONE 리터럴<a id="d5e3756" class="indexterm"/><a id="d5e3758" class="indexterm"/>은 TIMESTAMP 리터럴을 확장한 날짜형 리터럴이다.</p>

      <div class="literallayout"><p/></div>

      <p>TIMESTAMP WITH TIME ZONE 리터럴은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>기본 속성</p>

            <p>TIMESTAMP 타입과 동일하게 '년, 월, 일'의 날짜와 '시, 분 ,초', '소수점 아래의 초'의
            속성이 있다.</p>
          </li><li>
            <p>날짜형 리터럴 변환</p>

            <p><span>Tibero</span>에서는 <a href="ch_sql_functions.html#sect_TO_TIMESTAMP_TZ" title="4.2.185. TO_TIMESTAMP_TZ">TO_TIMESTAMP_TZ</a> <a id="d5e3773" class="indexterm"/><a id="d5e3775" class="indexterm"/>함수를 사용하여 문자열 리터럴이나 숫자 리터럴로 표현된 날짜 값을 TIMESTAMP WITH
            TIME ZONE 리터럴로 변환할 수 있다.</p>

            <pre class="programlisting">TO_TIMESTAMP_TZ('2004-05-15 19:25:43 Asia/Seoul', 'YYYY-MM-DD HH24:MI:SS.FF TZR')
TO_TIMESTAMP_TZ('1988-11-21 10:31:58.754 -07:30', 'YYYY-MM-DD HH24:MI:SS.FF TZH:
TZM')</pre>

            <p>기본 TIMESTAMP WITH TIME ZONE 형식은 초기화 파라미터 파일에 <a id="d5e3780" class="indexterm"/>NLS_TIMESTAMP_TZ_FORMAT 파라미터로 정의되어 있다.
            NLS_TIMESTAMP_TZ_FORMAT은 TIMESTAMP WITH TIME ZONE 형식을 지정하는
            파라미터이다.</p>
          </li><li>
            <p>ANSI 표현<a id="d5e3784" class="indexterm"/></p>

            <pre class="programlisting">TIMESTAMP '1993/12/11 13:37:43.27 Asia/Seoul'
TIMESTAMP '1993/12/11 13:37:43.27 +09:00'
TIMESTAMP '1993/12/11 13:37:43.27 +07'</pre>

            <div class="itemizedlist"><ul type="circle" compact="compact"><li>
                <p>기본 형식은 'YYYY/MM/DD HH24:MI:SSXFF TZR' 이다.</p>
              </li><li>
                <p>소수점 아래의 초('FF') 부분은 0~9자리까지 표현할 수 있다.</p>
              </li><li>
                <p>시간대('TZR') 부분은 지역이름 또는 오프셋 형식으로 표현할 수 있다. 만약 시간대('TZR')
                부분을 생략하는 경우엔 TIMESTAMP 타입 리터럴로 해석된다.</p>
              </li></ul></div>
          </li></ul></div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e3798"/>TIMESTAMP WITH LOCAL TIME ZONE</h4>

      <p>TIMESTAMP WITH LOCAL TIME ZONE 리터럴<a id="d5e3800" class="indexterm"/><a id="d5e3802" class="indexterm"/>은 TIMESTAMP 리터럴과 동일한 형식을 사용한다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3806"/>2.3.4. 간격 리터럴</h3></div></div></div>
      

      <p><span><strong class="guibutton">간격 리터럴</strong></span>(Interval literal) <a id="d5e3810" class="indexterm"/><a id="d5e3813" class="indexterm"/>은 특정 시간과 시간 사이의 간격을 표현하는 리터럴이다. 이러한 간격은 '연과 월'로 구성된 단위나
      '날짜, 시간, 분, 초'로 구성된 단위 중 하나로 표현될 수 있다.</p>

      <p><span>Tibero</span>에서는 간격
      리터럴을 다음과 같이 두 가지 타입으로 지원한다.</p><div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>YEAR TO MONTH</p>

            <p>간격을 가장 가까운 월 단위로 표현하는 타입이다.</p>
          </li><li>
            <p>DAY TO SECOND</p>

            <p>간격을 가장 가까운 분 단위로 표현하는 타입이다.</p>
          </li></ul></div><p>이처럼 각 타입의 리터럴은 첫 번째 필드와 생략 가능한 두 번째 필드로 구성된다. 첫 번째 필드는
      표현할 날짜 또는 시간의 기본 단위를 정의하고, 두 번째 필드는 기본 단위의 최소 증가 단위를 나타낸다. 간격 리터럴은 같은
      타입의 간격 리터럴끼리 서로 더하거나 뺄 수 있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e3825"/>YEAR TO MONTH</h4>

      <p>YEAR TO MONTH<a id="d5e3827" class="indexterm"/> 타입은 간격을 연과 월로 표현하는 간격 리터럴이다.</p>

      <div class="literallayout"><p/></div>

      <p>YEAR TO MONTH의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/interval_year_to_month.png"/></div>
          </div>
        </li><li>
          <p>구성 요소</p>

          <div class="informaltable">
              <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">구성 요소</th><th>설명</th></tr></thead><tbody><tr><td align="left">integer [-integer]</td><td><p>리터럴의 첫 번째와 생략 가능한 두 번째 필드의 값을
                    나타낸다.</p><p>첫 번째 필드가 YEAR이고, 두 번째 필드가 MONTH이면 두 번째
                    필드는 0과 11 사이의 값이어야 한다. 이때 두 번째 필드는 첫 번째 필드보다 더 작은 단위를 나타내야
                    한다. 즉, MONTH TO YEAR는 잘못된 표현이다.</p></td></tr><tr><td align="left">precision</td><td><p>YEAR 단위의 최대 정밀도를 나타낸다. </p><p>0과 9 사이의
                    값이어야 하고, 기본값은 2이다.</p></td></tr></tbody></table>
            </div>
        </li><li>
          <p>예제</p>

          <p>다음은 YEAR TO MONTH의 예이다.</p>

          <pre class="programlisting">INTERVAL '12-3' YEAR TO MONTH
INTERVAL '123' YEAR(3)
INTERVAL '123' MONTH
INTERVAL '1' YEAR
INTERVAL '1234' MONTH(3)</pre>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e3868"/>DAY TO SECOND</h4>

      <p>DAY TO SECOND <a id="d5e3870" class="indexterm"/>타입은 간격을 '날짜, 시간, 분, 초'로 표현하는 간격
      리터럴이다.</p><div class="literallayout"><p/></div><p>DAY TO SECOND의 세부 내용은 다음과
      같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>문법</p>

            <div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/interval_day_to_second.png"/></div>
            </div>
          </li><li>
            <p>구성요소</p>

            <div class="informaltable">
                <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">구성요소</th><th>설명</th></tr></thead><tbody><tr><td align="left">integer</td><td>일 수를 나타낸다.</td></tr><tr><td align="left">time_expr</td><td><p>time_expr은 HH[:MI[:SS[.n]]] 또는 MI[:SS[.n]]
                      또는 SS[.n]과 같은 형식으로 나타낸다. n은 초의 소수점 아래 자리를 나타낸다. 만일 n이
                      fractional_seconds_precision에 명시된 값보다 큰 자릿수의 값이면 n은
                      fractional_seconds_precision 값에 맞추어 반올림된다.</p><p>첫
                      번째 필드가 DAY인 경우에는 일 수를 표시하는 정수와 공백 문자 이후에 time_expr을
                      표시한다.</p></td></tr><tr><td align="left">leading_precision</td><td><p>첫 번째 필드의 정밀도를 나타낸다.</p><p>0과 9 사이의 정수
                      값을 갖고, 기본값은 2이다.</p></td></tr><tr><td align="left">fractional_seconds_precision</td><td><p>리터럴의 두 번째 필드의 정밀도를 나타낸다.</p><p>1과 9
                      사이의 값을 갖고, 기본값은 6이다. 이때 두 번째 필드는 첫 번째 필드보다 더 작은 단위를 나타내야
                      한다. 즉, MINUTE TO DAY는 잘못된 표현이다. 그리고 두 번째 필드가 HOUR,
                      MINUTE 또는 SECOND일 경우에는 각각 0 ~ 23, 0 ~ 59, 그리고 0 ~
                      59.999999999 사이의 값을 가져야 한다.</p></td></tr></tbody></table>
              </div>
          </li><li>
            <p>예제</p>

            <p>다음은 DAY TO SECOND의 예이다.</p>

            <pre class="programlisting">INTERVAL '1 2:3:4.567' DAY TO SECOND(3)
INTERVAL '1 2:3' DAY TO MINUTE
INTERVAL '123 4' DAY(3) TO HOUR
INTERVAL '123' DAY(3)
INTERVAL '12:34:56.1234567' HOUR TO SECOND(7)
INTERVAL '12:34' HOUR TO MINUTE
INTERVAL '12' HOUR
INTERVAL '12:34' MINUTE TO SECOND
INTERVAL '12' MINUTE
INTERVAL '12.345678' SECOND(2,6)</pre>
          </li></ul></div>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_format_string"/>2.4. 형식 문자열</h2></div></div></div>
    

    <p>형식 문자열<a id="d5e3920" class="indexterm"/>이란 NUMBER 타입과 날짜형 타입의 값을 문자열로 변환하기 위한 형식을 정의한 것이다.</p>

    <p>형식 문자열은 문자열 타입으로 변환된 NUMBER 타입과 날짜형 타입의 값을 다시 원래의 타입의 값으로 변환하는 데
    필요하다.</p>

    <p>문자열 타입과 날짜형 타입, NUMBER 타입의 값 사이에는 데이터 타입의 변환을 할 수 있다. 하지만, 실제 값에 따라
    변환이 불가능한 경우도 있다. 예를 들어 문자열 '12345'는 NUMBER 타입의 값으로 변환할 수 있지만, 문자열 'ABCDE'는
    변환할 수 없다.</p>

    <p>디폴트 시간 형식으로 되어 있지 않은 문자열이나 숫자 이외의 문자를 포함하는 문자열은 각각 날짜형 또는 NUMBER 타입의
    값으로 변환할 수 없다. 이러한 경우 반드시 TO_DATE, TO_NUMBER 등의 변환 함수를 사용해야 한다.</p>

    <p>형식 문자열은 TO_CHAR, TO_DATE, TO_NUMBER 함수의 파라미터로 사용된다. 만약 함수 파라미터로 형식
    문자열이 주어지지 않으면, 디폴트 형식을 사용하여 변환한다. 함수에 대한 자세한 내용은 <a href="ch_sql_functions.html" title="제4장 함수">“제4장 함수”</a>를 참고한다.</p>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_number_type_format"/>2.4.1. NUMBER 타입</h3></div></div></div>
      

      <p><span><strong class="guibutton">NUMBER 타입의 형식 문자열</strong></span><a id="d5e3932" class="indexterm"/><a id="d5e3935" class="indexterm"/>은 TO_CHAR 함수와 TO_NUMBER 함수에서 파라미터로 사용할 수 있다.</p><div class="informaltable">
          <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">함수</th><th>설명</th></tr></thead><tbody><tr><td align="left">TO_CHAR</td><td>NUMBER 타입의 값을 문자열로 변환한다.</td></tr><tr><td align="left">TO_NUMBER</td><td>문자열을 NUMBER 타입의 값으로 변환한다.</td></tr></tbody></table>
        </div><div class="literallayout"><p/></div><p>NUMBER 타입의 형식 문자열은 다음과
      같은 특징이 있다.</p><div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>여러 가지 형식 요소로 구성된다. 소수점 위아래의 자릿수, 음양 부호의 출력, 콤마(,) 또는 지수 형식
            등을 출력할 수 있다.</p>
          </li><li>
            <p>화폐 단위를 나타내는 기호($, W 등)를 삽입할 수 있다.</p>
          </li><li>
            <p>16진수로 출력할 수 있다.</p>
          </li><li>
            <p>별도의 문자열을 삽입할 수 없다.</p>
          </li><li>
            <p>대소문자를 구분하는 형식 요소가 없다.</p>
          </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 NUMBER 타입의 형식 문자열에 포함될 수 있는 형식 요소<a id="d5e3966" class="indexterm"/>이다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="100"/><col width="100"/><col/></colgroup><thead><tr><th>형식 요소</th><th>예</th><th>설명</th></tr></thead><tbody><tr><td>콤마 (,)</td><td>9,999</td><td>해당 위치에 콤마(,)를 찍는다. 콤마를 여러 개 찍을 수도 있다. 형식 문자열을 콤마로 시작할 수는
              없다.</td></tr><tr><td>점 (.)</td><td>99.99</td><td>소수점을 출력한다. 형식 문자열 내에서는 하나의 소수점만 나올 수 있다.</td></tr><tr><td>$</td><td>$9999</td><td>숫자의 시작에 달러 문자($)를 출력한다.</td></tr><tr><td>0</td><td><p>0999</p><p>9990</p></td><td>숫자의 앞이나 뒤에 0을 채운다. 해당되는 위치에 0을 찍을 수 있는 경우에만 0이 출력되는 것을
              보장한다.</td></tr><tr><td>9</td><td>9999</td><td><p>(자릿수 + 1)개의 문자를 사용해서 숫자를 출력한다.</p><p>플러스(+)나
              마이너스(-)가 추가로 붙을 수 있다(양수일 때는 공백, 음수일 때는 마이너스가 출력된다).
              </p><p>숫자의 앞쪽에 올 수 있는 0은 출력하지 않는다. 다만, 소수점 없이 정수만을 출력할 때
              정수 부분이 0일 경우는 0을 출력한다.</p></td></tr><tr><td>B</td><td>B9999</td><td>0의 값을 공백으로 출력한다.</td></tr><tr><td>D</td><td>99D99</td><td>해당 위치에 소수점을 출력한다. 현재는 점(.)과 기능이 같다.</td></tr><tr><td>EEEE</td><td>9.9EEEE</td><td>과학적 기수법에 의해 출력한다.</td></tr><tr><td>G</td><td>9G999</td><td>해당 위치에 콤마(,)를 찍는다. 현재는 콤마와 기능이 같다.</td></tr><tr><td>L 또는 U</td><td><p>L9999</p><p>U9999</p></td><td>숫자의 시작에 달러 문자($)를 출력한다. 현재는 $와 기능이 같다.</td></tr><tr><td>MI</td><td>9999MI</td><td>음수에 대해 마이너스를 뒤에 붙인다. 양수의 경우에는 공백을 출력한다. 형식 문자열의 맨 뒤에만 사용할
              수 있다.</td></tr><tr><td>RN (rn)</td><td><p>RN</p><p>rn</p></td><td><p>로마 숫자로 출력한다. RN은 대문자로, rn은 소문자로
              출력한다.</p><p>숫자는 1~ 3,999 사이의 정수만 가능하다.</p></td></tr><tr><td>S</td><td><p>S9999</p><p>9999S</p></td><td>양수/음수 부호를 해당 위치에 출력한다. 형식 문자열의 맨 처음 또는 맨 끝에서만 사용할 수
              있다.</td></tr><tr><td>TM</td><td>TM</td><td><p>가장 작은 수의 문자를 사용해서 숫자를 표현한다. </p><p>TM9와 TMe의
              형태로 사용할 수 있다. TM9는 TM과 같다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>TM9는 과학적 기수법이 아닌 고정 소수점으로 숫자를 출력한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>TMe는 과학적 기수법으로 출력한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>TM은 다른 형식 요소와 함께 쓰일 수 없다.</p>
                  </li></ul></div></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 TO_NUMBER 함수를 사용했을 때 각 NUMBER 타입의 값이 형식 문자열에 따라 어떻게
      출력<a id="d5e4059" class="indexterm"/>되는지를 보여준다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="200"/><col width="200"/><col/></colgroup><thead><tr><th>NUMBER 타입의 값</th><th>형식 문자열</th><th>출력 결과</th></tr></thead><tbody><tr><td>0</td><td>99.99</td><td>' .00'</td></tr><tr><td>0.1</td><td>99.99</td><td>' .10'</td></tr><tr><td>-0.1</td><td>99.99</td><td>' -.10'</td></tr><tr><td>0</td><td>90.99</td><td>' 0.00'</td></tr><tr><td>0.1</td><td>90.99</td><td>' 0.10'</td></tr><tr><td>-0.1</td><td>90.99</td><td>' -0.10'</td></tr><tr><td>0</td><td>9999</td><td>' 0'</td></tr><tr><td>1</td><td>9999</td><td>' 1'</td></tr><tr><td>0.1</td><td>9999</td><td>' 0'</td></tr><tr><td>-0.1</td><td>9999</td><td>' -0'</td></tr><tr><td>123.456</td><td>999.999</td><td>' 123.456'</td></tr><tr><td>-123.456</td><td>999.999</td><td>'-123.456'</td></tr><tr><td>123.456</td><td>FM999.999</td><td>'123.456'</td></tr><tr><td>123.45</td><td>999.009</td><td>' 123.450'</td></tr><tr><td>123.45</td><td>FM999.009</td><td>'123.45'</td></tr><tr><td>123</td><td>FM999.009</td><td>'123.00'</td></tr><tr><td>12345</td><td>99999S</td><td>'12345+'</td></tr></tbody></table>
      </div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_date_type_format"/>2.4.2. 날짜형 타입</h3></div></div></div>
      

      <p><span><strong class="guibutton">날짜형 타입의 형식 문자열</strong></span><a id="d5e4144" class="indexterm"/><a id="d5e4147" class="indexterm"/>은 TO_CHAR 함수, TO_DATE 함수, TO_TIMESTAMP 함수, TO_TIMESTAMP_TZ
      함수에서 파라미터로 사용할 수 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">함수</th><th>설명</th></tr></thead><tbody><tr><td align="left">TO_CHAR</td><td>날짜형 타입의 값을 문자열로 변환한다.</td></tr><tr><td align="left">TO_DATE</td><td>문자열을 날짜형 타입의 값으로 변환한다.</td></tr><tr><td align="left">TO_TIMESTAMP</td><td>문자열을 날짜/시간형 타입의 값으로 변환한다.</td></tr><tr><td align="left">TO_TIMESTAMP_TZ</td><td>문자열을 시간대를 포함하는 날짜/시간형 타입의 값으로 변환한다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>날짜형 타입의 형식 문자열은 다음과 같은 특징이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>여러 가지 형식 요소로 구성된다. 날짜형 타입에 포함된 '연, 월, 일, 시, 분, 초' 등의 값을 각각 어떤
          형식으로 출력할 것인지 지정한다. 예를 들어 연도를 나타내는 형식 요소 문자열인 'YYYY'와 'YY'의 경우 연도의
          마지막 네 자리 또는 두 자리만 출력하도록 한다. 즉, 2009년의 경우 각각 '2009'와 '09'를
          출력한다.</p>
        </li><li>
          <p>하이픈(-) 또는 슬래시(/)를 삽입할 수 있다. 만약 형식 문자열 내에 형식 요소 이외의 문자열을 삽입하고
          싶다면 큰따옴표(" ")를 이용하여 나타낸다.</p>
        </li><li>
          <p>대소문자를 구분하는 형식 요소가 있다. 예를 들어 요일을 출력하기 위한 형식 요소인 'DAY'는 요일 문자열
          전체를 대문자로, 'Day'는 맨 앞 글자만 대문자로, 'day'는 전체를 소문자로 출력한다. 월요일의 경우, 각각
          'MONDAY', 'Monday', 'monday'로 출력한다.</p>
        </li></ul></div>

      <p/>

      <div class="literallayout"><p/></div>

      <p>다음은 날짜형 타입의 형식 문자열에 포함될 수 있는 형식 요소<a id="d5e4182" class="indexterm"/>이다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="100"/><col width="90"/><col/></colgroup><thead><tr><th>형식 요소</th><th>TO_* 함수의 입력으로 사용 가능 여부</th><th>설명</th></tr></thead><tbody><tr><td><p>-</p><p>,</p><p>.</p><p>;</p><p>:</p><p>/</p><p>"text"</p></td><td>-</td><td>결과 값에 해당하는 위치에 그대로 출력된다.</td></tr><tr><td><p>AD</p><p>A.D.</p><p>BC</p><p>B.C.</p></td><td>예</td><td>서기 또는 기원 전을 표시한다.</td></tr><tr><td><p>AM</p><p>A.M.</p><p>PM</p><p>P.M.</p></td><td>예</td><td>오전 또는 오후를 표시한다.</td></tr><tr><td><p>CC</p><p>SCC</p></td><td>아니오</td><td><p>세기를 출력한다. (예: 2005년일 때는 21을 반환한다.)</p><p>SCC는
              기원전일 경우 마이너스(-)를 붙인다.</p></td></tr><tr><td>D</td><td>아니오</td><td>1주일 중 몇 번째 날인지 출력한다. (1-7)</td></tr><tr><td>DAY</td><td>아니오</td><td>요일을 출력한다. (예: THURSDAY)</td></tr><tr><td>DD</td><td>예</td><td>1개월 중 몇 번째 날인지 출력한다. (1-31)</td></tr><tr><td>DDD</td><td>예</td><td>1년 중 몇 번째 날인지 출력한다. (1-366)</td></tr><tr><td>DY</td><td>아니오</td><td>축약 표기한 요일을 출력한다. (예: THU)</td></tr><tr><td>FF[1~9]</td><td>예</td><td>소수점 이하 자리의 초를 나타낸다. FF 뒤에 명시한 숫자(1~9) 만큼 소수점 이하 자릿수가
              출력된다. 명시하지 않으면 데이터 타입의 디폴트 정밀도를 따른다.</td></tr><tr><td>FM</td><td>예</td><td>앞뒤 공백을 제거하고 출력하도록 하는 <a href="ch_sql_elements.html#sect_format_modifier" title="2.4.3. 형식 조절자">형식 조절자</a>이다.</td></tr><tr><td>FX</td><td>예</td><td>형식 문자열과 입력 문자열의 일치여부를 검사하는 <a href="ch_sql_elements.html#sect_format_modifier" title="2.4.3. 형식 조절자">형식 조절자</a>이다.</td></tr><tr><td><p>HH</p><p>HH12</p></td><td>예</td><td>시간을 출력한다. (1-12)</td></tr><tr><td>HH24</td><td>예</td><td>시간을 출력한다. (0-23)</td></tr><tr><td><p>IYYYY</p><p>IYYY</p><p>IYY</p><p>IY</p></td><td>아니오</td><td>4(3/2/1)자릿수 연도 표기를 ISO 표준에 의거 출력한다.</td></tr><tr><td>MI</td><td>예</td><td>분을 출력한다. (0-59)</td></tr><tr><td>MM</td><td>예</td><td>달을 출력한다. (1-12)</td></tr><tr><td>MON</td><td>예</td><td>축약된 달 이름을 출력한다. (예: DEC)</td></tr><tr><td>MONTH</td><td>예</td><td>달을 출력한다. (예: DECEMBER)</td></tr><tr><td>Q</td><td>아니오</td><td>분기를 출력한다. (1-4)</td></tr><tr><td>RM</td><td>예</td><td>달을 로마 숫자로 출력한다. (I-XII)</td></tr><tr><td>RR</td><td>예</td><td>두 자릿수의 연도의 입력 값에 따라 몇 세기인지 자동으로 조절한다.</td></tr><tr><td>RRRR</td><td>예</td><td>반올림한 연도를 표기한다. 4자리 또는 2자리를 입력받는다. 2자리로 입력했을 경우는 RR과 똑같이
              동작한다.</td></tr><tr><td>SS</td><td>예</td><td>초를 출력한다. (0-59)</td></tr><tr><td>SSSSS</td><td>예</td><td>자정을 기준으로 현재 몇 초인지 출력한다. (0-86399)</td></tr><tr><td>WW</td><td>아니오</td><td><p>1년 중 몇 번째 주인지 출력한다. (1-53) </p><p>첫 번째 주는 1월
              1일에 시작하고 1월 7일에 끝난다.</p></td></tr><tr><td>W</td><td>아니오</td><td><p>1개월 중 몇 번째 주인지 출력한다. (1-5) </p><p>첫 번째 주는 그 달
              1일에 시작하고 그 달 7일에 끝난다.</p></td></tr><tr><td>X</td><td>예</td><td>점(.)을 출력한다. TIMESTAMP를 출력하는 경우 소수점 자릿수를 표현하기 위해서
              사용된다.</td></tr><tr><td><p>YEAR</p><p>SYEAR</p></td><td>아니오</td><td>숫자로 된 연도를 단어로 풀어 쓴다. SYEAR는 기원전 연도에 마이너스(-)를 붙인다.</td></tr><tr><td><p>YYYY</p><p>SYYYY</p></td><td>아니오</td><td>4자릿수 연도를 표기한다. SYYYY는 기원전 연도에 마이너스(-)를 붙인다.</td></tr><tr><td><p>YYY</p><p>YY</p><p>Y</p></td><td>예</td><td>3(2/1)자릿수 연도를 출력한다.</td></tr><tr><td>TZH</td><td>예</td><td>시간대에서의 시간을 출력한다.</td></tr><tr><td>TZM</td><td>예</td><td>시간대에서의 분을 출력한다.</td></tr><tr><td>TZR</td><td>예</td><td>시간대에서의 지역을 출력한다.</td></tr><tr><td>TZD</td><td>예</td><td>시간대에서의 일광 절약시간 약어를 출력한다. 이 값은 반드시 TZR에서의 지역과 일치해야
              한다.</td></tr><tr><td>EE</td><td>예</td><td>연호를 출력한다(Japanese Imperial and Thai Buddha
              calendars).</td></tr><tr><td>E</td><td>예</td><td>연호의 약어를 출력한다(Japanese Imperial and Thai Buddha
              calendars).</td></tr></tbody></table>
      </div>

      <p>위의 표에서의 RR 형식 요소는 YY 형식 요소와 유사하나, 다른 세기의 연도 값을 더 간편하게 명시하고 저장할 수
      있다.</p>

      <p>RR 형식 요소의 정확한 규칙은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>현재 연도의 마지막 두 자리가 00 ~ 49 사이일 경우</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>명시한 두 자릿수 연도가 00 ~ 49 사이일 경우 반환되는 연도는 현재 연도와 앞의 두 자리가
              같다.</p>
            </li><li>
              <p>명시한 두 자릿수 연도가 50 ~ 99 사이일 경우 반환되는 연도의 앞의 두 자리는 현재 연도의 앞의 두
              자리에 1을 뺀 값과 같다.</p>
            </li><li>
              <p>다음은 2000~2049년에 수행했음을 가정했을 때의 예제이다.</p>

              <pre class="programlisting">SQL&gt; SELECT TO_CHAR(TO_DATE('20/08/13', 'RR/MM/DD'), 'YYYY') YEAR FROM DUAL;

YEAR
----------------------------
2020

SQL&gt; SELECT TO_CHAR(TO_DATE('98/12/25', 'RR/MM/DD'), 'YYYY') YEAR FROM DUAL;

YEAR
----------------------------
1998
</pre>
            </li></ul></div>
        </li><li>
          <p>현재 연도의 마지막 두 자리가 50 ~ 99 사이일 경우</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>명시한 두 자릿수 연도가 00 ~ 49 사이일 경우 반환되는 연도의 앞의 두 자리는 현재 연도의 앞의 두
              자리에 1을 더한 값과 같다.</p>
            </li><li>
              <p>명시한 두 자릿수 연도가 50 ~ 99 사이일 경우 반환되는 연도는 현재 연도와 앞의 두 자리가
              같다.</p>
            </li><li>
              <p>다음은 1950~1999년에 수행했음을 가정했을 때의 예제이다.</p>

              <pre class="programlisting">SQL&gt; SELECT TO_CHAR(TO_DATE('12/10/27', 'RR/MM/DD'), 'YYYY') YEAR FROM DUAL;

YEAR
----------------------------
2012

SQL&gt; SELECT TO_CHAR(TO_DATE('92/02/08', 'RR/MM/DD'), 'YYYY') YEAR FROM DUAL;

YEAR
----------------------------
1992
</pre>
            </li></ul></div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>날짜형 타입의 형식 요소<a id="d5e4406" class="indexterm"/><a id="d5e4409" class="indexterm"/>에는 다음과 같은 접미어<a id="d5e4412" class="indexterm"/>를 사용할 수 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th>접미어</th><th>의미</th><th>형식 문자열</th><th>출력 예</th></tr></thead><tbody><tr><td>TH</td><td>서수</td><td>DDTH</td><td>05TH</td></tr><tr><td>SP</td><td>철자로 표기한 숫자</td><td>DDSP</td><td>FIVE</td></tr><tr><td>SPTH 또는 THSP</td><td>철자로 표기한 서수</td><td>DDSPTH</td><td>FIFTH</td></tr></tbody></table>
      </div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
          <p>이 접미어는 출력할 때만 사용할 수 있으며, 숫자를 출력하는 형식 요소에만 사용할 수 있다.</p>
        </div>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_format_modifier"/>2.4.3. 형식 조절자</h3></div></div></div>
      

      <p>형식 조절자<a id="d5e4448" class="indexterm"/><a id="d5e4450" class="indexterm"/>는 형식 문자열 안에서 여러 번 표현할 수 있다. 이러한 경우 나타낼 때마다 각각의 기능이 비활성화되어
      있으면 활성화하고, 활성화 되어 있으면 비활성화한다.</p>

      <p>FM 형식 조절자를 통해 공백을 채우는 방식을 변경할 수 있고, FX 형식 조절자를 통해 입력 문자열과 형식 문자열이
      정확히 일치하는지 검사할 수 있다.</p>

      <p/>

      <p/>

      <h4><a id="d5e4456"/>FM<a id="d5e4457" class="indexterm"/><a id="d5e4460" class="indexterm"/></h4>

      <p><span>Tibero</span>는 각각의
      형식 요소에 대해 그 형식 요소가 출력하는 문자열의 최대 크기만큼 공백 문자를 채운다. 예를 들어 MONTH 형식 요소의 경우,
      가장 긴 달은 'SEPTEMBER'이므로 나머지 달은 오른쪽에 공백을 채워서 아홉 글자를 맞추게 된다.</p>

      <p>FM을 명시하면 공백을 채우는 방법이 다음과 같이 달라진다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>TO_CHAR 함수의 DATE 타입 형식 문자열에서, FM을 사용하는 경우</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>모든 공백 문자와 앞에 붙는 '0'이 제거된다. 예를 들어 4월을 MM으로 출력하면 04 대신 4가
              출력된다.</p>
            </li><li>
              <p>FM이 비활성화된 경우는 각각의 형식 요소에 대해 항상 같은 길이의 문자열이 출력되지만, FM이
              활성화되어 있을 경우는 이 문자열의 길이가 입력에 따라 바뀔 수 있다.</p>
            </li></ul></div>
        </li><li>
          <p>TO_CHAR 함수의 NUMBER 타입 형식 문자열에서, FM을 사용하는 경우</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>숫자 앞에 붙는 모든 공백 문자와 '9' 형식 요소에 의해 생긴 뒤에 붙는 모든 0이 제거된다. 그러므로
              결과는 왼쪽으로 정렬된 형태로 출력된다.</p>
            </li><li>
              <p>FM이 비활성화된 경우 공백 문자는 숫자의 앞을 채우기 때문에, 항상 오른쪽 정렬이 된다.</p>
            </li></ul></div>
        </li></ul></div>

      <p/>

      <div class="literallayout"><p/></div>

      <p/>

      <p/>

      <h4><a id="d5e4486"/>FX<a id="d5e4487" class="indexterm"/><a id="d5e4490" class="indexterm"/></h4>

      <p><span>Tibero</span>는 형식
      문자열과 입력 문자열이 정확히 일치하는지 검사하고, 만약 하나라도 어긋나는 경우엔 에러를 발생시킨다.</p>

      <p>FX를 명시하면 다음과 같은 제약조건을 가진다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>구분자나 큰따옴표(" ") 문자열의 위치가 형식 문자열에서의 위치와 정확히 일치해야 한다.</p>
        </li><li>
          <p>추가적인 공백 문자를 허용하지 않는다. 만약 FX가 비활성화된 경우엔 공백 문자는 무시된다.</p>
        </li><li>
          <p>입력 문자열에서 숫자들의 자릿수는 형식 문자열 각 요소에서 사용하는 자릿수와 정확히 일치해야 한다.</p>
        </li></ul></div>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_2_4"/>2.5. 의사 컬럼</h2></div></div></div>
    

    <p>의사 컬럼<a id="d5e4508" class="indexterm"/>은 사용자가 명시적으로 선언하지 않아도, <span>Tibero</span> 시스템이 자동으로 모든 테이블에 포함하는
    컬럼이다.</p>

    <p/>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_rowid"/>2.5.1. ROWID</h3></div></div></div>
      

      <p>ROWID<a id="d5e4516" class="indexterm"/><a id="d5e4518" class="indexterm"/>는 전체 데이터베이스 내의 하나의 로우를 유일하게 참조하는 식별자이다. ROWID는 그 로우의
      <span>디스크</span>의 물리적인 위치를
      가리키고 있으며, 그 로우가 삭제될 때까지 변화되지 않는다.</p>

      <p><span>Tibero</span>에서는 데이터베이스의 저장을 위한 디스크 구조를 다단계로
      구성하고 있다. <a id="d5e4524" class="indexterm"/>ROWID를 이용하여 디스크의 특정 로우를 찾아갈 수 있으려면, ROWID는 이러한 디스크 구조를
      반영해야 한다.</p>

      <p><span>Tibero</span>의 ROWID는 다음의 <a href="ch_sql_elements.html#fig_ROWID_structure" title="[그림 2.1] ROWID의 구조">[그림 2.1]</a>과 같은 구조를 갖는다.</p>

      <div class="figure"><a id="fig_ROWID_structure"/><p class="title"><b>[그림 2.1] ROWID의 구조</b></p><div class="figure-contents">
        

        <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="700"><tr><td align="left"><img src="resources/sql01-02.png" align="top" width="700" alt="ROWID의 구조"/></td></tr></table></div>
      </div></div><br class="figure-break"/>

      <p/>

      <p>ROWID는 전체 12byte로 구성되어 있으며, Segment, Data File, Data Block, Row가
      각각 4, 2, 4, 2byte로 되어 있다.</p>

      <p>ROWID 값을 표현하기 위한 포맷으로는 BASE64 인코딩을 이용한다. BASE64 인코딩은 6bits에 포함된
      숫자를 8bits 문자로 나타내는 방식으로, 0 ~ 63까지의 숫자를 A ~ Z, a ~ z, 0 ~ 9, +, /로
      대치한다.</p>

      <p>ROWID를 BASE64 인코딩으로 변환하면 Segment#, Data File#, Data Block#, Row#가
      각각 6, 3, 6, 3byte로 되고, 'SSSSSSFFFBBBBBBRRR'의 형태를 갖는다. 예를 들어 Segment# =
      100, Data File# = 20, Data Block# = 250, Row# = 0인 ROWID는
      'AAAABkAAUAAAAD6AAA'로 나타낸다.</p>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4542"/>2.5.2. ROWNUM</h3></div></div></div>
      

      <p>ROWNUM<a id="d5e4545" class="indexterm"/><a id="d5e4548" class="indexterm"/>은 SELECT 문장의 실행 결과로 나타나는 로우에 대하여 순서대로 번호를 부여한다. 질의 결과로
      반환되는 첫 번째 로우는 ROWNUM = 1이며 두 번째 로우는 ROWNUM = 2, 세 번째 로우는 ROWNUM = 3, …,
      등등의 값을 갖는다.</p>

      <p><span>Tibero</span>에서
      ROWNUM이 할당되는 순서는 다음과 같다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p>질의를 수행한다.</p>
        </li><li>
          <p>질의 결과로 로우가 생성된다.</p>
        </li><li>
          <p>로우를 반환하기 직전에 그 로우에 ROWNUM이 할당된다.</p>

          <p><span>Tibero</span>는 내부적으로 ROWNUM 카운터를 가지고
          있으며, 카운터 값을 질의 결과의 로우에 할당한다.</p>
        </li><li>
          <p>ROWNUM을 할당 받은 로우에 ROWNUM에 대한 조건식을 적용한다.</p>
        </li><li>
          <p>조건식을 만족하면 할당된 ROWNUM이 확정되고, 내부의 ROWNUM 카운터의 값이 1로 증가한다.</p>
        </li><li>
          <p>조건식을 만족하지 않으면 그 로우는 버려지고, 내부의 ROWNUM 카운터의 값은 증가하지 않는다.</p>
        </li></ol></div>

      <div class="literallayout"><p/></div>

      <p>ROWNUM은 질의 결과의 로우 개수를 한정하기 위하여 많이 사용된다. 아래의 SQL 문장은 10개의 로우만을 반환하는
      예이다.</p>

      <pre class="programlisting">SELECT * FROM EMP WHERE ROWNUM &lt;= 10;</pre>

      <p>ROWNUM은 질의를 처리하는 거의 마지막 단계에서 할당된다. 때문에 같은 SELECT 문장이라 하더라도 내부적으로
      어떤 단계로 질의를 처리하였는가에 따라 다른 결과를 가져올 수 있다. 예를 들어 질의 최적화기가 인덱스의 사용 유무를 어떻게
      결정하느냐에 따라 다른 결과를 얻는다.</p>

      <div class="literallayout"><p/></div>

      <p>ROWNUM을 포함하는 질의가 항상 같은 결과를 반환하도록 하기 위하여 ORDER BY 절을 사용할 수 있다. 하지만,
      <span>Tibero</span>에서는
      WHRER 절을 포함하는 모든 부질의를 처리한 다음에 ORDER BY 절을 처리한다. 따라서 ORDER BY 절을 이용해서 항상
      같은 결과를 얻을 수는 없다.</p>

      <p>예를 들어 다음의 질의는 실행할 때마다 다른 결과를 얻는다.</p>

      <pre class="programlisting">SELECT * FROM EMP WHERE ROWNUM &lt;= 10 ORDER BY EMPNO;</pre>

      <div class="literallayout"><p/></div>

      <p>위의 질의를 다음과 같이 변환하면 ORDER BY 절을 먼저 처리하게 되므로 항상 같은 결과를 얻을 수
      있다.</p>

      <pre class="programlisting">SELECT * FROM (SELECT * FROM EMP ORDER BY EMPNO)
WHERE ROWNUM &lt;= 10;</pre>

      <div class="literallayout"><p/></div>

      <p>또한, 다음과 같은 SELECT 문장은 하나의 로우도 반환하지 않는다.</p>

      <pre class="programlisting">SELECT * FROM EMP WHERE ROWNUM &gt; 1;</pre>

      <p>그 이유는 ROWNUM 값이 확정되기 전에 ROWNUM에 대한 조건식이 수행되기 때문이다. 위의 SELECT 문의
      결과는 첫 번째 로우가 ROWNUM = 1이기 때문에 조건식을 만족하지 않는다. 조건식을 만족하지 않으면 ROWNUM 카운터의
      값은 변하지 않는다. 따라서 두 번째 결과 로우도 ROWNUM = 1이므로 반환되지 않는다. 결국, 하나의 로우도 반환되지
      않는다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4584"/>2.5.3. LEVEL</h3></div></div></div>
      

      <p>LEVEL은 <a id="d5e4587" class="indexterm"/><a id="d5e4589" class="indexterm"/><a id="d5e4592" class="indexterm"/>계층 질의를 실행한 결과에 각 로우의 트리 내 계층을 출력하기 위한 컬럼 타입이다. 최상위 로우의
      LEVEL 값은 1이며, 하위 로우로 갈수록 1씩 증가한다. 계층 질의와 LEVEL 컬럼 값의 출력에 대해서는 <a href="ch_sql_queries.html#sect_hierarchical_query" title="5.5. 계층 질의">“5.5. 계층 질의”</a>에서 자세하게 설명한다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4595"/>2.5.4. CONNECT_BY_ISLEAF</h3></div></div></div>
      

      <p>CONNECT_BY_ISLEAF 의사 컬럼<a id="d5e4598" class="indexterm"/><a id="d5e4600" class="indexterm"/>은 현재 로우가 CONNECT BY 조건에 의해 정의된 트리(Tree)의 리프(Leaf)이면 1을
      반환하고 그렇지 않을 경우에는 0을 반환한다. 이 정보는 해당 로우가 계층 구조(Hierarchy)를 보여주기 위해 확장될 수
      있는지 없는지를 나타낸다.</p>

      <p>다음은 CONNECT_BY_ISLEAF 의사 컬럼을 사용한 예이다.</p>

      <pre class="programlisting">SQL&gt; SELECT ENAME, CONNECT_BY_ISLEAF, LEVEL, SYS_CONNECT_BY_PATH(ENAME,'-') "PATH"
     FROM EMP2
       START WITH ENAME = 'Clark'
       CONNECT BY PRIOR EMPNO = MGRNO
       ORDER BY ENAME;

ENAME           CONNECT_BY_ISLEAF LEVEL      PATH
--------------- ----------------- ---------- -----------------------
Alicia                          1          3 -Clark-Martin-Alicia
Allen                           1          3 -Clark-Ramesh-Allen
Clark                           0          1 -Clark
James                           1          3 -Clark-Martin-James
John                            0          3 -Clark-Ramesh-John
Martin                          0          2 -Clark-Martin
Ramesh                          0          2 -Clark-Ramesh
Ward                            1          4 -Clark-Ramesh-John-Ward
</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4605"/>2.5.5. CONNECT_BY_ISCYCLE</h3></div></div></div>
      

      <p>CONNECT_BY_ISCYCLE은 계층형 질의에서 사용되는 의사 컬럼<a id="d5e4608" class="indexterm"/><a id="d5e4610" class="indexterm"/>으로서 해당 로우가 자식 노드를 갖고 있음과 동시에 그 자식 노드가 해당 로우의 부모 노드가 되는지를
      판별한다. 즉, 부모 노드와 자식 노드의 루프 여부를 판별하여 이러한 자식 노드가 있을 경우 1, 없을 경우 0을
      반환한다.</p>

      <p>이 의사컬럼은 CONNECT BY 절에 반드시 NOCYCLE 구문이 명시되어야만 사용할 수 있다. 만약 NOCYCLE을
      명시할 경우 루프가 발생하더라도 에러를 발생시키지 않는다.</p>

      <p>다음은 CONNECT_BY_ISCYCLE 의사 컬럼을 사용한 예이다.</p>

      <pre class="programlisting">SQL&gt; SELECT ENAME, CONNECT_BY_ISCYCLE, LEVEL FROM EMP
     START WITH ENAME = 'Alice'
     CONNECT BY NOCYCLE PRIOR EMPNO = MGRNO
     ORDER BY ENAME;

ENAME           CONNECT_BY_ISCYCLE LEVEL
--------------- ------------------ ----------
Alice                            0          1
Smith                            1          2
Micheal                          0          3
Viki                             0          2
Jane                             1          2
Jacob                            0          4</pre>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e4617"/>2.6. NULL</h2></div></div></div>
    

    <p><a id="d5e4620" class="indexterm"/>한 로우에서 어떤 컬럼에 값이 없을 때 그 컬럼을 NULL이라고 하거나 NULL 값을 가진다고 한다.
    NULL은 NOT NULL 제약과 PRIMARY KEY 제약이 걸리지 않은 모든 데이터 타입의 칼럼에 포함될 수 있다. 실제 값을
    모르거나 아무런 의미 없는 값이 필요할 때 사용할 수 있다. NULL과 0은 다르기 때문에 NULL을 0으로 나타내면 안 된다. 다만
    문자 타입의 컬럼에 빈 문자열('')이 들어가면 NULL로 처리된다.</p>

    <p>NULL을 포함한 산술연산의 결과는 항상 NULL이다. 또한, 문자열 접합 연산(||)을 제외한 NULL을 포함하는 모든
    연산의 결과도 NULL이다.</p>

    <pre class="programlisting">NULL + 1 = NULL</pre>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4624"/>2.6.1. 함수에서의 NULL</h3></div></div></div>
      

      <p><a id="d5e4627" class="indexterm"/>REPLACE, NVL, CONCAT을 제외한 모든 상수 함수는 함수의 파라미터가 NULL일 경우 반환
      값은 NULL이다. <a id="d5e4630" class="indexterm"/><a id="d5e4633" class="indexterm"/>NVL 함수를 사용하면 NULL을 다른 값으로 반환할 수 있다. 컬럼 값이 NULL일 때
      NVL(column, 0) = 0이 되며, 컬럼 값이 NULL이 아닐 때 NVL(column, 0) = column이 된다.
      <a id="d5e4636" class="indexterm"/><a id="d5e4639" class="indexterm"/>대부분의 집단 함수는 NULL을 무시한다.</p>

      <p>다음은 NULL을 포함한 데이터에 AVG 함수를 사용했을 때의 결과이다.</p>

      <pre class="programlisting">DATA = {1000, 500, NULL, NULL, 1500}
AVG(DATA) = (1000 + 500 + 1500) /3 = 1000 </pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4644"/>2.6.2. NULL에 대한 비교조건</h3></div></div></div>
      

      <p><a id="d5e4647" class="indexterm"/>NULL을 검사할 수 있는 비교조건은 <a id="d5e4650" class="indexterm"/>IS NULL과 <a id="d5e4652" class="indexterm"/> IS NOT NULL만 가능하다. NULL은 데이터가 없다는 것을 의미한다. 때문에 NULL과
      NULL, NULL과 NULL이 아닌 다른 값을 서로 비교할 수 없다.</p>

      <p>다만 <a id="d5e4655" class="indexterm"/><a id="d5e4658" class="indexterm"/>DECODE 함수에서는 두 개의 NULL을 비교할 수 있다.</p>

      <pre class="programlisting">SQL&gt; SELECT DECODE(NULL, NULL, 1) FROM DUAL;

DECODE(NULL,NULL,1)
-------------------
                  1</pre>

      <p>위의 예에서 DECODE 함수를 통해 NULL이 서로 비교되었으며, 그 결과로 서로 같다는 의미인 '1'이 반환되었음을
      알 수 있다.</p>

      <p>만일 NULL에 다른 비교조건을 사용하면, 결과는 UNKOWN으로 나타난다. UNKNOWN으로 판별되는 조건은 거의
      대부분 FALSE처럼 처리된다. 그 예로 SELECT 문에서 WHERE 절에 UNKNOWN으로 판별되는 조건이 있을 경우 반환되는
      로우가 없다. 하지만 UNKNOWN이 FALSE와 다른 점은 UNKNOWN 조건에 또 다른 연산자가 더해져도 결과는
      UNKNOWN이라는 점이다.</p>

      <p>다음은 FALES에 NOT 연산자를 사용한 결과와 UNKNOWN에 NOT 연산자를 사용한 결과의 차이를
      보여준다.</p>

      <pre class="programlisting">NOT FALES = TRUE
NOT UNKNOWN = UNKNOWN</pre>

      <p/>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e4669"/>2.7. 주석</h2></div></div></div>
    

    <p>SQL 문장과 스키마 객체에는 <a id="d5e4672" class="indexterm"/>주석을 삽입할 수 있다. 책이나 문서에서 주석이 낱말이나 문장의 뜻을 쉽게 풀이하는 역할을 하듯 SQL
    문장에도 주석을 활용하여 해당 문장의 부연 설명을 삽입할 수 있다.</p>

    <p>주석의 내용은 데이터베이스에서 사용하는 문자 집합으로 표현할 수 있는 문자라면 어떤 내용이라도 포함될 수 있으며, 예약어,
    파라미터, 점 사이 등 어떤 곳에도 추가될 수 있다. 주석은 SQL 문장의 실행에는 전혀 영향을 주지 않는다.</p>

    <p>주석은 애플리케이션의 소스 코드를 읽기 쉽고 관리하기 좋게 만들어 준다. 예를 들어 애플리케이션 소스 코드 내부에 있는
    <a id="d5e4676" class="indexterm"/>SQL 문장에, 그 문장의 용도와 목적 등의 주석을 삽입해 두면, 각각의 문장의 의미를 쉽게 파악할 수
    있다.</p>

    <p>주석을 삽입하는 방법<a id="d5e4679" class="indexterm"/>은 다음과 같이 두 가지이다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>시작 기호(/*)로 주석의 시작을 나타내고 마침 기호(*/)로 주석을 끝낸다.</p>

        <p>주석의 내용을 여러 줄에 걸쳐 삽입할 수 있다. 시작 기호(/*)와 마침 기호(*/)를 내용과 구분하기 위해
        공백이나 줄 바꿈을 사용할 필요는 없다.</p>
      </li><li>
        <p>'--'로 주석의 시작을 나타내고 바로 뒤에 주석의 내용을 적는다.</p>

        <p>해당 줄의 끝이 주석의 끝을 나타내므로 주석의 내용이 다음 줄로 넘어가서는 안 된다.</p>
      </li></ul></div>

    <div class="literallayout"><p/></div>

    <p>다음은 SQL 문장에 주석을 삽입한 예이다.</p>

    <pre class="programlisting">SELECT emp_id, emp_name,
       e.dept_id                /* 부서가 총무과인 직원의 명단을 출력한다. */
                                /* 테이블 */
FROM emp e, dept d
WHERE e.dept_id = d.dept_id
 AND  d.dept_name = '총무과'
 AND  e.status != 1;            /* 퇴사한 사람 제외 */


SELET emp_id, emp_name, e.dept  -- 부서가 자재과인 직원의 명단을 출력한다.
                                -- 테이블
FROM emp e, dept d
WHERE e.dept_id = d.dept_id
 AND  d.dept_name = '자재과'
 AND  e.status != 1;            -- 퇴사한 사람 제외</pre>

    <p>위와 같이 SQL 문장뿐만 아니라 스키마 객체에도 주석을 삽입할 수 있다. 즉 <a id="d5e4693" class="indexterm"/><a href="ch_ddl.html#sect_ddl_COMMENT" title="7.22. COMMENT">COMMENT</a> 명령을 사용하여
    <a id="d5e4696" class="indexterm"/>스키마 객체인 테이블, 뷰, 컬럼에 주석을 삽입할 수 있다. 스키마 객체에 삽입된 주석은 데이터 사전에
    저장된다.</p>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_HINTS"/>2.8. 힌트</h2></div></div></div>
    

    <p>힌트는 일종의 지시문이다. SQL 문장에 힌트를 추가하여 <span>Tibero</span>의 질의 최적화기(Optimizer)에 특정 행동을
    지시하거나 <a id="d5e4704" class="indexterm"/><a id="d5e4707" class="indexterm"/>질의 최적화기의 실행 계획을 변경한다. 질의 최적화기가 항상 최적의 실행 계획을 수립할 수는 없다. 따라서
    개발자가 질의 최적화기의 실행 계획을 직접 수정할 수 있는 방법을 마련한 것이 바로 힌트이다.</p>

    <p>SQL 문장의 한 블록당 힌트는 하나만 올 수 있으며, SELECT, UPDATE, INSERT, DELETE 절 바로
    뒤에 <a id="d5e4710" class="indexterm"/>위치해야 한다.</p>

    <p>다음은 힌트를 사용한 예이다.</p>

    <pre class="programlisting">(DELETE|INSERT|SELECT|UPDATE) /*+ hint [hint] ... */

또는

(DELETE|INSERT|SELECT|UPDATE) --+ hint [hint] ...</pre>

    <div class="literallayout"><p/></div>

    <p>힌트를 사용할 때 주의할 점은 다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>힌트는 반드시 DELETE, INSERT, SELECT, UPDATE 절 뒤에만 올 수 있다.</p>
      </li><li>
        <p>'+' 기호는 반드시 주석 구분자('/*' 또는 '--') 바로 뒤에 공백 없이 붙여 써야 한다.</p>
      </li><li>
        <p>힌트와 '+' 기호 사이에 공백은 있어도 되고, 없어도 된다.</p>
      </li><li>
        <p>문법에 맞지 않는 힌트는 주석으로 취급되며, 에러는 발생하지 않는다.</p>
      </li></ul></div>

    <div class="literallayout"><p/></div><p>다음은 힌트의 종류<a id="d5e4728" class="indexterm"/><a id="d5e4731" class="indexterm"/>이다.</p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="100"/><col width="160"/><col/></colgroup><thead><tr><th>구성요소</th><th>힌트</th><th>설명</th></tr></thead><tbody><tr><td rowspan="6" valign="middle">질의 변형</td><td><a href="ch_sql_elements.html#no_query_transformation" title="2.8.1. NO_QUERY_TRANSFORMATION">NO_QUERY_TRANSFORMATION</a></td><td>질의 변형기에게 전체 쿼리에 대해서 변형을 실행하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_merge" title="2.8.1. NO_MERGE">NO_MERGE</a></td><td>질의 변형기에게 특정 뷰에 대한 뷰 병합(View Merging)을 하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#unnest" title="2.8.1. UNNEST">UNNEST</a></td><td>질의 변형기에게 특정 부질의를 언네스팅(Unnesting)하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_unnest" title="2.8.1. NO_UNNEST">NO_UNNEST</a></td><td>질의 변형기에게 특정 부질의에 대해 언네스팅을 수행하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_join_elimination" title="2.8.1. NO_JOIN_ELIMINATION">NO_JOIN_ELIMINATION</a></td><td>질의 변형기에게 조인 제거를 수행하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#star_transformation" title="2.8.1. STAR_TRANSFORMATION">STAR_TRANSFORMATION</a></td><td>질의 변형기에게 스타 변형(Star Transformation)을 하도록 지시한다.</td></tr><tr><td rowspan="2" valign="middle">최적화 방법</td><td><a href="ch_sql_elements.html#all_rows" title="2.8.2. ALL_ROWS">ALL_ROWS</a></td><td>전체 결과에 대한 처리량이 가장 많도록 처리과정의 최적화를 선택한다.</td></tr><tr><td><a href="ch_sql_elements.html#first_rows" title="2.8.2. FIRST_ROWS">FIRST_ROWS</a></td><td>결과를 가장 빠르게 보여줄 수 있도록 결과 표시의 최적화를 선택한다.</td></tr><tr><td rowspan="12" valign="middle">접근 방법</td><td><a href="ch_sql_elements.html#full" title="2.8.3. FULL">FULL</a></td><td>전체 테이블을 스캔하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#index" title="2.8.3. INDEX">INDEX</a></td><td>명시한 인덱스를 사용한 인덱스 스캔을 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_index" title="2.8.3. NO_INDEX">NO_INDEX</a></td><td>명시한 인덱스를 사용한 인덱스 스캔을 하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#index_asc" title="2.8.3. INDEX_ASC">INDEX_ASC</a></td><td>명시한 인덱스를 사용한 인덱스 스캔을 오름차순으로 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#index_desc" title="2.8.3. INDEX_DESC">INDEX_DESC</a></td><td>명시한 인덱스를 사용한 인덱스 스캔을 내림차순으로 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#index_ffs" title="2.8.3. INDEX_FFS">INDEX_FFS</a></td><td>명시한 인덱스를 사용한 인덱스를 사용해 빠른 전체 인덱스 스캔(Fast Full Index Scan)을
            하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_index_ffs" title="2.8.3. NO_INDEX_FFS">NO_INDEX_FFS</a></td><td>명시한 인덱스를 사용한 빠른 전체 인덱스 스캔을 하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#index_rs" title="2.8.3. INDEX_RS???TITLE??????TITLE???">INDEX_RS</a></td><td>명시한 인덱스를 사용한 인덱스를 사용해 범위 인덱스 스캔(Range Index Scan)을 하도록
            지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_index_rs" title="2.8.3. NO_INDEX_RS???TITLE??????TITLE???">NO_INDEX_RS</a></td><td>명시한 인덱스를 사용한 범위 인덱스 스캔을 하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#index_ss" title="2.8.3. INDEX_SS???TITLE??????TITLE???">INDEX_SS</a></td><td>명시한 인덱스를 사용한 인덱스를 사용해 인덱스 스킵 스캔(Index Skip Scan)을 하도록
            지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_index_ss" title="2.8.3. NO_INDEX_SS???TITLE??????TITLE???">NO_INDEX_SS</a></td><td>명시한 인덱스를 사용한 인덱스 스킵 스캔을 하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#index_join" title="2.8.3. INDEX_JOIN???TITLE??????TITLE???">INDEX_JOIN</a></td><td>명시한 테이블에 두 개 이상의 인덱스를 사용하여 자체 조인(Self Join)하도록
            지시한다.</td></tr><tr><td rowspan="2" align="left" valign="middle">조인 순서</td><td><a href="ch_sql_elements.html#leading" title="2.8.4. LEADING???TITLE??????TITLE???">LEADING</a></td><td>먼저 조인되어야 할 테이블의 집합을 명시한다.</td></tr><tr><td><a href="ch_sql_elements.html#ordered" title="2.8.4. ORDERED???TITLE??????TITLE???">ORDERED</a></td><td>테이블을 FROM 절에 명시된 순서대로 조인하도록 지시한다.</td></tr><tr><td rowspan="15" valign="middle">조인 방법</td><td><a href="ch_sql_elements.html#use_nl" title="2.8.5. USE_NL???TITLE??????TITLE???">USE_NL</a></td><td>중첩 루프 조인을 사용하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_use_nl" title="2.8.5. NO_USE_NL???TITLE??????TITLE???">NO_USE_NL</a></td><td>중첩 루프 조인을 사용하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#use_nl_with_index" title="2.8.5. USE_NL_WITH_INDEX???TITLE??????TITLE???">USE_NL_WITH_INDEX</a></td><td>명시한 인덱스와 두 테이블에 대한 조인 조건을 이용해 중첩 루프 조인을 사용하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#use_merge" title="2.8.5. USE_MERGE???TITLE??????TITLE???">USE_MERGE</a></td><td>합병 조인을 사용하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_use_merge" title="2.8.5. NO_USE_MERGE???TITLE??????TITLE???">NO_USE_MERGE</a></td><td>합병 조인을 사용하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#use_hash" title="2.8.5. USE_HASH???TITLE??????TITLE???">USE_HASH</a></td><td>해시 조인을 사용하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_use_hash" title="2.8.5. NO_USE_HASH???TITLE??????TITLE???">NO_USE_HASH</a></td><td>해시 조인을 사용하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#hash_sj" title="2.8.5. HASH_SJ???TITLE??????TITLE???">HASH_SJ</a></td><td>부질의를 언네스팅할 때 해시방법을 이용한 세미조인으로 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#hash_sj" title="2.8.5. HASH_SJ???TITLE??????TITLE???">HASH_AJ</a></td><td>부질의를 언네스팅할 때 해시방법을 이용한 안티조인으로 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#merge_sj" title="2.8.5. MERGE_SJ???TITLE??????TITLE???">MERGE_SJ</a></td><td>부질의를 언네스팅할 때 머지방법을 이용한 세미조인으로 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#merge_aj" title="2.8.5. MERGE_AJ???TITLE??????TITLE???">MERGE_AJ</a></td><td>부질의를 언네스팅할 때 머지방법을 이용한 안티조인으로 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#nl_sj" title="2.8.5. NL_SJ???TITLE??????TITLE???">NL_SJ</a></td><td>부질의를 언네스팅할 때 네스티드 룹 방법을 이용한 세미조인으로 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#nl_aj" title="2.8.5. NL_AJ???TITLE??????TITLE???">NL_AJ</a></td><td>부질의를 언네스팅할 때 네스티드 룹 방법을 이용한 안티조인으로 하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#swap_join_inputs" title="2.8.5. SWAP_JOIN_INPUTS???TITLE??????TITLE???">SWAP_JOIN_INPUTS</a></td><td>해시 조인을 수행하는 경우 빌드 테이블이 되도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_swap_join_inputs" title="2.8.5. NO_SWAP_JOIN_INPUTS???TITLE??????TITLE???">NO_SWAP_JOIN_INPUTS</a></td><td>해시 조인을 수행하는 경우 조인 순서가 변경되지 않도록 지시한다.</td></tr><tr><td rowspan="3" valign="middle">병렬 처리</td><td><a href="ch_sql_elements.html#parallel" title="2.8.6. PARALLEL???TITLE??????TITLE???">PARALLEL</a></td><td>지정한 개수의 스레드를 사용해 질의의 수행을 병렬로 진행하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_parallel" title="2.8.6. NO_PARALLEL???TITLE??????TITLE???">NO_PARALLEL</a></td><td>질의의 수행을 병렬로 진행하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#pq_distribute" title="2.8.6. PQ_DISTRIBUTE???TITLE??????TITLE???">PQ_DISTRIBUTE</a></td><td>조인을 포함한 질의의 병렬 처리에서 로우의 분산 방법을 지시한다.</td></tr><tr><td rowspan="4" valign="middle">실체화 뷰</td><td><a href="ch_sql_elements.html#rewrite" title="2.8.7. REWRITE???TITLE??????TITLE???">REWRITE</a></td><td>비용의 비교 없이 실체화 뷰(Materialized View)를 사용하여 질의의 다시 쓰기를
            지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_rewrite" title="2.8.7. NO_REWRITE???TITLE??????TITLE???">NO_REWRITE</a></td><td>질의의 다시 쓰기를 하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#materialize" title="2.8.7. MATERIALIZE???TITLE??????TITLE???">MATERIALIZE</a></td><td>With 절 안에 있는 Subquery를 실체화 뷰(Materialized View)로 만들도록
            지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#inline" title="2.8.7. INLINE???TITLE??????TITLE???">INLINE</a></td><td>With 절 안에 있는 Subquery를 실체화 뷰(Materialized View)로 만들지 않도록
            지시한다.</td></tr><tr><td rowspan="12" valign="middle">기타</td><td><a href="ch_sql_elements.html#append" title="2.8.8. APPEND???TITLE??????TITLE???">APPEND</a></td><td>DML 문장에서 직접 데이터 파일에 추가하는 삽입 방법 즉 Direct-Path 방식을 수행하도록
            지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#append_values" title="2.8.8. APPEND_VALUES???TITLE??????TITLE???">APPEND_VALUES</a></td><td>VALUES 절을 사용하는 INSERT 문에서 직접 데이터 파일에 추가하는 삽입 방법 즉
            Direct-Path 방식을 수행하도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#noappend" title="2.8.8. NOAPPEND???TITLE??????TITLE???">NOAPPEND</a></td><td>DML 문장에서 Direct-Path 방식을 수행하지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#ignore_row_on_dupkey_index" title="2.8.8. IGNORE_ROW_ON_DUPKEY_INDEX???TITLE??????TITLE???">IGNORE_ROW_ON_DUPKEY_INDEX</a></td><td>유일키 제약조건을 위배하는 로우가 삽입 될 때, 에러를 발생하지 않도록 한다.</td></tr><tr><td><a href="ch_sql_elements.html#card" title="2.8.8. CARD???TITLE??????TITLE???">CARD</a></td><td>지정 테이블의 Cardinality를 지정하여, 쿼리를 최적화 할때 이용하도록 한다.</td></tr><tr><td><a href="ch_sql_elements.html#monitor" title="2.8.8. MONITOR???TITLE??????TITLE???">MONITOR</a></td><td>쿼리를 수행할 때 쿼리 수행 정보를 모으도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_monitor" title="2.8.8. NO_MONITOR???TITLE??????TITLE???">NO_MONITOR</a></td><td>쿼리를 수행할 때 쿼리 수행 정보를 모으지 않도록 지시한다.</td></tr><tr><td><a href="ch_sql_elements.html#use_concat" title="2.8.8. USE_CONCAT???TITLE??????TITLE???">USE_CONCAT</a></td><td>OR expansion된 플랜만 생성한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_expand" title="2.8.8. NO_EXPAND???TITLE??????TITLE???">NO_EXPAND</a></td><td>OR expansion된 플랜을 배제한다.</td></tr><tr><td><a href="ch_sql_elements.html#result_cache" title="2.8.8. RESULT_CACHE???TITLE??????TITLE???">RESULT_CACHE</a></td><td>Query 결과를 저장하기 위해 Result Cache를 사용한다.</td></tr><tr><td><a href="ch_sql_elements.html#no_subquery_cache" title="2.8.8. NO_SUBQUERY_CACHE???TITLE??????TITLE???">NO_SUBQUERY_CACHE</a></td><td>쿼리를 수행하는 경우 특정 부질의에 대해 부질의 결과를 캐싱하지 않도록 강제한다.</td></tr><tr><td><a href="ch_sql_elements.html#opt_param" title="2.8.8. OPT_PARAM???TITLE??????TITLE???">OPT_PARAM</a></td><td>쿼리가 수행되는 동안 초기화 환경 변수를 바꾸는 데 사용한다.</td></tr></tbody></table>
    </div>

    <p/>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4978"/>2.8.1. 질의 변형</h3></div></div></div>
      

      <p>질의 변형(Query Transformation)<a id="d5e4981" class="indexterm"/>에 대한 힌트를 사용하여 <span>Tibero</span>의 질의 변형 방식에 영향을 줄 수
      있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="no_query_transformation"/>NO_QUERY_TRANSFORMATION</h4>

      <p><a id="d5e4988" class="indexterm"/><a id="d5e4991" class="indexterm"/>NO_QUERY_TRANSFORMATION는 질의 변형기(Query Transformer)가 전체 쿼리에
      대해 변형을 실행하지 않도록 지시하는 힌트이다. <span>Tibero</span>에서는 쿼리 변형이 자동으로 수행되며, 최적화된
      형태로 쿼리를 변형하여 실행계획을 생성하다. NO_QUERY_TRANSFORMATION 힌트를 사용한다면 디폴트로 수행되는 쿼리
      변형을 막을 수 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p><div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/no_query_transformation_hint.png"/></div>
            </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_merge"/>NO_MERGE</h4>

      <p><a id="d5e5006" class="indexterm"/><a id="d5e5009" class="indexterm"/>NO_MERGE는 질의 변형기(Query Transformer)가 특정 뷰에 대해 뷰 병합을 하지 않도록
      지시하는 힌트이다. <span>Tibero</span>에서는 뷰
      병합이 디폴트로 수행되며, 뷰가 병합이 가능할 경우 상위의 질의 블록과 결합해 하나의 질의 블록을 형성한다. NO_MERGE
      힌트를 사용하면 이렇게 디폴트로 수행되는 뷰의 병합을 막을 수 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p><div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/no_merge_hint.png"/></div>
            </div>
        </li><li>
          <p>예제</p>

          <p>다음은 NO_MERGE 힌트를 사용하는 예이다.</p>

          <pre class="programlisting">SELECT *
FROM T1, (SELECT /*+ NO_MERGE */ * FROM T2, T3 WHERE T2.A = T3.B) V
WHERE T1.C = V.D</pre>

          <p>위의 예에서처럼 NO_MERGE 힌트는 병합되기를 원하지 않는 뷰의 질의 블록에 명시한다. 힌트가 없었다면 뷰가
          병합되어 질의 최적화기에서 테이블 T1, T2, T3에 대한 조인 순서와 조인 방법을 고려하게 되지만, 위와 같이 힌트가
          있을 경우는 뷰가 병합되지 못하기 때문에 T2와 T3가 먼저 조인되고, 그 이후에 T1이 조인된다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="unnest"/>UNNEST</h4>

      <p><a id="d5e5029" class="indexterm"/><a id="d5e5032" class="indexterm"/>UNNEST는 질의 변형기가 특정 부질의(Subquery)를 언네스팅하도록 지시하는 힌트이다.
      <span>Tibero</span>는 부질의
      언네스팅을 디폴트로 수행하지만, 특정 쿼리만 언네스팅을 하려면 초기화 파라미터에서 언네스팅을 해제하면 된다. 그러면 UNNEST
      힌트를 이용할 수 있다. UNNEST 힌트는 부질의 블록에 명시한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/unnest_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_unnest"/>NO_UNNEST</h4>

      <p><a id="d5e5047" class="indexterm"/><a id="d5e5050" class="indexterm"/>NO_UNNEST는 질의 변형기가 특정 부질의에 대해 언네스팅을 수행하지 않도록 지시하는 힌트이다.
      <span>Tibero</span>는 부질의
      언네스팅을 디폴트로 수행하며 언네스팅이 가능한 경우 부질의를 조인으로 변환한다. 이때 NO_UNNEST 힌트를 사용해서 언네스팅을
      막을 수 있다. NO_UNNEST 힌트는 부질의 블록에 명시한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_unnest_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="no_join_elimination"/>NO_JOIN_ELIMINATION</h4>

      <p><a id="d5e5065" class="indexterm"/><a id="d5e5068" class="indexterm"/>NO_JOIN_ELIMINATION는 질의 변형기(Query Transformer)가 불필요한 조인을
      찾아서 제거하지 않도록 지시하는 힌트이다. Tibero에서는 디폴트로 질의 결과를 생성하는데 필요하지
      않은 조인들을 찾아서 제거하며, NO_JOIN_ELIMINATION 힌트를 사용하면 이를 막을 수 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p><div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/no_join_elimination_hint.png"/></div>
            </div>
        </li><li>
          <p>예제</p>

          <p>다음은 NO_JOIN_ELIMINATION 힌트를 사용하는 예이다.</p>

          <pre class="programlisting">SELECT /*+ NO_JOIN_ELIMINATION */ T2.FK, T2.A FROM T1, T2 WHERE T2.FK = T1.PK</pre>

          <p>위의 예처럼 T2의 컬럼을 요청하였을 때 T1과 T2 사이에 참조 관계가 정의되어 있다면 T1과 조인을 하지
          않아도 조건절에 주어진 T2.FK = T1.PK는 T2.FK가 NULL이 아닌 한 참임을 알 수 있다. 질의 변환기는
          이처럼 필요하지 않은 조인을 찾아 제거하는데 NO_JOIN_ELIMINATION 힌트를 적용하면 이러한 기능을 막을 수
          있다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="star_transformation"/>STAR_TRANSFORMATION</h4>

      <p><a id="d5e5087" class="indexterm"/><a id="d5e5090" class="indexterm"/>STAR_TRANSFORMATION는 스타 변형 (STAR TRANSFORMATION)이 가능할 경우
      변형을 시도하도록 지시하는 힌트이다. Tibero에서는 디폴트로 스타 변형을 하지않도록 하는데,
      STAR_TRANSFORMATION 힌트를 사용하면 이를 사용할 수 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p><div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/star_transformation_hint.png"/></div>
            </div>
        </li><li>
          <p>예제</p>

          <p>다음은 STAR_TRANSFORMATION 힌트를 사용하는 예이다.</p>

          <pre class="programlisting">SELECT /*+ STAR_TRANSFORMATION */ s.* FROM S, T1, T2
              WHERE S.C1 = T1.C1 AND S.C2 = T2.C2</pre>

          <p>스타 스키마(STAR SCHEMA)를 사용하는 데이터베이스 환경에서 위의 예처럼 쿼리를 쓰면 스타 변형을 할 수
          있다. 이 변형은 기존 INDEX JOIN으로만 풀린 플랜에서 BITMAP KEY ITERATION을 포함한 플랜으로
          풀리게 하여 더 효율적인 결과를 얻게 한다.</p>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e5106"/>2.8.2. 최적화 방법</h3></div></div></div>
      

      <p>최적화 방법이 적용된 힌트<a id="d5e5109" class="indexterm"/>를 사용하여 처리 과정과 결과 표시를 최적화할 수 있다. 만약 최적화 방법이 적용된 힌트가 사용된 질의가
      있다면 해당 질의에 대해서는 통계 정보와 초기화 파라미터의 최적화 방법(OPTIMIZER MODE)의 값이 없는 것처럼
      처리된다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="all_rows"/>ALL_ROWS</h4>

      <p><a id="d5e5115" class="indexterm"/><a id="d5e5118" class="indexterm"/>ALL_ROWS는 최소한의 리소스를 사용하여 전체 결과에 대한 처리량이 가장 많도록 처리과정의 최적화
      방법을 선택하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/all_rows_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="first_rows"/>FIRST_ROWS</h4>

      <p><a id="d5e5132" class="indexterm"/><a id="d5e5135" class="indexterm"/>FIRST_ROWS는 첫 로우부터 파라미터로 입력된 번호의 로우까지 가장 빠르게 보여줄 수 있도록 결과
      표시의 최적화 방법을 선택하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/first_rows_hint.png"/></div>
          </div>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e5146"/>2.8.3. 접근 방법</h3></div></div></div>
      

      <p><a id="d5e5149" class="indexterm"/>접근 방법이 적용된 힌트는 질의 최적화기가 특정 접근 방법의 사용이 가능한 경우, 그 방법을 사용하도록
      명시한다. 만일 힌트에서 명시한 방법을 사용할 수 없는 경우에는 질의 최적화기는 그 힌트를 무시한다.</p>

      <p>힌트에 명시하는 테이블명은 SQL 문에서 사용하는 이름과 동일해야 한다. 즉, 테이블 이름에 대한 별칭을 사용하였다면,
      테이블 이름 대신에 별칭을 사용하여야 한다. SQL 문에서 테이블 이름에 스키마 이름을 포함하여 명시하였더라도 힌트에서는 테이블
      이름만을 명시하여야 한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="full"/>FULL</h4>

      <p><a id="d5e5156" class="indexterm"/><a id="d5e5159" class="indexterm"/>FULL은 명시한 테이블을 스캔할 때, 전체 테이블을 스캔하도록 지시하는 힌트이다. WHERE 절에
      명시된 조건식에 맞는 인덱스가 있더라도 전체 테이블 스캔을 사용한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/full_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="index"/>INDEX</h4>

      <p><a id="d5e5173" class="indexterm"/><a id="d5e5176" class="indexterm"/>INDEX는 명시한 테이블을 스캔할 때, 명시한 인덱스를 사용하여 인덱스 스캔을 하도록 지시하는
      힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/index_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_index"/>NO_INDEX</h4>

      <p><a id="d5e5190" class="indexterm"/><a id="d5e5193" class="indexterm"/>NO_INDEX는 명시한 테이블을 스캔할 때, 명시한 인덱스를 사용하는 인덱스 스캔을 하지 않도록
      지시하는 힌트이다. 만일 NO_INDEX 힌트와 INDEX 또는 INDEX_ASC, INDEX_DESC 힌트가 동일한 인덱스를
      명시한다면 질의 최적화기는 이 두 힌트를 모두 무시한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_index_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="index_asc"/>INDEX_ASC</h4>

      <p><a id="d5e5207" class="indexterm"/><a id="d5e5210" class="indexterm"/>INDEX_ASC는 명시한 테이블을 스캔할 때, 명시한 인덱스를 사용하여 인덱스 스캔을 하도록 지시하는
      힌트이다. 만일 인덱스 범위 스캔을 사용하는 경우에는 인덱스를 오름차순으로 스캔하도록 한다. 현재 <span>Tibero</span>의 인덱스 스캔의 기본 동작이 오름차순이기 때문에
      INDEX_ASC는 INDEX와 동일한 작업을 수행한다. 분할된 인덱스의 경우 분할된 각 영역 내에서 오름차순으로
      스캔한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/index_asc_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="index_desc"/>INDEX_DESC</h4>

      <p><a id="d5e5225" class="indexterm"/><a id="d5e5228" class="indexterm"/>INDEX_DESC는 명시한 테이블을 스캔할 때, 명시한 인덱스를 사용하여 인덱스 스캔을 하도록 지시하는
      힌트이다. 만일 인덱스 범위 스캔을 사용하는 경우에는 인덱스를 내림차순으로 스캔하도록 한다. 분할된 인덱스의 경우 분할된 각 영역
      내에서 내림차순으로 스캔한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/index_desc_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="index_ffs"/>INDEX_FFS</h4>

      <p><a id="d5e5242" class="indexterm"/><a id="d5e5245" class="indexterm"/>INDEX_FFS는 명시한 테이블에 대해 명시한 인덱스를 사용하여 빠른 전체 인덱스 스캔(Fast
      Full Index Scan)을 사용하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/index_ffs_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_index_ffs"/>NO_INDEX_FFS</h4>

      <p><a id="d5e5259" class="indexterm"/><a id="d5e5262" class="indexterm"/>NO_INDEX_FFS는 명시한 테이블에 대해 명시한 인덱스를 사용하는 빠른 전체 인덱스 스캔을 사용하지
      않도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_index_ffs_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="index_rs"/>INDEX_RS<a id="d5e5275" class="indexterm"/><a id="d5e5278" class="indexterm"/></h4>

      <p>INDEX_RS는 명시한 테이블에 대해 명시한 인덱스를 사용하여 범위 인덱스 스캔(Range Index Scan)을
      사용하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/index_rs_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="no_index_rs"/>NO_INDEX_RS<a id="d5e5292" class="indexterm"/><a id="d5e5295" class="indexterm"/></h4>

      <p>NO_INDEX_RS는 명시한 테이블에 대해 명시한 인덱스를 사용하는 범위 인덱스 스캔을 사용하지 않도록 지시하는
      힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_index_rs_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="index_ss"/>INDEX_SS<a id="d5e5309" class="indexterm"/><a id="d5e5312" class="indexterm"/></h4>

      <p>INDEX_SS는 명시한 테이블에 대해 명시한 인덱스를 사용하여 인덱스 스킵 스캔(Index Skip Scan)을
      사용하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/index_ss_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_index_ss"/>NO_INDEX_SS<a id="d5e5326" class="indexterm"/><a id="d5e5329" class="indexterm"/></h4>

      <p>NO_INDEX_SS는 명시한 테이블에 대해 명시한 인덱스를 사용하는 인덱스 스킵 스캔을 사용하지 않도록 지시하는
      힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_index_ss_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="index_join"/>INDEX_JOIN<a id="d5e5343" class="indexterm"/><a id="d5e5346" class="indexterm"/></h4>

      <p>INDEX_JOIN은 명시한 테이블에 대해 명시한 두 개 이상의 힌트를 사용하여, 테이블을 스캔할 때 자체
      조인(Self Join)을 사용하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/index_join_hint.png"/></div>
          </div>
        </li></ul></div>

      <p/>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e5362"/>2.8.4. 조인 순서</h3></div></div></div>
      

      <p>LEADING, ORDERED는 조인 순서<a id="d5e5365" class="indexterm"/>를 결정하는 힌트이다. LEADING 힌트가 ORDERED보다 질의 최적화기를 선택할 수 있는 폭이
      넓어서 LEADING을 사용하는 것이 좋다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="leading"/>LEADING<a id="d5e5370" class="indexterm"/><a id="d5e5373" class="indexterm"/></h4>

      <p>LEADING은 조인에서 먼저 조인되어야 할 테이블의 집합을 명시하는 힌트이다. LEADING 힌트가 먼저 조인될 수
      없는 테이블을 포함하는 경우 무시된다. 또, LEADING 힌트끼리 충돌하는 경우에는 LEADING, ORDERED 힌트가 모두
      무시된다. 만일 ORDERED 힌트가 사용되는 경우에는 LEADING 힌트는 모두 무시된다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/leading_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="ordered"/>ORDERED<a id="d5e5387" class="indexterm"/><a id="d5e5390" class="indexterm"/></h4>

      <p>ORDERED는 테이블을 FROM 절에 명시된 순서대로 조인하도록 지시하는 힌트이다. 질의 최적화기는 조인의 결과
      집합의 크기에 대한 정보를 추가로 알고 있다. 사용자가 그 정보를 통해 질의 최적화기의 조인 순서를 명확히 알고 있을 경우에만
      ORDERED 힌트를 사용하는 것이 좋다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/ordered_hint.png"/></div>
          </div>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e5402"/>2.8.5. 조인 방법</h3></div></div></div>
      

      <p><a id="d5e5405" class="indexterm"/>조인 방법이 적용된 힌트는 한 테이블에 대해서만 조인 방법을 지시한다. 조인 방법이 적용된 힌트는 명시한
      테이블이 조인의 내부 테이블로 사용될 경우에만 참조된다. 명시한 테이블을 외부 테이블로 사용하는 경우에는 조인 방법이 적용된
      힌트는 무시된다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="use_nl"/>USE_NL<a id="d5e5411" class="indexterm"/><a id="d5e5414" class="indexterm"/></h4>

      <p>USE_NL은 명시한 테이블을 다른 테이블과 조인하는 경우 중첩 루프 조인을 사용하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/use_nl_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_use_nl"/>NO_USE_NL<a id="d5e5428" class="indexterm"/><a id="d5e5431" class="indexterm"/></h4>

      <p>NO_USE_NL은 명시한 테이블을 다른 테이블과 조인하는 경우 중첩 루프 조인을 사용하지 않도록 지시하는 힌트이다.
      하지만, 특수한 경우에는 이 힌트가 주어졌더라도 질의 최적화기에서 중첩 루프 조인을 사용하는 플랜을 생성할 수 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p><div class="informalfigure">
              <div xmlns="" class="mediaobject"><img src="resources/no_use_nl_hint.png"/></div>
            </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="use_nl_with_index"/>USE_NL_WITH_INDEX<a id="d5e5445" class="indexterm"/><a id="d5e5448" class="indexterm"/></h4>

      <p>USE_NL_WITH_INDEX는 명시한 테이블을 다른 테이블과 조인하는 경우 중첩 루프 조인을 사용하도록 지시하는
      힌트이다. 이때 명시한 테이블에 대한 접근은 명시한 인덱스와 두 테이블에 대한 조인 조건을 이용하여 이루어져야 한다. 만일
      인덱스를 사용할 수 없는 경우이면 힌트는 무시된다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/use_nl_with_index_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="use_merge"/>USE_MERGE<a id="d5e5462" class="indexterm"/><a id="d5e5465" class="indexterm"/></h4>

      <p>USE_MERGE는 명시한 테이블을 다른 테이블과 조인하는 경우 합병 조인을 사용하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/use_merge_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="no_use_merge"/>NO_USE_MERGE<a id="d5e5479" class="indexterm"/><a id="d5e5482" class="indexterm"/></h4>

      <p>NO_USE_MERGE는 명시한 테이블을 다른 테이블과 조인하는 경우 합병 조인을 사용하지 않도록 지시하는
      힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_use_merge_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="use_hash"/>USE_HASH<a id="d5e5496" class="indexterm"/><a id="d5e5499" class="indexterm"/></h4>

      <p>USE_HASH는 명시한 테이블을 다른 테이블과 조인하는 경우 해시 조인을 사용하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/use_hash_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_use_hash"/>NO_USE_HASH<a id="d5e5513" class="indexterm"/><a id="d5e5516" class="indexterm"/></h4>

      <p>NO_USE_HASH는 명시한 테이블을 다른 테이블과 조인하는 경우 해시 조인을 사용하지 않도록 지시하는
      힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_use_hash_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="hash_sj"/>HASH_SJ<a id="d5e5530" class="indexterm"/><a id="d5e5533" class="indexterm"/></h4>

      <p>HASH_SJ는 부질의를 언네스팅할 때 해시방법을 이용한 세미조인으로 하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/hash_sj_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="hash_aj"/>HASH_AJ<a id="d5e5547" class="indexterm"/><a id="d5e5550" class="indexterm"/></h4>

      <p>HASH_AJ는 부질의를 언네스팅할 때 해시방법을 이용한 안티조인으로 하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/hash_aj_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="merge_sj"/>MERGE_SJ<a id="d5e5564" class="indexterm"/><a id="d5e5567" class="indexterm"/></h4>

      <p>MERGE_SJ는 부질의를 언네스팅할 때 머지방법을 이용한 세미조인으로 하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/merge_sj_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="merge_aj"/>MERGE_AJ<a id="d5e5581" class="indexterm"/><a id="d5e5584" class="indexterm"/></h4>

      <p>MERGE_AJ는 부질의를 언네스팅할 때 머지방법을 이용한 안티조인으로 하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/merge_aj_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="nl_sj"/>NL_SJ<a id="d5e5598" class="indexterm"/><a id="d5e5601" class="indexterm"/></h4>

      <p>NL_SJ는 부질의를 언네스팅할 때 네스티드 루프 방법을 이용한 세미조인으로 하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/nl_sj_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="nl_aj"/>NL_AJ<a id="d5e5615" class="indexterm"/><a id="d5e5618" class="indexterm"/></h4>

      <p>NL_AJ는 부질의를 언네스팅할 때 네스티드 루프 방법을 이용한 안티조인으로 하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/nl_aj_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="swap_join_inputs"/>SWAP_JOIN_INPUTS<a id="d5e5632" class="indexterm"/><a id="d5e5635" class="indexterm"/></h4>

      <p>SWAP_JOIN_INPUTS는 해시 조인을 수행하는 경우 명시한 테이블을 사용하여 해시 테이블을 빌드하도록 지시하는
      힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/swap_join_inputs_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_swap_join_inputs"/>NO_SWAP_JOIN_INPUTS<a id="d5e5649" class="indexterm"/><a id="d5e5652" class="indexterm"/></h4>

      <p>NO_SWAP_JOIN_INPUTS는 해시 조인을 수행하는 경우 조인 순서가 바뀌는 경우, 명시한 테이블이 해시
      테이블로 빌드되지 않도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_swap_join_inputs_hint.png"/></div>
          </div>
        </li></ul></div>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e5667"/>2.8.6. 병렬 처리</h3></div></div></div>
      

      <h4><a id="parallel"/>PARALLEL<a id="d5e5670" class="indexterm"/><a id="d5e5673" class="indexterm"/></h4>

      <p>PARALLEL은 지정한 개수의 스레드를 사용해 질의의 수행을 병렬로 진행하도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/parallel_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="no_parallel"/>NO_PARALLEL<a id="d5e5687" class="indexterm"/><a id="d5e5690" class="indexterm"/></h4>

      <p>NO_PARALLEL은 질의의 수행을 병렬로 진행하지 않도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_parallel_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="pq_distribute"/>PQ_DISTRIBUTE<a id="d5e5704" class="indexterm"/><a id="d5e5707" class="indexterm"/></h4>

      <p>PQ_DISTRIBUTE는 조인을 포함한 질의의 병렬 처리에서 조인될 로우의 분산 방법을 지시하는 힌트이다. 분산
      방법으로는 HASH-HASH, BROADCAST-NONE, NONE-BROADCAST, NONE-NONE이 있으며 특정한 분산
      방법을 선택함으로써 병렬 처리에서 조인의 성능을 향상시킬 수 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/pq_distribute_hint.png"/></div>
          </div>

          <p>다음은 각각의 속성에 대한 설명이다.</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">속성</th><th>설명</th></tr></thead><tbody><tr><td align="left">NONE NONE</td><td>힌트가 없을 때와 같은 플랜이 생성된다.</td></tr><tr><td align="left">BROADCAST NONE</td><td>조인의 왼쪽은 BROADCAST, 오른쪽은 PE BLOCK ITERATOR의 분산 방법으로
                  동작한다.</td></tr><tr><td align="left">NONE BROADCAST</td><td>조인의 왼쪽은 PE BLOCK ITERATOR, 오른쪽은 BROADCAST의 분산 방법으로
                  동작한다.</td></tr><tr><td align="left">HASH HASH</td><td>조인의 왼쪽, 오른쪽 모두 HASH의 분산 방법으로 동작한다.</td></tr></tbody></table>
          </div>
        </li></ul></div>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e5742"/>2.8.7. 실체화 뷰</h3></div></div></div>
      

      <h4><a id="rewrite"/>REWRITE<a id="d5e5745" class="indexterm"/><a id="d5e5748" class="indexterm"/></h4>

      <p>REWRITE는 해당 질의 블록에서 비용의 비교 없이 실체화 뷰를 사용하여 질의의 다시 쓰기를 하도록 지시하는
      힌트이다. 따라서 최종으로는 REWRITE 힌트가 사용된 질의 블록만 다시 쓰기를 한 결과와 모든 블록에서 다시 쓰기를 한 결과의
      비용을 비교해서 더 좋은 쪽을 질의 최적화기가 선택하게 된다.</p>

      <p>실체화 뷰의 목록이 명시된 경우에는 목록에 있는 실체화 뷰만 사용하여 질의의 다시 쓰기를 시도한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/rewrite_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="no_rewrite"/>NO_REWRITE<a id="d5e5763" class="indexterm"/><a id="d5e5766" class="indexterm"/></h4>

      <p>NO_REWRITE는 해당 질의 블록에서는 질의의 다시 쓰기를 하지 않도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_rewrite_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="materialize"/>MATERIALIZE<a id="d5e5780" class="indexterm"/><a id="d5e5783" class="indexterm"/></h4>

      <p>MATERIALIZE는 With 절 안에 있는 Subquery를 실체화 뷰(Materialized View)로 만들도록
      지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/materialize_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="inline"/>INLINE<a id="d5e5797" class="indexterm"/><a id="d5e5800" class="indexterm"/></h4>

      <p>INLINE은 With 절 안에 있는 Subquery를 실체화 뷰(Materialized View)로 만들지 않도록
      지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/inline_hint.png"/></div>
          </div>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e5812"/>2.8.8. 기타</h3></div></div></div>
      

      <h4><a id="append"/>APPEND<a id="d5e5815" class="indexterm"/><a id="d5e5818" class="indexterm"/></h4>

      <p>APPEND는 DML 문장에서 직접 데이터 파일에 추가하는 삽입 방법 즉 Direct-Path 방식<a id="d5e5821" class="indexterm"/>을 수행하도록 지시하는 힌트이다.</p>

      <p>Direct-Path 방식은 일반적인 삽입 방법과 달리 항상 새로운 데이터 블록을 할당받아서 데이터 삽입을 수행하며,
      버퍼 캐시를 이용하지 않고 직접 데이터 파일을 추가하기 때문에 성능 향상에 많은 이점이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/append_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="append_values"/>APPEND_VALUES<a id="d5e5835" class="indexterm"/><a id="d5e5838" class="indexterm"/></h4>

      <p>APPEND_VALUES는 VALUES절을 사용하는 INSERT 문에서 직접 데이터 파일에 추가하는 삽입 방법 즉
      Direct-Path 방식<a id="d5e5841" class="indexterm"/>을 수행하도록 지시하는 힌트이다.</p>

      <p>Direct-Path 방식은 일반적인 삽입 방법과 달리 항상 새로운 데이터 블록을 할당받아서 데이터 삽입을 수행하며,
      버퍼 캐시를 이용하지 않고 직접 데이터 파일을 추가하므로 일괄 삽입에 사용하면 성능 향상에 많은 이점이 있다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/append_values_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="noappend"/>NOAPPEND<a id="d5e5855" class="indexterm"/><a id="d5e5858" class="indexterm"/></h4>

      <p>NOAPPEND는 DML 문장에서 Direct-Path 방식을 수행하지 않도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/noappend_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="ignore_row_on_dupkey_index"/>IGNORE_ROW_ON_DUPKEY_INDEX<a id="d5e5872" class="indexterm"/><a id="d5e5875" class="indexterm"/></h4>

      <p>single table INSERT문에서만 사용이 가능하다. 유일키 제약조건을 위배하면 에러를 발생시키지 않고 삽입하던
      로우를 롤백하고 다음 로우부터 삽입을 재개한다.</p>

      <p>인덱스를 명시하지 않은 경우, 여러 개의 인덱스를 명시한 경우, 명시된 인덱스가 UNIQUE 속성을 갖지 않는 경우에는
      힌트이지만 에러를 발생시킨다. 이 힌트를 명시하면 APPEND, PARALLEL 힌트는 무시된다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="resources/ignore_row_on_dupkey_index_hint.png" height="231.00000000000003"/></td></tr></table></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="card"/>CARD<a id="d5e5890" class="indexterm"/><a id="d5e5893" class="indexterm"/></h4>

      <p>CARD는 쿼리 최적화 할 때에 지정 테이블의 Cardinality를 주어진 값을 이용하여 계산하도록 지시하는
      힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/card_hint.png"/></div>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="monitor"/>MONITOR<a id="d5e5907" class="indexterm"/><a id="d5e5910" class="indexterm"/></h4>

      <p>MONITOR는 쿼리를 수행할 때 쿼리 수행 정보를 모으도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/monitor_hint.png"/></div>
          </div>
        </li></ul></div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="no_monitor"/>NO_MONITOR<a id="d5e5926" class="indexterm"/><a id="d5e5929" class="indexterm"/></h4>

      <p>NO_MONITOR는 쿼리를 수행할 때 쿼리 수행 정보를 모으지 않도록 지시하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_monitor_hint.png"/></div>
          </div>
        </li></ul></div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="use_concat"/>USE_CONCAT<a id="d5e5945" class="indexterm"/><a id="d5e5948" class="indexterm"/></h4>

      <p>USE_CONCAT은 OR 조건문을 UNION ALL로 쪼개어 OR 양쪽에 대하여 별도의 플랜 노드를 만들어 합치는
      OR expansion된 플랜이 만들어지도록 강제하는 힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/use_concat_hint.png"/></div>
          </div>
        </li></ul></div>

      <p/>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="no_expand"/>NO_EXPAND<a id="d5e5965" class="indexterm"/><a id="d5e5968" class="indexterm"/></h4>

      <p>NO_EXPAND는 OR expansion을 막음으로써 OR 조건문이 필터로 보존된 플랜을 만들도록 강제하는
      힌트이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_expand_hint.png"/></div>
          </div>
        </li></ul></div>

      <p/>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="result_cache"/>RESULT_CACHE<a id="d5e5985" class="indexterm"/><a id="d5e5988" class="indexterm"/></h4>

      <p>Query 결과를 Cache에 저장하기 위한 Result Cache를 사용하도록 지시하는 힌트이다.
      RESULT_CACHE_MODE 초기 파라미터 값이 "MANUAL"일 때만 유효하며, "FORCE"일 때는 힌트의 존재 여부와
      관계없이 모든 Query 결과를 Result Cache에 저장한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/result_cache_hint.png"/></div>
          </div>
        </li></ul></div>

      <p/>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="no_subquery_cache"/>NO_SUBQUERY_CACHE<a id="d5e6005" class="indexterm"/><a id="d5e6008" class="indexterm"/></h4>

      <p>NO_SUBQUERY_CACHE는 특정 질의 블록에 대해 부질의 결과를 캐싱하지 않도록 강제하는 힌트이다.
      Tibero는 가능하다면 부질의 결과 캐싱 기능을 사용하는 실행 계획을 수립한다. 이때 이 힌트를 사용하여
      특정 질의 블록에 대해 부질의 결과 캐싱을 강제로 막을 수 있다. NO_SUBQUERY_CACHE 힌트는 대상 질의 블록에
      명시하며, 부질의의 실행 계획 최상위 노드로서 CACHE가 생기지 않는다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/no_subquery_cache_hint.png"/></div>
          </div>
        </li><li>
          <p>예제</p>

          <p>다음은 NO_SUBQUERY_CACHE 힌트를 사용하는 예이다.</p>

          <pre class="programlisting">SELECT * FROM T1
WHERE EXISTS (SELECT /*+ NO_SUBQUERY_CACHE */ * FROM T2 WHERE T1.A = T2.A)</pre>

          <p>위에 예처럼 EXISTS절 질의 블록에 힌트를 명시할 경우, 해당 블록에 대해 부질의 결과를 캐싱하는 기능을
          사용하지 않도록 강제한다.</p>
        </li></ul></div>

      <p/>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="opt_param"/>OPT_PARAM<a id="d5e6030" class="indexterm"/><a id="d5e6033" class="indexterm"/></h4>

      <p>쿼리가 수행되는 도중 초기화 환경변수를 바꿔서 수행하는 힌트이다. 예를 들어 수행되는 쿼리에
      /*+OPT_PARAM(OPTIMIZER_MODE FIRST_ROWS_1)*/ 이라는 힌트를 준다면, 해당 쿼리가 수행되는 동안에
      한해서 OPTIMIZER_MODE가 FIRST_ROWS_1로 설정되어 수행된다.</p>

      <div class="itemizedlist"><ul type="disc"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/opt_param_hint.png"/></div>
          </div>
        </li></ul></div>

      <p/>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e6048"/>2.9. 스키마 객체</h2></div></div></div>
    

    <p>데이터베이스는 여러 객체로 구성된다. 각 객체는 <span><strong class="guibutton">'데이터베이스 &gt; 사용자 &gt; 스키마 &gt;
    스키마 객체'</strong></span>의 순으로 포함 관계를 갖는다. 하나의 데이터베이스는 여러 <a id="d5e6052" class="indexterm"/>사용자가 공유하고 있다. 또한 사용자 중에는 데이터베이스를 관리하기 위해 특별한 권한을 부여 받고 있는
    DBA가 있다.</p>

    <p><a id="d5e6055" class="indexterm"/>스키마는 사용자가 소유한 객체의 모임(Collection)이다. <span>Tibero</span>에서는 한 사용자가 하나의 스키마만을 정의할 수 있고,
    스키마의 이름은 항상 사용자의 이름과 동일하다. 이러한 스키마에 포함된 객체를 <a id="d5e6058" class="indexterm"/><span><strong class="guibutton">스키마 객체</strong></span>라 한다. SQL 표준에서 정의한 스키마 객체 외에,
    데이터베이스 시스템에 따라 추가적인 스키마 객체를 제공하고 있다.</p>

    <p><span>Tibero</span>에서 제공하는
    스키마 객체는 다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>테이블(Table)</p>
      </li><li>
        <p>인덱스(Index)</p>
      </li><li>
        <p>뷰(View)</p>
      </li><li>
        <p>시퀀스(Sequence)</p>
      </li><li>
        <p>동의어(Synonym)</p>
      </li></ul></div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6074"/>2.9.1. 테이블</h3></div></div></div>
      

      <p>테이블<a id="d5e6077" class="indexterm"/>은 관계형 데이터베이스의 기본 저장 단위이다. 다른 모든 스키마 객체는 테이블을 중심으로 정의된다.
      테이블은 2차원 행렬(Matrix)의 형태를 갖는다. 테이블은 하나 이상의 <a id="d5e6079" class="indexterm"/>컬럼으로 구성되며 각 컬럼은 고유의 데이터 타입을 갖는다. 하나의 테이블은 0개 이상의
      <a id="d5e6081" class="indexterm"/>로우를 포함한다. 각 로우는 각 컬럼에 해당하는 값을 갖는다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>테이블을 생성하고 변경, 제거하기 위한 SQL 문장은 각각 <a href="ch_ddl.html#sect_ddl_CREATE_TABLE" title="7.41. CREATE TABLE">CREATE TABLE</a>, <a href="ch_ddl.html#sect_ddl_ALTER_TABLE" title="7.15. ALTER TABLE">ALTER TABLE</a>, <a href="ch_ddl.html#sect_ddl_DROP_TABLE" title="7.62. DROP TABLE">DROP TABLE</a>이다. 이러한 문장은 DDL에 포함되며,
        자세한 설명은 <a href="ch_ddl.html" title="제7장 데이터 정의어">“제7장 데이터 정의어”</a>를 참고한다.</p>
      </div>

      

      <div class="literallayout"><p/></div>

      <p>다음은 회사 직원의 정보를 저장하고 있는 EMP 테이블의 예이다.</p>

      <div class="example"><a id="ex_emp_table"/><p class="title"><b>[예 2.1] EMP 테이블</b></p><div class="example-contents">
        

        

        <pre class="programlisting">     EMPNO ENAME        ADDR                 SALARY     DEPTNO
---------- ------------ ---------------- ---------- ----------
        35 John         Houston               30000          5
        54 Alicia       Castle                25000          4
        27 Ramesh       Humble                38000          5
        69 James        Houston               35000          4</pre>
      </div></div><br class="example-break"/>

      <p>위의 테이블은 'EMPNO, ENAME, ADDR, SALARY, DEPTNO'의 다섯 개의 컬럼으로 구성되며, 네
      개의 로우를 포함하고 있다. 테이블을 구성하는 컬럼 정보는 거의 변경되지 않으나, 테이블에 포함된 로우의 개수는 수시로 변경될 수
      있다.</p>

      <p>컬럼의 데이터 타입 중에는 문자형과 같이 최대 길이를 미리 정해야 하는 것도 있고, NUMBER 타입과 같이 정밀도와
      스케일을 정해야 하는 것도 있다. 일부 컬럼에 대해서는 기본값을 선언할 수도 있다. 데이터 타입에 대해서는 <a href="ch_sql_elements.html#sect_data_type" title="2.1. 데이터 타입">“2.1. 데이터 타입”</a>에서 자세하게
      설명한다.</p><div class="literallayout"><p/></div><p>테이블 전체 또는 일부 컬럼에 <a id="d5e6098" class="indexterm"/><a id="d5e6100" class="indexterm"/>무결성 제약조건(Integrity Constraints)을 선언할 수 있다. 무결성 제약 조건은 테이블에
      어떠한 로우가 삽입되든 항상 만족되어야 한다. 예를 들어 테이블 EMP의 한 컬럼 SALARY에 대하여 다음과 같은 조건을 선언할
      수 있다.</p>

      <pre class="programlisting">SALARY &gt;= 0</pre>

      <p>직원의 연봉이 0보다 작을 수 없으므로, 이러한 조건을 사용해 잘못된 데이터의 입력을 미리 막을 수 있다. 무결성
      제약조건을 표현하기 위한 조건식(Condition Expression)은 <a href="ch_sql_expressions.html#sect_conditions" title="3.4. 조건식">“3.4. 조건식”</a>에서 설명한다.</p>

      <p>하나의 테이블에 무결성 제약조건을 선언할 수도 있고, 두 개의 테이블에 <a id="d5e6107" class="indexterm"/>참조 무결성(Referential Integrity) 제약조건을 선언할 수도 있다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 회사의 부서 정보를 저장하는 DEPT 테이블의 예이다.</p>

      <div class="example"><a id="ex_dept_table"/><p class="title"><b>[예 2.2] DEPT 테이블</b></p><div class="example-contents">
        

        

        <pre class="programlisting">    DEPTNO DNAME        LOC
---------- ------------ ----------------
         1 Accounting   Houston
         4 Research     Spring
         5 Sales        Houston</pre>
      </div></div><br class="example-break"/>

      <p>회사의 모든 직원이 하나의 특정 부서에 반드시 소속되어야 한다면, <a href="ch_sql_elements.html#ex_emp_table" title="[예 2.1] EMP 테이블">[예 2.1]</a>의 테이블 EMP의 컬럼 DEPTNO의 값은 반드시 <a href="ch_sql_elements.html#ex_dept_table" title="[예 2.2] DEPT 테이블">[예 2.2]</a>의 테이블 DEPT의 컬럼 DEPTNO에 존재하는 값이어야 한다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>무결성 제약조건에 대한 자세한 내용은 "<span>Tibero</span> 관리자 안내서"를 참고한다.</p>
      </div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6121"/>2.9.2. 인덱스</h3></div></div></div>
      

      <p><a id="d5e6124" class="indexterm"/>인덱스는 테이블과 별도의 저장공간을 이용하여 그 테이블의 특정 컬럼을 빠르게 검색 할 수 있도록 해주는
      데이터 구조이다. 테이블의 소유자는 어떤 컬럼에 대해 하나 이상의 인덱스를 생성할 수 있다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>인덱스를 생성하고 변경, 제거하기 위한 SQL 문장은 각각 <a href="ch_ddl.html#sect_ddl_CREATE_INDEX" title="7.30. CREATE INDEX">CREATE INDEX</a>, <a href="ch_ddl.html#sect_ddl_ALTER_INDEX" title="7.5. ALTER INDEX">ALTER INDEX</a>, <a href="ch_ddl.html#sect_ddl_DROP_INDEX" title="7.52. DROP INDEX">DROP INDEX</a>이다. 이러한 문장은 DDL에 포함되며,
        자세한 설명은 <a href="ch_ddl.html" title="제7장 데이터 정의어">“제7장 데이터 정의어”</a>를 참고한다.</p>
      </div>

      

      <div class="literallayout"><p/></div>

      <p>다음은 인덱스에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>자동 인덱싱</p>

          <p><span>Tibero</span>에서는 모든 테이블의 기본 키(Primary
          Key) 컬럼에 대해 자동으로 인덱스를 생성한다. <a id="d5e6139" class="indexterm"/><a id="d5e6141" class="indexterm"/>기본 키 컬럼이란 테이블 내의 특정 로우를 유일하게 식별할 수 있는 값을 갖는 컬럼을 의미한다.
          하나의 테이블 내에서 어떤 로우도 다른 로우와 동일한 기본 키 컬럼 값을 가질 수 없다. 위의 <a href="ch_sql_elements.html#ex_emp_table" title="[예 2.1] EMP 테이블">[예 2.1]</a>와 <a href="ch_sql_elements.html#ex_dept_table" title="[예 2.2] DEPT 테이블">[예 2.2]</a>에서는 각각 컬럼
          EMPNO와 DEPTNO가 기본 키 컬럼이 될 수 있다.</p>
        </li><li>
          <p>컬럼의 중복 허용</p>

          <p>인덱스는 컬럼 값의 중복 유무에 관계 없이 생성할 수 있다. 예를 들어 테이블 DEPT의 컬럼 DEPTNO와
          같이 중복이 없는 컬럼이나 테이블 EMP의 컬럼 DEPTNO와 같이 중복이 있는 컬럼에 대해서도 인덱스를 생성할 수
          있다.</p>
        </li><li>
          <p>복수 컬럼 허용</p>

          <p>인덱스는 하나의 컬럼뿐만 아니라 <a id="d5e6152" class="indexterm"/>둘 이상의 컬럼 값을 하나로 접합하여 생성할 수도 있다. 예를 들어 테이블 EMP의 컬럼
          ENAME과 ADDR 값을 합쳐서 인덱스를 만들 수 있다. 이러한 인덱스는 둘 이상의 컬럼이 동시에 검색 대상이 될 확률이
          높은 경우에 유용하다.</p>
        </li><li>
          <p>인덱스의 적용</p>

          <p>사용자가 인덱스를 생성하더라도 바로 사용되지는 않는다. <a id="d5e6158" class="indexterm"/>인덱스가 생성되면 SQL 질의를 수행할 때, 질의 최적화기가 인덱스를 사용할 때와 사용하지 않을
          때의 실행 효율성을 비교하고, 더 효율적인 방향으로 실제 질의를 실행한다. 따라서, 질의 대상 테이블에 대해서 생성된
          인덱스를 이용할 것인지, 어떤 컬럼에 대해서 생성된 인덱스를 이용할 것인지는 데이터베이스 시스템에 의하여 자동적으로
          결정된다.</p>
        </li><li>
          <p>인덱스의 관리</p>

          <p><a id="d5e6164" class="indexterm"/>인덱스의 관리도 데이터베이스 시스템에서 자동적으로 이루어진다. 인덱스가 생성된 후에 테이블에
          하나의 로우가 삽입되거나 갱신, 삭제되면, 그 테이블에 대하여 생성된 모든 인덱스에서 그 로우에 대한 삽입, 갱신, 삭제가
          이루어진다.</p>
        </li><li>
          <p>인덱스의 제거</p>

          <p><a id="d5e6170" class="indexterm"/>인덱스가 더 이상 필요하지 않으면 언제라도 그 인덱스를 제거할 수 있다. 인덱스를 너무 많이
          생성해 놓으면 테이블에 대한 갱신이 이루어질 때마다 인덱스에도 함께 반영해 주어야 하므로 성능 저하의 원인이 될 수 있다.
          따라서, 불필요한 인덱스는 제거하는 것이 바람직하다.</p>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6173"/>2.9.3. 뷰</h3></div></div></div>
      

      <p><a id="d5e6176" class="indexterm"/>뷰는 SQL 문장에 이름을 붙인 것으로, 빈번히 수행되는 질의의 결과를 테이블 형태로 이용할 수 있도록
      정의한 것이다. 뷰는 테이블 또는 다른 뷰를 이용하여 정의할 수 있으며, SQL 문장 내에서 일반 테이블과 동일하게 이용할 수
      있다. 뷰가 정의된 테이블을 <a id="d5e6178" class="indexterm"/><a id="d5e6181" class="indexterm"/>기반 테이블(base table)이라 한다.</p>

      <p>뷰를 정의하는 이유는, 하나의 테이블을 여러 사용자가 함께 접근할 수 있지만 사용자에 따라 테이블 내용의 일부를
      숨김으로써 정보 보안을 유지하고자 하는 것이다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>뷰를 생성하고 제거하기 위한 SQL 문장은 <a href="ch_ddl.html#sect_ddl_CREATE_VIEW" title="7.47. CREATE VIEW">CREATE VIEW</a>, <a href="ch_ddl.html#sect_ddl_DROP_VIEW" title="7.68. DROP VIEW">DROP VIEW</a>이다. 이러한 문장은 DDL에 포함되며,
        자세한 설명은 <a href="ch_ddl.html" title="제7장 데이터 정의어">“제7장 데이터 정의어”</a>를 참고한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 뷰에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>뷰 병합</p>

          <p>데이터베이스 시스템 내에서 뷰는 질의 문장을 문자열 형태로 관리한다. 만약 뷰를 포함한 SQL 문장이 입력되면,
          데이터베이스 시스템은 그 문장을 뷰를 포함하지 않는 기반 테이블에 대한 SQL 문장으로 변환한다. 이러한 과정을 뷰
          병합이라고 한다.</p>
        </li><li>
          <p>뷰의 활용과 권한</p>

          <p><a id="d5e6198" class="indexterm"/>뷰가 이용되는 경우는 위에서와 같이 빈번한 질의를 단순화하고자 하는 경우 이외에, 뷰를 정의한
          기반 테이블의 일부만을 드러내고자 하는 경우에도 사용된다. 예를 들어 테이블 EMP의 내용 중에서 컬럼 SALARY의
          내용을 관리직이 아닌 일반 직원에게 드러내고 싶지 않은 경우에, 일반 직원이 테이블 EMP를 직접 접근하지 못하고 뷰를
          통해서만 접근하도록 할 수 있다.</p>

          <p><a id="d5e6202" class="indexterm"/>이러한 경우 스키마 객체를 접근할 수 있는 권한(Authority)과 연관이 된다. 즉, 뷰를
          정의한 사용자가 일반 직원에게 그 뷰를 접근할 권한만을 부여하고 뷰가 정의된 기반 테이블 EMP를 접근할 권한을 부여하지
          않으면, 일반 직원에게 테이블 EMP 내의 데이터 중에서 그 뷰에 의하여 볼 수 있는 일부만을 드러내는
          것이다.</p>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6205"/>2.9.4. 시퀀스</h3></div></div></div>
      

      <p><a id="d5e6208" class="indexterm"/>시퀀스는 유일한 연속적인 값을 생성해 낼 수 있는 스키마 객체이다. 이 값은 보통 <a id="d5e6210" class="indexterm"/>기본 키 또는 유일 키에 값을 채워 넣을 때 사용된다. 항상 시퀀스의 이름에는 의사 컬럼을 붙여서
      사용한다.</p>

      <p>SQL 문에서는 다음의 의사 컬럼을 통해 시퀀스의 값을 읽어 들인다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">컬럼</th><th>설명</th></tr></thead><tbody><tr><td align="left">CURRVAL</td><td>현재 세션에서 마지막으로 조회한 NEXTVAL 값을 반환한다.<a id="d5e6225" class="indexterm"/></td></tr><tr><td align="left">NEXTVAL</td><td>시퀀스의 현재 값을 증가시키고 증가된 그 값을 반환한다.<a id="d5e6230" class="indexterm"/></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 의사 컬럼과 함께 시퀀스를 사용하는 예이다.</p>

      <pre class="programlisting">seq1.currval
seq2.nextval</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 위치에 따른 시퀀스 의사 컬럼의 사용 여부<a id="d5e6237" class="indexterm"/>에 대해 설명한다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">사용 여부</th><th>위치</th></tr></thead><tbody><tr><td align="left">사용 가능</td><td><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>SELECT 리스트</p>
                  </li></ul></div><p>부질의 또는 뷰의 SELECT 리스트에서는 사용할 수
              없다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>INSERT 문의 부질의의 SELECT 리스트</p>
                  </li><li style="list-style-type: circle">
                    <p>INSERT 문의 VALUES 절</p>
                  </li><li style="list-style-type: circle">
                    <p>UPDATE 문의 SET 절</p>
                  </li></ul></div></td></tr><tr><td align="left">사용 불가능</td><td><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>SELECT, DELETE, UPDATE 문의 부질의의 내부</p>
                  </li><li style="list-style-type: circle">
                    <p>뷰의 내부</p>
                  </li><li style="list-style-type: circle">
                    <p>DISTINCT가 있는 SELECT 문</p>
                  </li><li style="list-style-type: circle">
                    <p>GROUP BY 절이나 ORDER BY 절이 있는 SELECT 문</p>
                  </li><li style="list-style-type: circle">
                    <p>집합 연산자(UNION, INTERSECT, MINUS)로 다른 SELECT 문과 연결된
                    SELECT 문</p>
                  </li><li style="list-style-type: circle">
                    <p>SELECT 문의 WHERE 절</p>
                  </li><li style="list-style-type: circle">
                    <p>CREATE TABLE 또는 ALTER TABLE을 실행할 때 컬럼의 DEFAULT
                    값</p>
                  </li><li style="list-style-type: circle">
                    <p>CHECK 제약 조건</p>
                  </li></ul></div></td></tr></tbody></table>
      </div>

      <p><a id="d5e6286" class="indexterm"/>시퀀스를 생성할 때 초기 값과 증감치가 결정된다. NEXTVAL 의사 컬럼을 통해 최초로 시퀀스에
      접근하면, 시퀀스는 <a id="d5e6289" class="indexterm"/>초기 값을 반환한다. 이후 NEXTVAL을 사용할 때마다 시퀀스의 값은 <a id="d5e6292" class="indexterm"/>증감치 만큼 증가하고, 새로 증가된 값을 반환한다. CURRVAL 의사 컬럼은 항상 시퀀스의 현재 값을
      반환하며, 이것은 가장 마지막에 사용된 NEXTVAL이 반환한 값과 같다.</p>

      <p>CURRVAL 의사 컬럼을 사용하기 전에 적어도 한 번 이상은 시퀀스에 NEXTVAL을 사용해서 <a id="d5e6296" class="indexterm"/>초기화를 시켜야 한다. SQL 문장에 사용된 NEXTVAL 의사 컬럼은 SQL 문장이 처리하는 행의
      단위별로 시퀀스의 값을 <a id="d5e6299" class="indexterm"/>증가시킨다.</p>

      <div class="literallayout"><p/></div>

      <p>시퀀스의 값을 증가시키는 행은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>최상위 레벨의 SELECT 문이 출력하는 행</p>
        </li><li>
          <p>INSERT ... SELECT 문에서 SELECT 문이 선택하는 행</p>
        </li><li>
          <p>CREATE TABLE ... AS SELECT 문에서 SELECT 문이 선택하는 행</p>
        </li><li>
          <p>UPDATE 문이 갱신하는 각각의 행</p>
        </li><li>
          <p>VALUES 절을 포함한 INSERT 문이 삽입하는 행</p>
        </li></ul></div>

      <p>한 행에 두 번 이상의 NEXTVAL이 나왔을 경우 시퀀스 값은 처음 한 번만 증가되며, 증가된 그 값이 다음 위치에
      동일하게 사용된다.</p>

      <p>NEXTVAL과 CURRVAL이 한 행에 동시에 나왔을 경우 시퀀스 값은 역시 한 번만 증가되며, NEXTVAL에
      사용된 값이 CURRVAL에 동일하게 사용된다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6317"/>2.9.5. 동의어</h3></div></div></div>
      

      <p><a id="d5e6320" class="indexterm"/>동의어는 특정 스키마 객체에 정의하는 일종의 별칭(Alias)이다. 대개 긴 이름을 갖는 스키마 객체에
      대하여 짧은 이름의 동의어를 정의하거나, 특별한 용도의 스키마 객체에 대하여 동의어를 정의한다.</p>

      <p>다음은 동의어에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>동의어와 뷰의 차이점</p>

          <p>동의어는 긴 이름 대신 사용한다는 점에서 뷰와 같다. 그러나 뷰는 하나의 완전한 SQL 문장에 대한 것이고,
          동의어는 하나의 스키마 객체에 한정된다는 차이점이 있다. 또한 동의어는 뷰와 다르게 접근 권한이 별도로 설정되지 않는다.
          만약 특정 스키마 객체에 대한 접근 권한이 있다면 그에 대한 동의어에 대해서도 접근 권한을 갖게 된다.</p>
        </li><li>
          <p>동의어의 사용 설정</p>

          <p>동의어는 기본적으로 동의어를 정의한 사용자만이 사용할 수 있으나, 다른 모든 사용자도 함께 사용하도록
          <a id="d5e6330" class="indexterm"/>공용으로 정의할 수도 있다. 이렇게 모든 사용자가 사용할 수 있는 동의어를 공유 동의어라고
          부른다. <span>Tibero</span>에서는 DBA와 일반 사용자가 데이터
          사전(Data Dictionary)의 정보를 쉽게 접근할 수 있도록, 여러 가지 시스템 뷰를 정의하고 각각에 대한 동의어를
          정의하고 있다.</p>
        </li></ul></div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>동의어를 생성하고 삭제하기 위한 SQL 문장은 <a href="ch_ddl.html#sect_ddl_CREATE_SYNONYM" title="7.40. CREATE SYNONYM">CREATE SYNONYM</a>과 <a href="ch_ddl.html#sect_ddl_DROP_SYNONYM" title="7.61. DROP SYNONYM">DROP SYNONYM</a>이다. 동의어를 변경하기 위한
        별도의 SQL 문장은 없다. 이러한 문장은 DDL에 포함되며, 자세한 설명은 <a href="ch_ddl.html" title="제7장 데이터 정의어">“제7장 데이터 정의어”</a>를
        참고한다.</p>
      </div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_SQL_schema_obj_name"/>2.9.6. 스키마 객체의 이름</h3></div></div></div>
      

      <p>스키마 객체<a id="d5e6342" class="indexterm"/>에 따라 사용자가 각각의 부분 또는 전체에 이름을 부여할 수 있거나 꼭 부여해야만 하는 경우가 있다.
      테이블, 테이블의 컬럼, 인덱스, 무결성 제약조건<span>, 테이블 파티션, 테이블 서브 파티션, 인덱스 파티션, 인덱스
      서브파티션, 패키지와 패키지 내의 함수와 프러시저</span> 등이 이에 해당한다.</p>

      <p>SQL 문장에서 스키마 객체의 이름을 명시할 때는 <a id="d5e6347" class="indexterm"/>'따옴표 있는 식별자' 또는 '따옴표 없는 식별자'를 사용한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>따옴표 있는 식별자는 큰따옴표(" ")로 시작해서 큰따옴표로 끝난다.</p>
        </li><li>
          <p>따옴표 없는 식별자는 큰따옴표로 열고 닫지 않는다.</p>
        </li></ul></div>

      <p>스키마 객체에 이름을 부여할 때는 이 두 개 중 어떤 것을 쓰더라도 상관없다. 따옴표 없는 식별자는 대소문자를 구별하지
      않으며, 모두 대문자로 간주되어 처리된다. 따옴표 있는 식별자는 대소문자를 구분한다.</p>

      <p>예를 들어 다음의 경우는 모두 서로 다른 식별자이다.</p>

      <pre class="programlisting">department
"department"
"Department"</pre>

      <div class="literallayout"><p/></div>

      <p>다음의 경우는 모두 같은 식별자이다.</p>

      <pre class="programlisting">department
DEPARTMENT
"DEPARTMENT"</pre>

      <div class="literallayout"><p/></div>

      <p>식별자를 기술할 때는 다음의 규칙을 지켜야 한다.<a id="d5e6364" class="indexterm"/></p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>길이가 30byte를 넘어서는 안 된다.</p>
        </li><li>
          <p>예약어는 따옴표 없는 식별자가 될 수 없다. 따옴표를 적용하여 예약어를 식별자로 만들 수 있으나, 권장하지는
          않는다. 예약어는 <a href="appendix_reserved_words.html" title="Appendix A. 예약어">“Appendix A. 예약어”</a>를 참고한다.</p>
        </li><li>
          <p>따옴표 없는 식별자는 알파벳, 한글, 숫자, 언더바( _ ), $, #만 사용할 수 있다. 다만, 숫자,
          '$', '#'는 첫 글자로 올 수 없다.</p>
        </li><li>
          <p>따옴표 있는 식별자는 공백을 포함한 어떤 문자라도 쓸 수 있다. 다만 큰따옴표(" ")는 사용할 수
          없다.</p>
        </li><li>
          <p>하나의 <a id="d5e6379" class="indexterm"/><a id="d5e6382" class="indexterm"/>네임스페이스 안에서 서로 다른 두 객체가 동일한 이름을 가질 수 없다.</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="100" align="left"/><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th align="left">네임스페이스</th><th>종류</th></tr></thead><tbody><tr><td rowspan="2" align="left">스키마 객체</td><td align="left">하나의 네임스페이스</td><td>테이블, 뷰, 실체화 뷰, 시퀀스, 동의어<span>, 패키지, 패키지에 포함되지 않은 함수
                  및 프러시저</span></td></tr><tr><td align="left">독립적인 네임스페이스</td><td><p>인덱스, 트리거, 대용량 객체형 데이터 타입</p><p>(서로 다른
                  스키마의 네임스페이스는 공유되지 않는다. 그러므로 서로 다른 스키마에 있는 두 개의 테이블은 같은 이름을
                  가질 수 있다.)</p></td></tr><tr><td align="left">일반 객체</td><td align="left">독립적인 네임스페이스</td><td>사용자 역할, 공유 동의어<span>, 테이블 스페이스</span></td></tr></tbody></table>
          </div>
        </li><li>
          <p>하나의 테이블 내의 서로 다른 컬럼은 동일한 이름을 가질 수 없다. 서로 다른 테이블에 속해 있는 컬럼은 동일한
          이름을 가질 수 있다.</p>
        </li><li>
          <p>한 패키지 내의 서로 다른 프러시저나 함수는 인자의 개수나 데이터 타입이 다른 경우에 한해서 동일한 이름을 가질
          수 있다.</p>
        </li></ul></div>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6416"/>2.9.7. 스키마 객체 관련 문법</h3></div></div></div>
      

      <p><a id="d5e6419" class="indexterm"/>SQL 문장에서 스키마 객체와 객체의 구성 요소를 명시하는 방법을 설명한다.</p>

      <div class="literallayout"><p/></div>

      <p>스키마 객체를 명시하는 문법의 세부 내용은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>문법</p>

          <div class="informalfigure">
            <div xmlns="" class="mediaobject"><img src="resources/schema_object_or_part.png"/></div>
          </div>
        </li><li>
          <p>구성요소</p>

          <div class="informaltable">
              <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">구성요소</th><th>설명</th></tr></thead><tbody><tr><td align="left">schema</td><td><p>객체를 포함하고 있는 스키마의 이름이다.</p><p>이 schema
                    부분을 명시해 사용자가 소유한 스키마가 아닌 다른 사용자의 스키마에 있는 객체를 지정할 수가 있다. 다른
                    사용자가 소유한 스키마 객체에 접근하기 위해서는 권한을 부여받아야 한다. schema를 생략하면 자기
                    자신의 스키마에 있는 객체를 명시하는 것으로 인식된다.</p><p>스키마 객체에만
                    schema라는 한정어를 사용할 수가 있다. 스키마 객체와 스키마 객체가 아닌 일반 객체의 종류 및
                    네임스페이스에 대해서는 <a href="ch_sql_elements.html#sect_SQL_schema_obj_name" title="2.9.6. 스키마 객체의 이름">“2.9.6. 스키마 객체의 이름”</a>에
                    설명되어 있다.</p><p>참고로 공유 동의어에 대해서는 "PUBLIC"이라는 한정어를
                    사용한다. PUBLIC을 사용할 때는 큰따옴표(" ")를 꼭 사용해야만 한다.</p></td></tr><tr><td align="left">object</td><td>객체의 이름이다.</td></tr><tr><td align="left">part</td><td>객체의 구성 요소를 명시할 때 사용된다. 예를 들면 테이블의 구성 요소로는
                    컬럼<span>, 파티션 등</span>이 있다.</td></tr><tr><td align="left">dblink</td><td><p>분산 데이터베이스 기능을 사용할 때 필요하다. object 부분에 명시한 객체를
                    포함하고 있는 데이터베이스의 이름을 명시한다.</p><p>dblink를 사용해 자신의
                    데이터베이스가 아닌 원격 데이터베이스에 있는 객체를 명시할 수가 있다. 이 한정어를 생략하면 사용자의
                    데이터베이스에 있는 객체를 명시하는 것으로 인식된다.</p></td></tr></tbody></table>
            </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="schema_obj_search"/>스키마 객체를 찾는 과정</h4>

      <p>SQL 문장 내에 명시된 스키마 객체를 찾는 과정은 다음과 같다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p>SQL 문장의 문맥에 따라 네임스페이스가 결정된다.</p>
        </li><li>
          <p>결정된 네임스페이스 내에서 객체를 찾는다.</p>
        </li><li>
          <p>객체의 타입이 SQL 문장 내의 객체가 명시된 위치에서 사용될 수 있는지 확인한다.</p>
        </li><li>
          <p>사용될 수 없는 타입이라면 에러를 반환한다.</p>
        </li></ol></div>

      <div class="literallayout"><p/></div>

      <p>다음은 위의 과정을 설명하는 예이다.</p>

      <pre class="programlisting">SELECT * FROM employees;</pre>

      <p>위의 SQL 문장을 입력했다고 가정하고, 위의 문장을 예로 스키마 객체를 찾는 과정을 설명하면 다음과 같다. 각각의
      숫자는 스키마 객체를 찾는 과정에서 각 단계를 설명할 때 사용된 숫자와 동일한 단계이다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p>위의 SQL 문장은 스키마를 명시하지 않았으므로 사용자가 소유한 스키마를 네임스페이스로 결정한다.</p>
        </li><li>
          <p>결정된 네임스페이스에서 즉, 사용자가 소유한 스키마 내에서 employees라는 객체가 있는지 찾는다. 만일
          찾지 못했다면 employees라는 공유 동의어가 존재하는지 확인한다. 공유 동의어에도 employees라는 객체가 없다면
          에러를 반환한다.</p>

          <p>만약 찾은 객체가 동의어라면 동의어의 정의를 따라가서 동의어가 정의하고 있는 스키마 객체가 동의어인지 아닌지
          확인한다. 동의어라면 또 그 동의어의 정의를 따라간다. 동의어가 아닌 스키마 객체가 나올 때까지 이 과정을
          반복한다.</p>
        </li><li>
          <p>해당 객체를 찾았으면 그 객체가 테이블인지 아니면 뷰인지 확인한다. FROM 절에는 테이블 또는 뷰만 올 수
          있다.</p>
        </li><li>
          <p>만약 테이블 또는 뷰가 아닌 다른 객체라면 에러를 반환한다.</p>
        </li></ol></div>

      <p/>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e6494"/>원격 데이터베이스의 객체를 찾는 과정</h4>

      <p>원격 데이터베이스에 있는 객체를 명시하기 위해서는 객체 이름 다음에 "@" 표시와 함께 데이터베이스
      링크(Database link) 이름을 명시한다. 데이터베이스 링크는 원격 데이터베이스와의 연결을 담당하는 스키마 객체이다.
      데이터베이스 링크는 <a href="ch_ddl.html#sect_ddl_CREATE_DATABASE_LINK" title="7.26. CREATE DATABASE LINK">“7.26. CREATE DATABASE LINK”</a>를 사용하여
      생성한다.</p>

      <p>SQL 문장에서 데이터베이스 링크를 사용했을 경우 해당 객체를 찾는 과정은 다음과 같다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p>먼저 사용자의 스키마에서 해당 이름을 갖는 데이터베이스 링크가 존재하는지 찾는다.</p>
        </li><li>
          <p>존재하지 않으면 공유 데이터베이스 링크 중에서 해당 이름을 찾는다.</p>
        </li><li>
          <p>해당 데이터베이스 링크를 찾았으면, 그 데이터베이스 링크를 이용해 원격 데이터베이스의 객체에 접근을
          시도한다.</p>
        </li><li>
          <p>해당 원격 데이터베이스에서 스키마 객체를 찾는 과정은 <a href="ch_sql_elements.html#schema_obj_search" title="2.9.7. 스키마 객체를 찾는 과정">"스키마 객체를 찾는 과정"</a>과 동일하다.</p>
        </li></ol></div>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch_sql_concept.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch_sql_expressions.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제1장 SQL 소개 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제3장 SQL 연산</td></tr></table></div><div xmlns="" align="center"/></body></html>