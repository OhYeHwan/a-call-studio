<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제4장 배열 변수</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbESQL/COBOL 안내서"/><link rel="up" href="index.html" title="Tibero tbESQL/COBOL 안내서"/><link rel="prev" href="ch03.html" title="제3장 기본 프로그래밍"/><link rel="next" href="chapter_reference.html" title="제5장 tbESQL/COBOL 문장"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제4장 배열 변수</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_reference.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_array_variable"/>제4장 배열 변수</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_array_variable.html#d5e1908">4.1. 개요</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e1952">4.2. 배열 변수 선언</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e1959">4.3. 입/출력 배열 변수</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_array_variable.html#d5e1964">4.3.1. SELECT</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e2107">4.3.2. INSERT</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e2138">4.3.3. UPDATE</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e2165">4.3.4. DELETE</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e2191">4.3.5. FOR 절</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_array_variable.html#d5e2228">4.4. 구조체 배열 변수</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_array_variable.html#d5e2238">4.4.1. 구조체 배열 변수의 선언</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e2260">4.4.2. 사용 방법</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 배열 변수의 기본 개념과 선언 방법, 그리고 배열 변수를 <span>tbESQL</span>/COBOL 문장에서 입/출력 변수로 사용하는 방법을 설명한다.
  <a id="d5e1904" class="indexterm"/><a id="d5e1906" class="indexterm"/></p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1908"/>4.1. 개요</h2></div></div></div>
    

    <p><span>tbESQL</span>/COBOL 프로그램의 배열 변수는 COBOL 프로그래밍 언어의 배열
    변수의 개념과 동일하다. 배열은 동일한 타입의 값을 여러 개 저장할 수 있는 데이터 구조이다.</p>

    <p><span>tbESQL</span>/COBOL 프로그램에서는 SELECT 문장을 실행한 뒤 다수의 결과
    로우를 저장하기 위해서 출력 변수로 배열 변수를 사용하거나, INSERT 문장을 사용할 때도 보통 여러 개의 로우를 삽입하게 되므로
    입력 변수로 배열 변수를 사용한다.</p>

    <div class="literallayout"><p/></div>

    <p>배열 변수가 출력 변수로 사용될 때는 <span><strong class="guibutton">출력 배열 변수</strong></span>라고 부르며, 입력 변수로
    사용될 때는 <span><strong class="guibutton">입력 배열 변수</strong></span>라고 한다. 출력 배열 변수와 입력 배열 변수가 사용되는 문장은
    다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>출력 배열 변수<a id="d5e1921" class="indexterm"/></p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>SELECT</p>
          </li></ul></div>
      </li><li>
        <p>입력 배열 변수<a id="d5e1928" class="indexterm"/></p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>INSERT</p>
          </li><li>
            <p>UPDATE</p>
          </li><li>
            <p>DELETE</p>
          </li></ul></div>
      </li></ul></div>

    <div class="literallayout"><p/></div>

    <p><span>tbESQL</span>/COBOL 프로그램에서 <span>tbESQL</span>/COBOL 문장과 COBOL 프로그램의 변수 사이에 데이터를 주고받을 때
    배열 변수를 사용하면 다음과 같은 장점이 있다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>간결하고 구조적인 프로그래밍</p>

        <p>배열 변수를 사용하면 각각의 로우를 처리할 때마다 별도의 SQL 문장을 사용하지 않고, 모든 로우를 하나의 SQL
        문장으로 처리할 수 있다. 따라서 프로그램의 소스 코드를 보다 단순화할 수 있으며, 구조적인 프로그래밍이
        가능하다.</p>
      </li><li>
        <p><span>tbESQL</span>/COBOL 프로그램의 성능 향상</p>

        <p>클라이언트와 서버 환경에서는 데이터를 주고 받기 위하여 많은 시간이 필요하다. 배열 변수를 사용해 여러 로우를
        한꺼번에 처리하면 전송 시간이 크게 줄어든다.</p>
      </li></ul></div>

    <p/>

    <p/>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1952"/>4.2. 배열 변수 선언</h2></div></div></div>
    

    <p><span>tbESQL</span>/COBOL 문장에서 사용될 배열 변수는 대체로 COBOL 프로그램에서
    배열 변수를 선언하는 방법과 같다. 다만, <span>tbESQL</span>/COBOL 문장에 사용될 배열 변수를 선언할 때에는 반드시 DECLARE
    영역 안에 선언해야 한다.</p>

    <p>다음은 배열 변수를 선언하는 예이다.</p>

    <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
   01 ENAME  PIC X(24) OCCURS 50 TIMES VARYING. 
   01 SALARY PIC S9(5) OCCURS 50 TIMES. 
   01 ADDR   PIC X(32) OCCURS 50 TIMES VARYING. 
... 
EXEC SQL END DECLARE SECTION END-EXEC.</pre>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1959"/>4.3. 입/출력 배열 변수</h2></div></div></div>
    

    <p>본 절에서는 <span>tbESQL</span>/COBOL 문장에서 배열 변수가 입/출력 변수로 사용될 경우 각
    <span>tbESQL</span>/COBOL 문장에 따른 배열 변수의 사용 방법에 대해
    설명한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1964"/>4.3.1. SELECT</h3></div></div></div>
      

      <p><span><strong class="guibutton">SELECT</strong></span> 문장을 실행하여 반환되는 결과 로우의 개수가 하나 이상이라면
      반드시 커서 또는 <span><strong class="guibutton">배열 변수</strong></span>를 사용해야 한다. 결과 로우의 개수를 미리 예측할 수 있다면
      배열 변수의 크기를 충분히 선언하여 사용할 수 있다. 만약 결과 로우의 개수가 예측하기 힘들거나 매우 크다면,
      <span><strong class="guibutton">배열 변수와 커서를 함께</strong></span> 사용할 수도 있다.<a id="d5e1970" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1973"/>배열 변수</h4>

      <p><span><strong class="guibutton">SELECT</strong></span> 문장의 실행 결과로 반환된 로우의 개수가 예측 가능하고 크기가
      크지 않다면 <span><strong class="guibutton">배열 변수</strong></span>를 이용하여 모든 결과 로우를 한번에 받을 수 있다. 예를 들어
      SELECT 문장의 결과로 반환되는 로우의 개수가 50개를 넘지 않는 경우에 다음과 같이 소스 코드를 작성할 수
      있다.</p>

      <div class="example"><a id="ex_array_select"/><p class="title"><b>[예 4.1] SELECT 문장에서의 배열 변수의 사용</b></p><div class="example-contents">
        

        

        <pre class="programlisting">01 ENAME  PIC X(24) OCCURS 50 TIMES VARYING. 
01 SALARY PIC S9(5) OCCURS 50 TIMES. 
01 ADDR   PIC X(32) OCCURS 50 TIMES VARYING. 
... 
EXEC SQL SELECT ENAME, SALARY, ADDR 
         INTO :ENAME, :SALARY, :ADDR 
         FROM EMP 
         WHERE SALARY &gt;= 50000 
END-EXEC.</pre>

        <p>결과 로우의 각 컬럼 값은 각 배열 변수에 저장되며, 저장될 때 같은 순서의 변수에 저장된다. 예를 들어 세 번째
        로우의 컬럼 값은 각각 배열 변수의 세 번째 위치인 ENAME(3), SALARY(3), ADDR(3)에
        저장된다.</p>

        <div class="literallayout"><p/></div>

        <p>SELECT 문장에서 배열 변수를 사용할 때는 다음의 사항에 유의해야 한다.</p>

        <div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>INTO 절에 포함되는 출력 변수는 배열 변수와 일반 변수가 동시에 <span><strong class="guibutton">함께 올 수
            없다.</strong></span></p>

            <p>따라서 INTO 절에 포함된 모든 출력 변수는 배열 변수이거나 또는 일반 변수이어야 한다.</p>
          </li><li>
            <p>SELECT 문장의 실행 결과로 반환된 로우의 전부가 아닌 <span><strong class="guibutton">일부</strong></span>만을
            얻고 싶을 때에도 배열 변수를 이용할 수 있다. 위의 <a href="chapter_array_variable.html#ex_array_select" title="[예 4.1] SELECT 문장에서의 배열 변수의 사용">[예 4.1]</a>에서
            SELECT 문장의 실행 결과로 반환된 로우가 50개가 넘는 경우에 50개까지의 결과 로우만을 배열 변수에
            저장한다.</p>
          </li><li>
            <p>SELECT 문장의 실행 결과로 배열 변수에 저장된 로우의 실제 개수는 변수인
            <span><strong class="guibutton">SQLERRD(3) IN SQLCA</strong></span>를 통해 알 수 있다.</p>

            <p>다음은 SELECT 문의 실행 후에 올 수 있는 소스 코드에 SQLERRD(3) IN SQLCA를 사용한
            예이다.</p>

            <pre class="programlisting">PERFORM VARYING CNT FROM 1 BY 1 
                     UNTIL ( CNT &gt; SQLERRD(3) IN SQLCA ) 
        DISPLAY ENAME(CNT) ', ' SALARY(CNT) ', ' ADDR(CNT) 
END-PERFORM. 
DISPLAY 'number of returned rows = ' SQLERRD(3) IN SQLCA</pre>

            <p>맨 마지막 라인을 보면 반환된 로우의 개수를 출력하는 데 SQLERRD(3) IN SQLCA를
            사용하였다.</p>
          </li><li>
            <p>배열 변수의 크기가 일정하지 않은 경우에는 <span><strong class="guibutton">가장 작은</strong></span> 배열 변수의
            크기를 전체 배열 변수의 크기로 설정한다. 예를 들어 다음의 소스 코드와 같이 배열 변수가 선언된 경우에 배열 변수
            ENAME과 SALARY의 크기는 50이지만, ADDR의 크기가 30이므로, SELECT 문의 실행 후에 반환되는 결과
            로우의 개수는 30개이다.</p>

            <pre class="programlisting">01 ENAME  PIC X(24) OCCURS 50 TIMES VARYING. 
01 SALARY PIC S9(5) OCCURS 50 TIMES. 
01 ADDR   PIC X(32) OCCURS 30 TIMES VARYING. 
... 
EXEC SQL SELECT ENAME, SALARY, ADDR 
         INTO :ENAME, :SALARY, :ADDR 
         FROM EMP 
         WHERE SALARY &gt;= 50000 
END-EXEC.</pre>
          </li><li>
            <p>SELECT 문장의 <span><strong class="guibutton">WHERE</strong></span> 절에는 배열 변수가 올 수 없다.
            WHERE 절에 배열 변수가 오는 경우 질의의 의미가 모호해지기 때문이다.</p>

            <p>따라서 다음과 같은 소스 코드는 프리컴파일 과정에서 에러를 반환한다.</p>

            <pre class="programlisting">01 DEPTNO PIC S9(9) OCCURS 50 TIMES. 
... 
EXEC SQL SELECT ENAME, SALARY, ADDR 
         INTO :ENAME, :SALARY, :ADDR 
         FROM EMP 
         WHERE DEPTNO = :DEPTNO 
END-EXEC.</pre>

            <p>배열 변수와 함께 커서를 사용하더라도 SELECT 문장의 WHERE 절에 배열 변수를 사용할 수는
            없다.</p>
          </li></ul></div>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2009"/>배열 변수와 커서<a id="d5e2010" class="indexterm"/></h4>

      <p><span><strong class="guibutton">SELECT</strong></span> 문장의 실행 결과로 반환되는 로우의 개수를 예측하기 어렵거나
      반환되는 로우의 개수가 많다면 배열 변수와 함께 <span><strong class="guibutton">커서</strong></span>를 이용하여야 한다. 이때 일반
      커서는 물론 스크롤 가능 커서도 사용할 수 있다.</p>

      <p>커서와 배열 변수를 함께 사용하는 방법은 커서와 일반 변수를 함께 사용하는 경우와 거의 유사하다. 하지만
      <span><strong class="guibutton">FETCH</strong></span>를 실행할 때 루프를 빠져 나오는 방법이 일반 변수를 사용할 때와 다르다. 그
      이유는 NOT FOUND 에러가 발생되는 경우가 차이가 있기 때문이다.</p>

      <p/>

      <p>일반적으로 커서를 이용하여 루프 내에서 결과 로우를 액세스할 때 더 이상 읽어 올 결과 로우가 없으면 NOT FOUND
      에러가 반환된다. 하지만 일반 변수일 때와 배열 변수일 때 <span><strong class="guibutton">NOT FOUND 에러</strong></span>는
      다음과 같은 차이가 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th>설명</th></tr></thead><tbody><tr><td align="left">일반 변수</td><td>일반 변수를 이용할 때에는 결과 로우를 하나씩 액세스하므로 NOT FOUND 에러가 발생할 때에는 출력
              변수에 저장된 결과 로우는 없다.</td></tr><tr><td align="left">배열 변수</td><td>배열 변수를 이용할 때에는 배열 변수의 크기보다 작은 수의 결과 로우를 반환하더라도 NOT FOUND
              에러를 반환한다. 즉, NOT FOUND 에러를 반환하더라도 출력 배열 변수에는 결과 로우가 포함되어 있을 수
              있다.</td></tr></tbody></table>
      </div>

      <p>따라서 배열 변수를 사용할 때는 SQLCA의 변수를 사용해 루프를 빠져 나온다. 커서와 함께 배열 변수가 사용될 때에
      SQLERRD(3) IN SQLCA에는 FETCH 문장을 수행할 때마다 현재까지 처리된 결과 로우의 누적 개수가 저장된다.
      그러므로 이 누적 개수가 더 이상 증가하지 않을 때 루프를 중단하면 된다.</p>

      <p>다음은 루프를 중단하는 소스 코드의 예이다.</p>

      <div class="example"><a id="d5e2036"/><p class="title"><b>[예 4.2] SQLERRD(3) IN SQLCA를 활용한 루프의 중단</b></p><div class="example-contents">
        

        

        <pre class="programlisting">01 IDX           PIC S9(9). 
01 COUNT         PIC S9(9). 
01 BEFORE-COUNT  PIC S9(9). 
01 CURRENT-COUNT PIC S9(9). 
... 
EXEC SQL DECLARE CUR CURSOR FOR ... 
... 
MOVE 0 TO BEFORE-COUNT. 
MOVE 0 TO CURRENT-COUNT. 
... 
FETCH. 
   EXEC SQL FETCH CUR INTO ... 
   MOVE SQLERRD(3) IN SQLCA TO CURRENT-COUNT.<span><strong class="guibutton">

   IF (CURRENT-COUNT = BEFORE-COUNT) GOTO FETCH-END.</strong></span>
   COMPUTE COUNT = CURRERNT-COUNT - BEFORE-COUNT. 
 
   PERFORM VARYING IDX FROM 1 BY 1 UNTIL ( IDX &gt; COUNT ) 
* 각 로우에 대한 처리 
   END-PERFORM. 
 
    MOVE CURRENT-COUNT TO BEFORE-COUNT. 
    GO TO FETCH. 
FETCH-END.</pre>
      </div></div><br class="example-break"/>

      <p>위의 예에서는 두 개의 새로운 변수 BEFORE-COUNT와 CURRENT-COUNT를 사용하여 두 변수의 값이
      일치하면 FETCH 루프를 중단한다. 출력 배열 변수에 저장된 실제 결과 로우의 개수는 변수 COUNT에 저장된다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2042"/>다수의 커서</h4>

      <p><span><strong class="guibutton">SELECT</strong></span> 문장에는 배열 변수와 함께 <span><strong class="guibutton">다수의
      커서</strong></span>를 사용할 수도 있다. 몇 개의 커서를 사용하더라도 하나의 커서를 사용할 때와 동일하게 처리된다. 동시에
      여러 개의 커서를 사용할 때 SQLCA의 변수는 각 커서마다 별도로 선언되지는 않는다. 따라서 변수 SQLCA에 저장된 데이터는
      직전에 실행된 질의 또는 기타 SQL 문장의 결과에 대한 데이터이다.</p>

      <p>다음은 각 커서에 FETCH를 수행할 때마다 변수 SQLCA에 저장되는 데이터의 예이다.</p>

      <pre class="programlisting">EXEC SQL DECLARE CUR1 CURSOR FOR ... 
EXEC SQL DECLARE CUR2 CURSOR FOR ... 
... 
EXEC SQL OPEN CUR1 END-EXEC. 
EXEC SQL OPEN CUR2 END-EXEC. 
... 
EXEC SQL FETCH CUR1 INTO :ENAME END-EXEC. 
* SQLERRD(3) = 20 
EXEC SQL FETCH CUR2 INTO :SALARY END-EXEC. 
* SQLERRD(3) = 30, not 50 
EXEC SQL FETCH CUR1 INTO :ENAME END-EXEC. 
* SQLERRD(3) = 40, not 70 
EXEC SQL FETCH CUR1 INTO :ENAME END-EXEC. 
* SQLERRD(3) = 60, not 90 
EXEC SQL FETCH CUR2 INTO :SALARY END-EXEC. 
* SQLERRD(3) = 60, not 120</pre>

      <p>위의 예에서 배열 변수 ENAME과 SALARY는 각각 크기가 20과 30이며, 커서 CUR1과 CUR2에 연관된
      SELECT 문장의 결과 로우의 개수가 충분히 크다고 가정한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2050"/>스크롤 가능 커서</h4>

      <p><span><strong class="guibutton">SELECT</strong></span> 문장에는 배열 변수와 함께 <span><strong class="guibutton">스크롤 가능
      커서</strong></span>를 사용할 수도 있다. 스크롤 가능 커서는 일반 커서의 경우와 거의 동일하게 사용할 수 있으나,
      <span><strong class="guibutton">SQLERRD(3) IN SQLCA</strong></span>에 저장되는 값의 의미가 달라진다.</p>

      <p>일반 커서와 스크롤 가능 커서의 SQLERRD(3) IN SQLCA 값의 차이는 다음과 같다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="250" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th>설명</th></tr></thead><tbody><tr><td align="left">일반 커서의 SQLERRD(3) IN SQLCA</td><td>일반 커서의 경우에는 액세스된 결과 로우의<span><strong class="guibutton"> 누적 개수</strong></span>를
              저장하고 있다.</td></tr><tr><td align="left">스크롤 가능 커서의 SQLERRD(3) IN SQLCA</td><td>현재까지 액세스된 가장 마지막 결과 로우의 <span><strong class="guibutton">절대 위치</strong></span>를
              저장하고 있다.</td></tr></tbody></table>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      <p>스크롤 가능 커서를 사용할 때 SQLERRD(3) IN SQLCA에 저장되는 값은 다음과 같이 결정된다.</p>

      <p>FETCH 문장을 수행할 때마다 옵션에 의하여 정해진 결과 로우의 위치로부터 배열 변수의 크기만큼 액세스하게 되므로,
      SQLERRD(3) IN SQLCA에 저장되는 값은(액세스하고자 하는 결과 로우의 절대 위치 + 배열 변수의 크기 - 1) 값
      중에서 현재까지 가장 큰 값이 된다. 만약 액세스하려는 위치에서부터 남아 있는 결과 로우의 개수가 배열 변수의 크기보다 작다면
      SQLERRD(3) IN SQLCA에 저장되는 값은 전체 결과 로우의 개수가 된다. 결과 로우의 절대 위치 값과
      SQLERRD(3) IN SQLCA 값은 항상 1 이상이다.</p>

      <div class="literallayout"><p/></div>

      <p>다음의 소스 코드는 배열 변수와 함께 스크롤 가능 커서를 사용하는 예이다.</p>

      <pre class="programlisting">EXEC SQL DECLARE CUR SCROLL CURSOR FOR ... 
... 
EXEC SQL OPEN CUR END-EXEC. 
... 
 
EXEC SQL FETCH CUR INTO :ENAME END-EXEC. 
* 1번째 로우부터 액세스. SQLERRD(3) = 20 
 
EXEC SQL FETCH NEXT CUR INTO :ENAME END-EXEC. 
* 21번째 로우부터 액세스. SQLERRD(3) = 40 
 
EXEC SQL FETCH ABSOLUTE 11 CUR INTO :ENAME END-EXEC. 
* 11번째 로우부터 액세스. SQLERRD(3) = 40 
 
EXEC SQL FETCH RELATIVE 20 CUR INTO :ENAME END-EXEC. 
* 51번째 로우부터 액세스. SQLERRD(3) = 70 
 
EXEC SQL FETCH ABSOLUTE 41 CUR INTO :ENAME END-EXEC. 
* 41번째 로우부터 액세스. SQLERRD(3) = 70 
 
EXEC SQL FETCH RELATIVE 20 CUR INTO :ENAME END-EXEC. 
* 81번째 로우부터 액세스. SQLERRD(3) = 90 
 
EXEC SQL FETCH ABSOLUTE 51 CUR INTO :ENAME END-EXEC. 
* 51번째 로우부터 액세스. SQLERRD(3) = 90</pre>

      <p>위의 예에서 배열 변수 ENAME의 크기는 20이며, 커서 CUR에 연관된 SELECT 문장의 결과로 반환된 로우의
      전체 개수는 90이라고 가정한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2081"/>지시자 배열 변수</h4>

      <p><span><strong class="guibutton">SELECT</strong></span> 문장에는 출력 배열 변수와 함께 <span><strong class="guibutton">지시자 배열
      변수</strong></span>를 사용할 수 있다.</p>

      <p>지시자 배열 변수는 출력 배열 변수와 같은 크기를 가져야 하며, 배열 변수로 선언한다는 것 외에는 일반적인 지시자
      변수와 동일하게 사용할 수 있다. 반환되는 컬럼 값이 NULL이거나 값의 일부가 잘릴 가능성이 있다면 지시자 배열 변수의 사용을
      고려해야 한다. 지시자 배열 변수도 다른 변수와 마찬가지로 DECLARE 영역 내에 선언한다.</p>

      <p>다음은 지시자 배열 변수를 사용한 예이다.</p>

      <pre class="programlisting">01 ADDR     PIC X(24) OCCURS 50 TIMES VARYING. 
01 ADDR-IND PIC S9(4) OCCURS 50 TIMES COMP-5. 
... 
EXEC SQL SELECT ADDR, ... 
         INTO :ADDR INDICATOR :ADDR-IND, ... 
         FROM EMP 
         WHERE DEPTNO = 5 
END-EXEC.</pre>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>입력 배열 변수와 함께 지시자 배열 변수를 사용할 수도 있다. 입력 지시자 변수는 INSERT, UPDATE,
        DELETE 문장에서 사용할 수 있다.</p>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2092"/>사용 예제</h4>

      <p>다음은 <a href="ch03.html#ex_using_cursor" title="[예 3.11] 커서의 사용">[예 3.11]</a>에서 제시한 예제를 배열 변수를 이용하도록 수정한
      예이다.</p>

      <pre class="programlisting">IDENTIFICATION                      DIVISION. 
************************************************************* 
PROGRAM-ID.                         TEST. 
************************************************************* 
ENVIRONMENT                         DIVISION. 
************************************************************* 
CONFIGURATION                       SECTION. 
* 
SOURCE-COMPUTER.                    TEST-MACHINE. 
OBJECT-COMPUTER.                    TEST-MACHINE. 
************************************************************* 
DATA                                DIVISION. 
************************************************************* 
WORKING-STORAGE                     SECTION. 
 
EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
01 USERPASS PIC X(20) VALUE Z"<span>tibero</span>/<span>tmax</span>". 
01 ENAME    PIC X(24) OCCURS 30 TIMES VARYING.<em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
01 SALARY   PIC S9(5) OCCURS 30 TIMES. 
01 ADDR     PIC X(32) OCCURS 30 TIMES VARYING. 
01 DEPTNO   PIC S9(9). 
EXEC SQL END DECLARE SECTION END-EXEC. 
 
01 IDX           PIC S9(9). 
01 COUNT         PIC S9(9). 
01 BEFORE_COUNT  PIC S9(9). 
01 CURRENT_COUNT PIC S9(9). 
 
EXEC SQL INCLUDE SQLCA END-EXEC. 
 
PROCEDURE             DIVISION. 
 
EXEC SQL DECLARE EMP-CURSOR CURSOR FOR 
         SELECT ENAME, SALARY, ADDR 
         FROM EMP 
         WHERE DEPTNO = :DEPTNO 
END-EXEC. 
 
EXEC SQL CONNECT :USERPASS END-EXEC. 
DISPLAY 'Connected.'. 
MOVE 10 TO DEPTNO. 
 
EXEC SQL OPEN EMP-CURSOR END-EXEC. 
MOVE 0 TO BEFORE-COUNT. 
MOVE 0 TO CURRENT-COUNT. 
 
FETCH. 
   EXEC SQL FETCH EMP-CURSOR 
            INTO :ENAME, :SALARY, :ADDR 
   END-EXEC. 
 
   MOVE SQLERRD(3) IN SQLCA TO CURRENT-COUNT. 
 
   IF (CURRENT-COUNT = BEFORE-COUNT) GOTO FETCH-END.<em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
 
   COMPUTE COUNT = CURRERNT_COUNT - BEFORE-COUNT. 
 
   PERFORM VARYING IDX FROM 1 BY 1 UNTIL ( IDX &gt; COUNT ) 
           DISPLAY 'ENAME = ' ENAME-ARR(IDX)<em class="lineannotation"><span class="lineannotation">... ③ ...</span></em>
                   ', SALARY = ' SALARY(IDX) 
                   ', ADDR = ' ADDR-ARR(IDX) 
   END-PERFORM. 
 
   MOVE CURRENT-COUNT TO BEFORE-COUNT. 
   GO TO FETCH. 
FETCH-END. 
 
EXEC SQL CLOSE EMP-CURSOR END-EXEC. 
EXEC SQL COMMIT WORK RELEASE END-EXEC.</pre>

      <p>① <a href="ch03.html#ex_using_cursor" title="[예 3.11] 커서의 사용">[예 3.11]</a>과 비교했을 때 변수를 배열 변수로
      선언한다.</p>

      <p>② FETCH를 수행할 때 루프를 중단한다.</p>

      <p>③ 배열 변수에 저장된 컬럼의 값을 DISPLAY 문을 통해 출력한다.</p>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2107"/>4.3.2. INSERT</h3></div></div></div>
      

      <p><span><strong class="guibutton">INSERT</strong></span> 문장에서 배열 변수를 사용하는 방법은 일반적인 입력 변수를
      사용하는 방법과 동일하다. 입력 배열 변수가 사용되는 각 문장은 문장이 실행되기 직전에 동적으로 배열 변수에 저장된 값을 읽어
      들인다. 따라서 각 문장이 실행되기 전에 반드시 배열 변수에 적절한 값을 넣어 주는 코드가 있어야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>INSERT 문장에서 배열 변수를 사용할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>INSERT 문장에서 사용되는 입력 변수는 배열 변수와 일반 변수가 함께 올 수 없다. 따라서 모든 입력 변수가
          배열 변수이거나 일반 변수로만 구성되어야 한다.</p>
        </li><li>
          <p>SELECT 문장과 유사하게 SQLERRD(3) IN SQLCA에는 삽입된 로우의 개수가 저장되어 있다.
          SQLERRD(3) IN SQLCA에는 항상 하나의 INSERT 문장에 의해 삽입된 로우의 개수만 저장된다.</p>
        </li><li>
          <p>FOR 절을 사용해 입력 배열 변수의 크기보다 적은 개수의 로우를 삽입하도록 할 수도 있다.</p>

          <p>예를 들면 크기가 50인 입력 배열 변수의 내용 중에서 30개의 로우 값만을 이용하는 경우이다.</p>
        </li><li>
          <p>입력 배열 변수와 함께 지시자 배열 변수를 사용할 수도 있다. 삽입해야 할 컬럼 값 중 일부만 NULL 값인
          경우에는 반드시 지시자 배열 변수를 사용해야 한다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 배열 변수와 함께 INSERT 문장을 실행하는 예이다.</p>

      <div class="example"><a id="ex_insert_array"/><p class="title"><b>[예 4.3] INSERT 문장의 배열 변수</b></p><div class="example-contents">
        

        

        <pre class="programlisting">01 ENAME  PIC X(24) OCCURS 50 TIMES VARYING. 
01 SALARY PIC S9(5) OCCURS 50 TIMES. 
... 
MOVE "BROWN" TO ENAME(1). 
MOVE "30000" TO SALARY(1). 
MOVE "WHITE" TO ENAME(2). 
MOVE "28000" TO SALARY(2). 
... 
EXEC SQL INSERT INTO EMP (ENAME, SALARY) 
         VALUES (:ENAME, :SALARY) 
END-EXEC.</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>위의 <a href="chapter_array_variable.html#ex_insert_array" title="[예 4.3] INSERT 문장의 배열 변수">[예 4.3]</a>에서의 INSERT 문장은 다음의 루프를 이용한 소스
      코드와 같은 결과를 갖는다. 하지만 배열 변수를 이용하는 편이 서버와의 통신 비용을 크게 줄일 수 있으므로 성능 면에서 훨씬
      효율적이다.</p>

      <pre class="programlisting">PERFORM VARYING IDX FROM 1 BY 1 UNTIL ( IDX &gt; 50 ) 
        EXEC SQL INSERT INTO (ENAME, SALARY) 
                 VALUES (:ENAME(IDX), :SALARY(IDX)) 
        END-EXEC. 
END-PERFORM.</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 컬럼 SALARY에 대해 지시자 배열 변수를 사용한 예이다.</p>

      <pre class="programlisting">01 ENAME      PIC X(24) OCCURS 50 TIMES VARYING. 
01 SALARY     PIC S9(5) OCCURS 50 TIMES. 
01 SALARY-IND PIC S9(4) COMP-5 OCCURS 50 TIMES. 
... 
EXEC SQL INSERT INTO EMP (ENAME, SALARY) 
         VALUES (:ENAME, :SALARY<span><strong class="guibutton">:SALARY-IND</strong></span>) 
END-EXEC.</pre>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2138"/>4.3.3. UPDATE</h3></div></div></div>
      

      <p><span><strong class="guibutton">UPDATE</strong></span> 문장에서 배열 변수를 사용하는 방법도 일반 변수를 사용하는 방법과
      유사하다.</p>

      <div class="literallayout"><p/></div>

      <p>UPDATE 문장에서 배열 변수를 사용할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>UPDATE 문장에서는 SELECT 문장과는 다르게 <span><strong class="guibutton">WHERE 절</strong></span>에도
          배열 변수를 사용할 수 있다.</p>

          <p>WHERE 절에 배열 변수를 사용하면 SET 절에도 배열 변수를 사용해야 한다. 만약 WHERE 절에 일반
          변수를 사용하였다면 SET 절에도 일반 변수를 사용하여야 한다.</p>
        </li><li>
          <p>INSERT 문장과 유사하게 SQLERRD(3) IN SQLCA에는 갱신된 로우의 개수가 저장된다.
          SQLERRD(3) IN SQLCA에는 항상 하나의 UPDATE 문장에 의해 갱신된 로우의 개수만 저장되며, 무결성
          제약조건을 만족하기 위해 연속적으로 갱신되거나 삭제된 로우의 개수는 포함되지 않는다.</p>
        </li><li>
          <p>UPDATE 문장에서 SET 절 내에 사용된 입력 변수에는 배열 변수와 일반 변수가 함께 올 수
          없다.</p>
        </li><li>
          <p>SELECT FOR UPDATE 문장 내에서 <span><strong class="guibutton">UPDATE ... CURRENT OF
          절</strong></span>과 함께 배열 변수를 사용할 수 없다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 UPDATE 문장의 SET 절과 WHERE 절에 배열 변수를 사용한 예이다.</p>

      <div class="example"><a id="ex_array_update"/><p class="title"><b>[예 4.4] UPDATE 문장의 배열 변수</b></p><div class="example-contents">
        

        

        <pre class="programlisting">01 SALARY PIC S9(5) OCCURS 50 TIMES. 
01 EMPNO  PIC S9(9) OCCURS 50 TIMES. 
... 
MOVE "12000" TO SALARY(1). 
MOVE "22000" TO SALARY(2). 
MOVE "18000" TO SALARY(3). 
MOVE "23000" TO SALARY(4). 
MOVE "30000" TO SALARY(5). 
 
MOVE "23401" TO EMPNO(1). 
MOVE "12089" TO EMPNO(2). 
MOVE "13560" TO EMPNO(3). 
MOVE "32109" TO EMPNO(4). 
MOVE "10094" TO EMPNO(5). 
... 
EXEC SQL UPDATE EMP SET SALARY = :SALARY 
         WHERE EMPNO = :EMPNO 
END-EXEC.</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>위의 <a href="chapter_array_variable.html#ex_array_update" title="[예 4.4] UPDATE 문장의 배열 변수">[예 4.4]</a>은 다음과 같은 루프를 이용한 연속된 UPDATE
      문장과 동일한 결과를 갖는다. 하지만 배열 변수를 이용하는 편이 성능 면에서 더욱 효율적이다.</p>

      <pre class="programlisting">PERFORM VARYING IDX FROM 1 BY 1 UNTIL ( IDX &gt; 50 ) 
        EXEC SQL UPDATE EMP SET SALARY = :SALARY(IDX) 
                 WHERE EMPNO = :EMPNO(IDX) 
        END-EXEC. 
END-PERFORM.</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2165"/>4.3.4. DELETE</h3></div></div></div>
      

      <p><span><strong class="guibutton">DELETE</strong></span> 문장에서 배열 변수를 사용하는 방법도 일반 변수를 사용하는 방법과
      유사하다.</p>

      <div class="literallayout"><p/></div>

      <p>DELETE 문장에서 배열 변수를 사용할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>DELETE 문장에서도 UPDATE 문장과 같이 <span><strong class="guibutton">WHERE 절</strong></span>에 배열
          변수를 사용할 수 있다.</p>
        </li><li>
          <p>INSERT, UPDATE 문장에서와 유사하게, SQLERRD(3) IN SQLCA에는 삭제된 로우의 개수가
          저장된다. SQLERRD(3) IN SQLCA에는 항상 하나의 DELETE 문장에 의하여 삭제된 로우의 개수만 저장되며,
          무결성 제약조건을 만족하기 위하여 연속적으로 갱신되거나 삭제된 로우의 개수는 포함되지 않는다.</p>
        </li><li>
          <p>DELETE 문장의 WHERE 절에 사용될 입력 변수로 배열 변수와 일반 변수가 함께 올 수 없다.</p>
        </li><li>
          <p>DELETE 문장에 배열 변수를 사용할 때는 <span><strong class="guibutton">DELETE ... CURRENT OF
          절</strong></span>을 사용할 수 없다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 DELETE 문장의 WHERE 절에 배열 변수를 사용한 예이다.</p>

      <div class="example"><a id="ex_array_delete"/><p class="title"><b>[예 4.5] DELETE 문장의 배열 변수</b></p><div class="example-contents">
        

        

        <pre class="programlisting">01 EMPNO PIC S9(9) OCCURS 50 TIMES. 
... 
MOVE "15009" TO EMPNO(1). 
MOVE "13450" TO EMPNO(2). 
MOVE "24200" TO EMPNO(3). 
MOVE "15832" TO EMPNO(4). 
MOVE "20009" TO EMPNO(5). 
MOVE "30110" TO EMPNO(6). 
... 
EXEC SQL DELETE EMP WHERE EMPNO = :EMPNO 
END-EXEC.</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>위의 <a href="chapter_array_variable.html#ex_array_delete" title="[예 4.5] DELETE 문장의 배열 변수">[예 4.5]</a>은 다음의 루프와 동일한 결과를 갖는다. 하지만
      INSERT, UPDATE 문장과 마찬가지로 배열 변수를 이용하는 편이 성능 면에서 효율적이다.</p>

      <pre class="programlisting">PERFORM VARYING IDX FROM 1 BY 1 UNTIL ( IDX &gt; 50 ) 
        EXEC SQL DELETE EMP 
                 WHERE EMPNO = :EMPNO(IDX) 
        END-EXEC. 
END-PERFORM.</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2191"/>4.3.5. FOR 절<a id="d5e2193" class="indexterm"/></h3></div></div></div>
      

      <p>INSERT, DELETE, UPDATE 문장에서 입력 배열 변수를 사용할 때 배열 변수의 크기보다 적은 개수의 로우를
      처리하려는 경우에 <span><strong class="guibutton">FOR 절</strong></span>을 사용한다. FOR 절은 EXEC SQL 바로 다음에 오며,
      처리하고자 하는 로우의 개수를 명시한다.</p>

      <div class="literallayout"><p/></div>

      <p>FOR 절에 로우의 개수를 명시할 때 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>FOR 절에 로우의 개수를 명시할 때는 <span><strong class="guibutton">숫자</strong></span>를 명시할 수도 있으며,
          <span><strong class="guibutton">변수</strong></span>를 명시할 수도 있다.</p>

          <p>변수를 명시할 경우 해당 변수는 반드시 <span><strong class="guibutton">DECLARE 영역</strong></span>에 선언되어
          있어야 한다.</p>
        </li><li>
          <p>FOR 절에 로우의 개수를 명시할 때 연산식을 사용해서는 안 된다.</p>
        </li><li>
          <p>FOR 절의 로우 개수는 항상 입력 배열 변수의 크기보다 작아야 한다.</p>

          <p><span>tbESQL</span>/COBOL 프로그램에서는 지정된 로우의 개수를 저장할 배열
          변수의 크기를 검토하지 않는다.</p>

          <p>만약 지정된 로우의 개수보다 배열 변수의 크기가 작다면, 내부적으로 유효하지 않은 메모리에 접근하게 되어 메모리
          에러가 발생하고, 이때 <span>tbESQL</span>/COBOL 프로그램이 어떠한 동작을 할지 보장할 수
          없다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음의 소스 코드는 FOR 절을 이용하는 예이다.</p>

      <pre class="programlisting">01 ENAME     PIC X(24) OCCURS 50 TIMES VARYING. 
01 SALARY    PIC S9(5) OCCURS 50 TIMES. 
01 EMPNO     PIC S9(9) OCCURS 50 TIMES. 
01 ROW-COUNT PIC S9(9). 
... 
EXEC SQL FOR <span><strong class="guibutton">20</strong></span><em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
         INSERT INTO EMP (ENAME, SALARY, ADDR) 
         VALUES (:ENAME, :SALARY, NULL) 
END-EXEC. 
...<span><strong class="guibutton">
MOVE 30 TO ROW-COUNT.</strong></span>
EXEC SQL FOR <span><strong class="guibutton">:ROW-COUNT</strong></span><em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
         UPDATE EMP SET SALARY = :SALARY 
         WHERE EMPNO = :EMPNO 
END-EXEC.</pre>

      <p>① 로우의 개수를 숫자로 설정하여 FOR 절을 이용할 수 있다.</p>

      <p>② 변수를 이용하여 로우의 개수를 설정하여 FOR 절을 이용할 수 있다. 단, 변수 ROW-COUNT는 DECLARE
      영역에 선언되어 있어야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 FOR 절에서 로우의 개수를 명시할 때 임의의 연산식을 사용한 경우로 잘못된 예이다.</p>

      <pre class="programlisting">EXEC SQL FOR<span><strong class="guibutton">( :ROW-COUNT + 10 )</strong></span>
         DELETE EMP WHERE EMPNO = :EMPNO 
END-EXEC.</pre>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2228"/>4.4. 구조체 배열 변수</h2></div></div></div>
    

    <p><span>tbESQL</span>/COBOL 문장 내에서 여러 컬럼을 동시에 처리할 때 각 컬럼별 입/출력
    변수 각각을 나열할 수도 있지만, 각 컬럼에 대한 변수를 모아 하나의 구조체로 정의하여 구조체 타입의 변수를 이용할 수도
    있다.</p>

    <p>또한 더 나아가 각 컬럼의 여러 로우를 한꺼번에 처리하고자 할 때 구조체로 정의한 타입을 배열로 선언하여,
    <span><strong class="guibutton"> 구조체 배열 변수<a id="d5e2234" class="indexterm"/><a id="d5e2236" class="indexterm"/></strong></span>를 이용할 수 있다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2238"/>4.4.1. 구조체 배열 변수의 선언</h3></div></div></div>
      

      <p>구조체 배열 변수를 선언할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>구조체 배열 변수는 반드시 <span><strong class="guibutton">DECLARE 영역</strong></span>에 선언되어야
          한다.</p>
        </li><li>
          <p><span>tbESQL</span>/COBOL 문장에서 사용되는 구조체 타입의 변수는 중첩되어
          정의될 수 없다(일반적인 구조체 변수일 때나 구조체 배열 변수일 때나 동일하다).</p>
        </li><li>
          <p>구조체 변수의 그 하위 멤버는 배열일 수 없다(일반적인 구조체 변수일 때나 구조체 배열 변수일 때나
          동일하다).</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 구조체 배열 변수를 선언하는 예이다.</p>

      <pre class="programlisting">01 EMP OCCURS 50 TIMES. 
   03 ENAME  PIC X(24) VARYING. 
   03 SALARY PIC S9(5). 
   03 ADDR   PIC X(32) VARYING.</pre>

      <p>다음은 구조체를 잘못 선언한 예이다.</p>

      <pre class="programlisting">01 EMP OCCURS 50 TIMES. 
   03 ENAME PIC X(24) VARYING. 
   03 SUB-EMP. 
      05 SALARY PIC S9(5). 
      05 ADDR   PIC X(32) VARYING.</pre>

      <p>위의 예에서는 구조체 EMP 내부에 구조체 SUB_EMP를 중첩하여 정의하였다. 구조체 타입의 변수는 중첩되어 정의될
      수 없다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 구조체 타입 변수의 하위 멤버를 배열로 선언한 경우로 잘못 선언한 예이다.</p>

      <pre class="programlisting">01 ENAME 
   03 FIRST-NAME OCCURS 5 TIMES 
   03 LAST-NAME  OCCURS 5 TIMES 
 
01 ENAME-ARR OCCURS 10 TIMES 
   03 FIRST-NAME OCCURS 5 TIMES 
   03 LAST-NAME  OCCURS 5 TIMES</pre>

      <p>위의 예에서 ENAME과 ENAME-ARR의 하위 멤버로 각각 배열을 선언하였다. 구조체 타입의 변수는 하위 멤버로
      배열이 올 수 없다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2260"/>4.4.2. 사용 방법</h3></div></div></div>
      

      <p>단순 구조체 타입의 변수와 마찬가지로 구조체 배열 변수는 SELECT 문장에서의 출력 변수와 INSERT 문장에서의
      입력 변수로 사용할 수 있다.</p>

      <p>구조체 배열 변수를 사용하는 방법은 일반적인 배열 변수와 동일하며, 배열 변수의 사용 방법에 대한 내용은 구조체 배열
      변수에도 동일하게 해당된다. 단순히 구조체 배열 변수만을 사용할 수도 있으며 커서와 함께 사용할 수도 있다.</p>

      <p>다음은 구조체 배열 변수를 입/출력 변수로 사용하는 예이다.</p>

      <pre class="programlisting">01 EMP OCCURS 50 TIMES. 
   03 ENAME  PIC X(24) VARYING. 
   03 SALARY PIC S9(5). 
   03 ADDR   PIC X(32) VARYING. 
       ... 
       EXEC SQL SELECT ENAME, SALARY, ADDR 
                INTO<span><strong class="guibutton"> :EMP</strong></span>
                FROM EMP 
                WHERE SALARY &gt;= 50000 
       END-EXEC. 
       ... 
       EXEC SQL INSERT INTO EMP 
                       VALUES<span><strong class="guibutton">(:EMP)</strong></span>
       END-EXEC.</pre>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_reference.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제3장 기본 프로그래밍 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제5장 <span>tbESQL</span>/COBOL 문장</td></tr></table></div><div xmlns="" align="center"/></body></html>