<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제4장 복합 타입</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbPSM 안내서"/><link rel="up" href="index.html" title="Tibero tbPSM 안내서"/><link rel="prev" href="chapter_control.html" title="제3장 제어 구조"/><link rel="next" href="chapter_subprogram.html" title="제5장 서브 프로그램"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제4장 복합 타입</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_control.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_subprogram.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_composite"/>제4장 복합 타입</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_composite.html#d5e2867">4.1. 개요</a></span></dt><dt><span class="section"><a href="chapter_composite.html#d5e2884">4.2. 컬렉션 타입</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_composite.html#sect_composite_table">4.2.1. 테이블</a></span></dt><dt><span class="section"><a href="chapter_composite.html#sect_index_by_table">4.2.2. 인덱스 테이블</a></span></dt><dt><span class="section"><a href="chapter_composite.html#sect_composite_varray">4.2.3. 배열</a></span></dt><dt><span class="section"><a href="chapter_composite.html#d5e2997">4.2.4. 컬렉션 함수와 프러시저</a></span></dt><dt><span class="section"><a href="chapter_composite.html#d5e3234">4.2.5. 예외 상황</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_composite.html#sect_composite_record">4.3. 레코드</a></span></dt><dt><span class="section"><a href="chapter_composite.html#sect_dml_with_record">4.4. 레코드 타입 변수의 DML</a></span></dt></dl></div>
  

  <p>본 장에서는 <span>tbPSM</span>에서 제공하는 구조체 형태의 콜렉션 타입과 레코드를 설명한다.</p>

  <p/>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2867"/>4.1. 개요</h2></div></div></div>
    

    <p><span><strong class="guibutton">복합 타입</strong></span>(composite type)이란 <span>tbPSM</span>이 제공하는 스칼라 타입의 집합이다. 일반적인 프로그래밍 언어의 구조체에
    해당하며, 그 종류는 다음과 같다.<a id="d5e2872" class="indexterm"/></p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>컬렉션(collection) 타입 : <a href="chapter_composite.html#sect_composite_table" title="4.2.1. 테이블">테이블</a>(nested table), <a href="chapter_composite.html#sect_index_by_table" title="4.2.2. 인덱스 테이블">인덱스 테이블</a>(indexed by table), <a href="chapter_composite.html#sect_composite_varray" title="4.2.3. 배열">배열</a>(varray)</p>
      </li><li>
        <p><a href="chapter_composite.html#sect_composite_record" title="4.3. 레코드">레코드</a>(record)</p>
      </li></ul></div>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2884"/>4.2. 컬렉션 타입<a id="d5e2886" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">컬렉션</strong></span>이란 같은 타입을 갖는 구성요소의 집합이다. 일반적인 프로그래밍 언어에서
    사용하는 배열이나 리스트와 비슷한 개념이다.</p>

    <p><span>tbPSM</span>에서 지원하는 컬렉션 타입에는 세 가지가 있다. 즉, 테이블, 인덱스
    테이블, 그리고 배열이다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_composite_table"/>4.2.1. 테이블<a id="d5e2894" class="indexterm"/></h3></div></div></div>
      

      <p>테이블은 구성요소의 길이 제한이 없고, 각각의 구성요소에 접근할 때는 배열과 마찬가지로 인덱스로 접근한다. 그러나
      배열과 다르게 구성요소가 연속적으로 존재하지 않을 수 있다. 즉, 어떤 구성요소의 다음 인덱스에 값이 반드시 존재한다는 보장이
      없다.</p>

      <p>테이블의 구성요소는 항상 같은 타입을 가지며, REF CURSOR를 제외한 모든 타입이 될 수 있다.</p>

      <p><span>tbPSM</span>에서 테이블을 선언하는 방법은 다음과 같다.</p>

      <pre class="programlisting">TYPE name IS TABLE OF type [NOT NULL];</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2903"/>테이블의 초기화</h4>

      <p>테이블은 초기화라는 과정을 거치게 되는데, 이 과정을 거치지 않은 변수는 항상 NULL을 가지며, 구성요소도 존재하지
      않게 된다. 만약 초기화되지 않은 테이블에 접근할 경우 <span><strong class="guibutton">COLLECTION_IS_NULL</strong></span>
      예외 상황이 발생한다.</p>

      <p>테이블을 초기화하는 방법은 다음과 같다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF VARCHAR2(10) NOT NULL;
    kinds kind_tab;
BEGIN
    kinds := kind_tab('math', 'physics', 'history', 'science');
END;</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2909"/>테이블의 구성요소</h4>

      <p>테이블은 최대 크기의 제한이 없기 때문에 초기 값으로 주어진 구성요소가 현재의 최대 길이가 된다. 만약 테이블에서
      NOT NULL 제약조건이 없을 경우 NULL을 구성요소로 사용할 수 있다.</p>

      <pre class="programlisting">DECLARE
    <span><strong class="guibutton">TYPE kind_tab IS TABLE OF VARCHAR2(10);
    kinds kind_tab := kind_tab('math', NULL, 'history', 'science');</strong></span>
BEGIN
    NULL;
END;</pre>

      <div class="literallayout"><p/></div>

      <p>테이블의 구성요소는 하나의 독립적인 변수처럼 사용할 수 있으며, 해당 변수의 값을 추출할 수 있다. 또한 대입도
      가능하다.</p>

      <p>예를 들면 다음과 같다.</p>

      <pre class="programlisting">DECLARE
    TYPE class_tab IS TABLE OF VARCHAR2(10);
    classes class_tab := class_tab('math', 'physics', 'science');
BEGIN
    classes(3) := 'history';
    IF classes(1) IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('I hate this class');
    END IF;
    DBMS_OUTPUT.PUT_LINE(classes(3) || ' is my favorite class');
END;
/
history is my favorite class

PSM completed</pre>

      <div class="literallayout"><p/></div>

      <p>테이블의 구성요소를 참조하기 위해서는 다음과 같이 사용해야 한다.</p>

      <pre class="programlisting">table_name(index)</pre>

      <p>index에는 1 ~ 2^31 - 1사이의 값만을 사용할 수 있다.</p>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e2922"/>MULTISET 연산자<a id="d5e2923" class="indexterm"/></h4>

      <p>테이블 형태의 변수에는 MULTISET 연산자의 결과를 대입할 수 있다. MULTISET 연산자로는 UNION,
      INTERSECT, EXCEPT 세 가지가 있다.</p>

      <p>UNION은 MULTISET 연산자의 두 테이블을 합쳐 준다. 합칠 때 중복값의 제거 여부를 옵션으로 결정할 수 있다.
      ALL과 DISTINCT의 두 가지 옵션이 있으며, ALL 옵션은 중복되는 값을 제거하지 않는다. 반면 DISTINCT 옵션은
      중복되는 값을 제거한다. 옵션을 주지 않으면 ALL과 같이 동작한다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,2,3);
    tab2 kind_tab := kind_tab(1,4,5);
    result kind_tab;
BEGIN
    result := tab1 MULTISET UNION ALL tab2;
END;</pre>

      <p>MULTISET UNION 에 의해 tab1과 tab2의 구성요소들이 합쳐져 result 테이블에 저장된다. 옵션은
      ALL이므로 중복값을 제거하지 않아, 이 테이블은 1, 2, 3, 1, 4, 5의 여섯 개 구성요소를 갖는다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,2,3);
    tab2 kind_tab := kind_tab(1,4,5);
    result kind_tab;
BEGIN
    result := tab1 MULTISET UNION tab2;
END;</pre>

      <p>ALL 혹은 DISTINCT 옵션을 사용하지 않은 경우 위 예제의 ALL 옵션과 동일하게 동작한다. result
      테이블은 1, 2, 3, 1, 4, 5의 여섯 개 구성요소를 갖는다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,2,3);
    tab2 kind_tab := kind_tab(1,4,5);
    result kind_tab;
BEGIN
    result := tab1 MULTISET UNION DISTINCT tab2;
END;</pre>

      <p>DISTINCT 옵션을 사용한 경우 MULTISET 연산자의 결과에서 중복된 구성요소는 제거된다. result 테이블은
      1, 2, 3, 4, 5의 다섯 개 구성요소를 갖는다.</p>

      <div class="literallayout"><p/></div>

      <p>INTERSECT는 MULTISET 연산자의 두 테이블 사이에 공통된 구성요소를 찾아 준다. 중복값의 제거 여부를
      옵션으로 결정할 수 있다. ALL과 DISTINCT의 두 가지 옵션이 있으며, ALL 옵션은 중복되는 값을 제거하지 않는다. 반면
      DISTINCT 옵션은 중복되는 값을 제거한다. 옵션을 주지 않으면 ALL과 같이 동작한다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,1,2,3);
    tab2 kind_tab := kind_tab(1,1,2,4);
    result kind_tab;
BEGIN
    result := tab1 MULTISET INTERSECT ALL tab2;
END;</pre>

      <p>MULTISET INTERSECT에 의해 tab1과 tab2의 구성요소들 중 공통된 구성요소를 찾아 result
      테이블에 저장된다. 옵션은 ALL이므로 중복값을 제거하지 않아, 이 테이블은 1, 1, 2의 세 개 구성요소를
      갖는다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,1,2,3);
    tab2 kind_tab := kind_tab(1,1,2,4);
    result kind_tab;
BEGIN
    result := tab1 MULTISET INTERSECT tab2;
END;</pre>

      <p>ALL 혹은 DISTINCT 옵션을 사용하지 않은 경우 위 예제의 ALL 옵션과 동일하게 동작한다. result
      테이블은 1, 1, 2의 여섯 개 구성요소를 갖는다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,1,2,3);
    tab2 kind_tab := kind_tab(1,1,2,4);
    result kind_tab;
BEGIN
    result := tab1 MULTISET INTERSECT DISTINCT tab2;
END;</pre>

      <p>DISTINCT 옵션을 사용한 경우 MULTISET 연산자의 결과에서 중복된 구성요소는 제거된다. result 테이블은
      1, 2의 두 개 구성요소를 갖는다.</p>

      <div class="literallayout"><p/></div>

      <p>EXCEPT는 MULTISET 연산자의 앞 테이블에는 있으면서 뒤 테이블에는 없는 구성요소를 찾아 준다. 중복값의 제거
      여부를 옵션으로 결정할 수 있다. ALL과 DISTINCT의 두 가지 옵션이 있으며, ALL 옵션은 중복되는 값을 제거하지
      않는다. 반면 DISTINCT 옵션은 중복되는 값을 제거한다. 옵션을 주지 않으면 ALL과 같이 동작한다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,2,3,3);
    tab2 kind_tab := kind_tab(1,2,4,5);
    result kind_tab;
BEGIN
    result := tab1 MULTISET EXCEPT ALL tab2;
END;</pre>

      <p>MULTISET EXCEPT에 의해 tab1의 구성요소이면서 tab2의 구성요소는 아닌 값들만 result 테이블에
      저장된다. 옵션은 ALL이므로 중복값을 제거하지 않아, 이 테이블은 3, 3의 두 개 구성요소를 갖는다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,2,3,3);
    tab2 kind_tab := kind_tab(1,2,4,5);
    result kind_tab;
BEGIN
    result := tab1 MULTISET EXCEPT tab2;
END;</pre>

      <p>ALL 혹은 DISTINCT 옵션을 사용하지 않은 경우 위 예제의 ALL 옵션과 동일하게 동작한다. result
      테이블은 3, 3의 두 개 구성요소를 갖는다.</p>

      <pre class="programlisting">DECLARE
    TYPE kind_tab IS TABLE OF NUMBER;
    tab1 kind_tab := kind_tab(1,2,3,3);
    tab2 kind_tab := kind_tab(1,2,4,5);
    result kind_tab;
BEGIN
    result := tab1 MULTISET EXCEPT DISTINCT tab2;
END;</pre>

      <p>DISTINCT 옵션을 사용한 경우 MULTISET 연산자의 결과에서 중복된 구성요소는 제거된다. result 테이블은
      3의 한 개 구성요소를 갖는다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_index_by_table"/>4.2.2. 인덱스 테이블<a id="d5e2951" class="indexterm"/></h3></div></div></div>
      

      <p>인덱스 테이블은 키와 값이 합쳐진 구성요소를 갖는 테이블이다. 각각의 구성요소에 접근할 때에는 숫자 또는 문자열을
      이용하여 인덱스로 접근한다. 인덱스 테이블의 구성요소는 PLS_INTEGER, BINARY_INTERGER, VARCHAR2,
      STRING, LONG 타입이어야 한다.</p>

      <p><span>tbPSM</span>에서 인덱스 테이블을 선언하는 방법은 다음과 같다.</p>

      <pre class="programlisting">TYPE index_table1 OF PLS_INTEGER [NOT NULL] INDEX BY PLS_INTEGER;
TYPE index_table1 OF VARCHAR2(10) INDEX BY STRING(1);</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2959"/>인덱스 테이블의 사용</h4>

      <p>인덱스 테이블은 선언할 때 최대 크기의 제한이 없다. 인덱스 테이블의 크기는 인덱스가 동일하게 설정된 키에 값을
      삽입하는 경우 이전 값이 변경되므로 증가하지 않는다. 반면에 인덱스가 다르게 설정된 키에 값을 삽입하는 경우 인덱스 테이블의
      크기는 증가하게 된다.</p>

      <pre class="programlisting">DECLARE
  TYPE kind_tab IS TABLE OF NUMBER INDEX BY VARCHAR2(10);
  fruit_table kind_tab;  -- 과일 개수 테이블, 인덱스는 과일명
BEGIN
  fruit_table('apple'):= 10;
  fruit_table('orange'):= 100;
  fruit_table('strawberry'):= 35;
  fruit_table('pineapple'):= 80;
  fruit_table('watermelon'):= 20;
END;
/</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_composite_varray"/>4.2.3. 배열<a id="d5e2964" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">배열</strong></span>은 테이블과 달리 선언할 때 길이의 제한이 있다. 따라서 선언할 때 반드시
      길이를 지정해야 한다. 그리고 각각의 구성요소는 항상 연속적으로 존재하며, 구성요소에 접근할 때에는 인덱스로 한다.</p>

      <p>배열은 모든 구성요소가 서로 동일한 타입이어야 한다. REF CURSOR를 제외한 모든 타입이 될 수 있다. 또한
      배열을 구성요소 타입으로 갖는 배열을 선언할 수 있다.</p>

      <p><span>tbPSM</span>에서 배열을 선언하는 방법은 다음과 같다.</p>

      <pre class="programlisting">TYPE name IS VARRAY(limit) OF type [NOT NULL];</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2974"/>배열의 초기화</h4>

      <p>배열은 초기화라는 과정을 거치게 되는데, 이 과정을 거치지 않은 변수는 항상 NULL을 가지며, 구성요소도 존재하지
      않게 된다. 만약 초기화되지 않은 배열에 접근할 경우 <span><strong class="guibutton">COLLECTION_IS_NULL</strong></span>
      예외 상황이 발생한다.</p>

      <p>배열을 초기화하는 방법은 다음과 같다.</p>

      <pre class="programlisting">DECLARE
    TYPE class_arr IS VARRAY(10) OF VARCHAR2(10) NOT NULL;
    classes class_arr;
BEGIN
    classes := class_arr('math', 'physics', 'history', 'science');
END;</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2980"/>배열의 구성요소</h4>

      <p>배열은 선언할 때 지정한 길이가 구성요소의 최대 길이가 되므로, 초기화되지 않은 나머지 구성요소는 존재하지 않는 값이
      된다. 만약 초기화되지 않은 구성요소에 접근할 경우에는 <span><strong class="guibutton">BEYOND_SUBSCRIPT</strong></span>
      예외 상황이 발생한다. 만약 배열에서 NOT NULL 제약조건이 없을 경우에는 NULL을 구성요소로 사용할 수 있다.</p>

      <pre class="programlisting">DECLARE
    <span><strong class="guibutton">TYPE class_arr IS VARRAY(5) OF VARCHAR2(10);
    classes class_arr := class_arr('math', NULL, 'science');</strong></span>
BEGIN
    NULL;
END;</pre>

      <div class="literallayout"><p/></div>

      <p>배열의 구성요소는 하나의 독립적인 변수처럼 사용할 수 있으며, 해당 변수의 값을 추출할 수 있다. 또한 대입도
      가능하다.</p>

      <p>예를 들면 다음과 같다.</p>

      <pre class="programlisting">DECLARE
    TYPE class_arr IS VARRAY(10) OF VARCHAR2(10);
    classes class_arr := class_arr('math', 'physics', 'art');
BEGIN
    classes(3) := 'history';
    IF classes(1) IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('I hate this class');
    END IF;
    DBMS_OUTPUT.PUT_LINE(classes(3) || ' is my favorite class');
END;
/
history is my favorite class

PSM completed</pre>

      <div class="literallayout"><p/></div>

      <p>배열의 구성요소를 참조하기 위해서는 다음과 같이 사용해야 한다.</p>

      <pre class="programlisting">varray_name(index)</pre>

      <p>index에는 1 ~ 2^31 - 1 사이의 값만을 사용할 수 있다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
          <p>배열은 IS NULL 연산자와 등호 연산자만 사용할 수 있다. 대소 비교와 같은 일반적인 비교 연산은
          불가능하다.</p>
        </div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2997"/>4.2.4. 컬렉션 함수와 프러시저<a id="d5e2999" class="indexterm"/><a id="d5e3001" class="indexterm"/></h3></div></div></div>
      

      <p><span>tbPSM</span>은 컬렉션 타입을 쉽고 편하게 사용하기 위해 컬렉션 함수와 프러시저를
      제공한다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th align="left">이름</th><th>설명</th></tr></thead><tbody><tr><td align="left">컬렉션 함수</td><td align="left"><p><a href="chapter_composite.html#func_EXISTS" title="4.2.4. EXISTS 함수???TITLE???">EXISTS</a></p><p><a href="chapter_composite.html#func_COUNT" title="4.2.4. COUNT 함수???TITLE???">COUNT</a></p><p><a href="chapter_composite.html#func_LIMIT" title="4.2.4. LIMIT 함수???TITLE???">LIMIT</a></p><p><a href="chapter_composite.html#func_FIRST_LAST" title="4.2.4. FIRST, LAST 함수???TITLE??????TITLE???">FIRST, LAST</a></p><p><a href="chapter_composite.html#func_PRIOR_NEXT" title="4.2.4. PRIOR, NEXT 함수???TITLE??????TITLE???">PRIOR, NEXT</a></p></td><td>컬렉션 함수는 항상 반환값을 갖는다.</td></tr><tr><td align="left">프러시저</td><td align="left"><p><a href="chapter_composite.html#proc_EXTEND" title="4.2.4. EXTEND 프러시저???TITLE???">EXTEND</a></p><p><a href="chapter_composite.html#proc_TRIM" title="4.2.4. TRIM 프러시저???TITLE???">TRIM</a></p><p><a href="chapter_composite.html#proc_DELETE" title="4.2.4. DELETE 프러시저???TITLE???">DELETE</a></p></td><td>프러시저는 반환값을 갖지 않는다.</td></tr></tbody></table>
      </div>

      <p>컬렉션 함수와 프러시저를 초기화되지 않은 컬렉션 변수에 사용하는 경우
      <span><strong class="guibutton">COLLECTION_IS_NULL</strong></span> 예외 상황이 발생한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="func_EXISTS"/>EXISTS 함수<a id="d5e3043" class="indexterm"/></h4>

      <p>EXISTS 함수는 n-번째 구성요소의 존재 여부를 TRUE, FALSE로 반환한다. 이 값은 DELETE 프러시저에
      의해 달라질 수 있다.</p>

      <p>다음은 EXISTS 함수의 예이다.</p>

      <pre class="programlisting">DECLARE
    TYPE sunday_tab IS TABLE OF PLS_INTEGER;
    my_sunday sunday_tab := sunday_tab(2, 9, 16, 23, 30);
BEGIN
    IF my_sunday.EXISTS(2) THEN
        DBMS_OUTPUT.PUT_LINE('Second sunday is ' || my_sunday(2));
    END IF;
    my_sunday.DELETE(2);
    IF my_sunday.EXISTS(2) = false THEN
        DBMS_OUTPUT.PUT('Second sunday is disappeared....');
        DBMS_OUTPUT.PUT_LINE(' because of work');
    END IF;
    IF my_sunday.EXISTS(10) = false THEN
        DBMS_OUTPUT.PUT_LINE('Only 4 or 5 weeks in a month');
    END IF;
END;
/
Second sunday is 9
Second sunday is disappeared.... because of work
Only 4 or 5 weeks in a month

PSM completed</pre>

      <div class="literallayout"><p/></div>

      

      <h4><a id="func_COUNT"/>COUNT 함수<a id="d5e3050" class="indexterm"/></h4>

      <p>COUNT 함수는 컬렉션 변수의 구성요소 개수를 반환한다. 이 값은 DELETE 프러시저에 의해 달라질 수
      있다.</p>

      <p>다음은 COUNT 함수의 예이다.</p>

      <pre class="programlisting">DECLARE
    TYPE sunday_tab IS TABLE OF PLS_INTEGER;
    my_sunday sunday_tab := sunday_tab(2, 9, 16, 23, 30);
BEGIN
    DBMS_OUTPUT.PUT_LINE(my_sunday.COUNT);
    my_sunday.DELETE(2);
    DBMS_OUTPUT.PUT_LINE(my_sunday.COUNT);
END;
/
5
4

PSM completed</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="func_LIMIT"/>LIMIT 함수<a id="d5e3057" class="indexterm"/></h4>

      <p>LIMIT 함수는 컬렉션 타입에 따라 반환되는 값이 다르다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">컬렉션 타입</th><th>설명</th></tr></thead><tbody><tr><td align="left">테이블, 인덱스 테이블</td><td>구성요소의 길이 제한이 없으므로 NULL을 반환한다.</td></tr><tr><td align="left">배열</td><td>배열을 선언할 때 지정된 값이 반환된다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 LIMIT 함수의 예이다.</p>

      <pre class="programlisting">DECLARE
    TYPE sunday_tab IS TABLE OF PLS_INTEGER;
    TYPE monday_arr IS VARRAY(7) OF PLS_INTEGER;
    my_sunday sunday_tab := sunday_tab(2, 9, 16, 23, 30);
    my_monday monday_arr := monday_arr(3, 10, 17, 24, 31);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Limit of table = ' || my_sunday.LIMIT);
    DBMS_OUTPUT.PUT_LINE('Limit of varrary = ' || my_monday.LIMIT);
END;
/
Limit of table =
Limit of varrary = 7

PSM completed</pre>

      <div class="literallayout"><p/></div>

      

      <h4><a id="func_FIRST_LAST"/>FIRST, LAST 함수<a id="d5e3079" class="indexterm"/><a id="d5e3081" class="indexterm"/></h4>

      <p>FIRST 함수는 첫 번째 구성요소의 인덱스를 반환하고, LAST 함수는 마지막 구성요소의 인덱스를 반환한다. 이 값은
      DELETE 프러시저에 의해 달라질 수 있다.</p>

      <p>FIRST, LAST 함수는 컬렉션 타입에 따라 반환되는 값이 다르다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">컬렉션 타입</th><th>설명</th></tr></thead><tbody><tr><td align="left">인덱스 테이블</td><td><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>FIRST 함수 : 가장 낮은 키값을 갖는 테이블을 반환한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>LAST 함수 : 가장 높은 키값을 갖는 테이블을 반환한다.</p>
                  </li></ul></div></td></tr><tr><td align="left">배열</td><td><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>FIRST 함수 : 항상 1을 반환한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>LAST 함수 : 항상 COUNT 함수와 같은 값을 반환한다.</p>
                  </li></ul></div></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 FIRST, LAST 함수의 예이다.</p>

      <pre class="programlisting">DECLARE
    TYPE sunday_tab IS TABLE OF PLS_INTEGER;
    my_sunday sunday_tab := sunday_tab(2, 9, 16, 23, 30);
BEGIN
    DBMS_OUTPUT.PUT_LINE('First sunday is ' || my_sunday.FIRST());
    DBMS_OUTPUT.PUT_LINE('Last sunday is ' || my_sunday.LAST());
    my_sunday.DELETE(1);
    DBMS_OUTPUT.PUT_LINE('First sunday is ' || my_sunday.FIRST());
END;
/
First sunday is 1
Last sunday is 5
First sunday is 2

PSM completed</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="func_PRIOR_NEXT"/>PRIOR, NEXT 함수<a id="d5e3114" class="indexterm"/><a id="d5e3116" class="indexterm"/></h4>

      <p>PRIOR 함수는 n-번째 구성요소의 바로 앞에 구성요소 인덱스를 반환하고, NEXT 함수는 n-번째 구성요소의 바로
      다음의 구성요소 인덱스를 반환한다. 컬렉션 타입 중 인덱스 테이블은 키값의 순서에 따라 PRIOR, NEXT 함수의 값을
      반환한다. 이때 키값의 순서는 기본적으로 키값의 바이너리 값을 비교할 때 정해진다.</p>

      <div class="literallayout"><p/></div>

      <p>n의 값은 EXTEND, TRIM, DELETE 프러시저에 의해 달라질 수 있다. n의 값에 따라 각 함수는 반환하는
      값이 다음과 같이 다르다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="90" align="left"/><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">함수</th><th align="left">n의 값</th><th>반환값</th></tr></thead><tbody><tr><td rowspan="2" align="left">PRIOR</td><td align="left">n &lt; 1</td><td>NULL</td></tr><tr><td align="left">LAST보다 클 경우</td><td>항상 LAST 함수의 값을 반환한다.</td></tr><tr><td rowspan="2" align="left">NEXT</td><td align="left">n &lt; 1</td><td>1</td></tr><tr><td align="left">LAST보다 클 경우</td><td>NULL</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 PRIOR, NEXT 함수의 예이다.</p>

      <pre class="programlisting">DECLARE
    TYPE sunday_tab IS TABLE OF PLS_INTEGER;
    my_sunday sunday_tab := sunday_tab(2, 9, 16, 23, 30);
BEGIN
    DBMS_OUTPUT.PUT_LINE('First sunday is ' || my_sunday.PRIOR(2));
    DBMS_OUTPUT.PUT_LINE('Last sunday is ' || my_sunday.NEXT(1));
    my_sunday.DELETE(2);
    DBMS_OUTPUT.PUT_LINE('First sunday is ' || my_sunday.NEXT(1));
END;
/
First sunday is 1
Last sunday is 2
First sunday is 3

PSM completed</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="proc_EXTEND"/>EXTEND 프러시저<a id="d5e3150" class="indexterm"/></h4>

      <p>EXTEND 프러시저는 테이블이나 배열의 크기를 늘리기 위해 사용된다.</p>

      <p>사용하는 방법은 다음과 같이 세 가지가 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">방법</th><th>설명</th></tr></thead><tbody><tr><td align="left">EXTEND</td><td>하나의 NULL 구성요소를 추가한다.</td></tr><tr><td align="left">EXTEND(n)</td><td>n개의 NULL 구성요소를 추가한다.</td></tr><tr><td align="left">EXTEND(m, n)</td><td>n번째 구성요소를 m개 추가한다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 EXTENT 프러시저의 예이다.</p>

      <pre class="programlisting">DECLARE
    TYPE sunday_tab IS TABLE OF PLS_INTEGER;
    my_sunday sunday_tab := sunday_tab(2, 9, 16, 23, 30);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Before extend = ' || my_sunday.COUNT);
    my_sunday.EXTEND(4, 2);
    DBMS_OUTPUT.PUT_LINE('After extend = ' || my_sunday.COUNT);
END;
/
Before extend = 5
After extend = 9

PSM completed</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="proc_TRIM"/>TRIM 프러시저<a id="d5e3176" class="indexterm"/></h4>

      <p>TRIM 프러시저는 배열이나 테이블의 크기를 줄이기 위해 사용된다.</p>

      <p>사용하는 방법은 다음과 같이 두 가지가 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">방법</th><th>설명</th></tr></thead><tbody><tr><td align="left">TRIM</td><td>뒤에서부터 하나의 구성요소를 제거한다.</td></tr><tr><td align="left">TRIM(n)</td><td><p>뒤에서부터 n개의 구성요소를 제거한다.</p><p>만약 n의 크기가 큰 경우에는
              SUBSCRIPT_BEYOND_COUNT<a id="d5e3196" class="indexterm"/> 예외 상황이 발생한다.</p></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 TRIM 프러시저의 예이다.</p>

      <pre class="programlisting">DECLARE
    TYPE sunday_tab IS TABLE OF PLS_INTEGER;
    my_sunday sunday_tab := sunday_tab(2, 9, 16, 23, 30);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Before trim = ' || my_sunday.COUNT);
    my_sunday.TRIM(2);
    DBMS_OUTPUT.PUT_LINE('After trim = ' || my_sunday.COUNT);
END;
/
Before trim = 5
After trim = 3

PSM completed</pre>

      <div class="literallayout"><p/></div>

      <h4><a id="proc_DELETE"/>DELETE 프러시저<a id="d5e3203" class="indexterm"/></h4>

      <p>DELETE 프러시저는 특정 인덱스의 구성요소를 제거하거나 전체 구성요소를 제거하기 위해 사용된다.</p>

      <p>사용하는 방법은 다음과 같이 세 가지가 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">방법</th><th>설명</th></tr></thead><tbody><tr><td align="left">DELETE</td><td>전체 구성요소를 제거한다.</td></tr><tr><td align="left">DELETE(n)</td><td><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>테이블 : 테이블에서 n번째 구성요소를 제거한다.</p>
                  </li><li style="list-style-type: circle">
                    <p>인덱스 테이블 : 키값이 n인 값을 제거한다.</p>
                  </li></ul></div></td></tr><tr><td align="left">DELETE(m, n)</td><td><p>테이블 또는 인덱스 테이블에서 m부터 n까지의 구성요소를 제거한다.
              </p><p>m이 n보다 크거나 m과 n 중 하나라도 NULL이면 어떠한 값도 제거되지
              않는다.</p></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 DELETE 프러시저의 예이다.</p>

      <pre class="programlisting">DECLARE
    TYPE sunday_tab IS TABLE OF PLS_INTEGER;
    my_sunday sunday_tab := sunday_tab(2, 9, 16, 23, 30);
BEGIN
    my_sunday.delete(2, 4);
    IF my_sunday.EXISTS(2) THEN
        DBMS_OUTPUT.PUT_LINE('Second sunday is ' || my_sunday(2));
    END IF;
END;
/

PSM completed
</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3234"/>4.2.5. 예외 상황</h3></div></div></div>
      

      <p>컬렉션 타입과 관련된 예외 상황을 정리하면 다음과 같다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="220" align="left"/><col/></colgroup><thead><tr><th align="left">예외 상황</th><th>발생 조건</th></tr></thead><tbody><tr><td align="left">COLLECTION_IS_NULL<a id="d5e3247" class="indexterm"/></td><td>초기화되지 않은 컬렉션 변수에 접근하는 경우</td></tr><tr><td align="left">NO_DATA_FOUND<a id="d5e3253" class="indexterm"/></td><td>DELETE 프러시저에 의해 제거된 구성요소에 접근하는 경우 또는 인덱스 테이블에 존재하지 않는 값에
              접근하는 경우</td></tr><tr><td align="left">SUBSCRIPT_BEYOND_COUNT<a id="d5e3259" class="indexterm"/></td><td>인덱스가 구성요소의 개수를 초과한 값으로 주어진 경우</td></tr><tr><td align="left">SUBSCRIPT_OUSIDE_LIMIT<a id="d5e3265" class="indexterm"/></td><td>인덱스가 허용 범위를 벗어난 경우</td></tr><tr><td align="left">VALUE_ERROR<a id="d5e3271" class="indexterm"/></td><td>인덱스가 NULL이거나 숫자의 형태로 변환이 안 되는 경우</td></tr></tbody></table>
      </div>

      <p/>

      
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_composite_record"/>4.3. 레코드<a id="d5e3278" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">레코드</strong></span>는 관련 있는 구성요소의 집합인데, 일반적인 프로그래밍 언어의 구조체와
    동일하다. 레코드에 소속된 모든 구성요소의 타입이 서로 같을 필요가 없다. 또한 필드가 다시 레코드를 포함할 수도 있다.</p>

    <p>레코드는 주로 데이터베이스 테이블의 로우 전체를 저장하기 위해 사용된다. <a href="chapter_03.html#sect_etctype" title="2.2.5. 기타 타입">“2.2.5. 기타 타입”</a>에서 설명한 내용 중에서 <span><strong class="guibutton">%ROWTYPE</strong></span>은
    레코드의 대표적인 예이다.</p>

    <div class="literallayout"><p/></div>

    <p>레코드를 선언하는 방법은 다음과 같다.</p>

    <pre class="programlisting">TYPE rec_name IS 
    RECORD (field1 field1_type[, field2 field2_type...]);</pre>

    <div class="literallayout"><p/></div>

    <p>레코드는 일반적으로 다음과 같은 특성이 있다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>레코드는 컬렉션 타입과 달리 초기화 과정이 필요 없다.</p>
      </li><li>
        <p>선언과 동시에 메모리가 할당되어 각각의 필드에 직접 접근할 수 있다.</p>
      </li><li>
        <p>레코드 변수는 소속된 필드의 타입이 모두 같을 경우에만 대입할 수 있다.</p>
      </li><li>
        <p>레코드 내부에 포함된 각 필드는 일반적인 변수와 동일하게 취급된다.</p>
      </li><li>
        <p>레코드는 NULL의 허용 여부뿐만 아니라 등호, 부등호 등의 비교가 불가능하다.</p>

        <p>만약 이러한 비교가 필요하다면, 두 개의 레코드를 파라미터로 전달 받아 필드를 직접 비교하는 함수를 작성해야
        한다.</p>
      </li></ul></div>

    <div class="literallayout"><p/></div>

    <p>다음은 레코드 선언의 예이다.</p>

    <pre class="programlisting">DECLARE
    music_info musics%ROWTYPE;
BEGIN
    SELECT * INTO music_info FROM musics WHERE kind = 'POP';
    DBMS_OUTPUT.PUT_LINE(music_info.title);
END;</pre>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_dml_with_record"/>4.4. 레코드 타입 변수의 DML<a id="d5e3307" class="indexterm"/></h2></div></div></div>
    

    <p>레코드는 테이블의 로우와 유사한 형태를 갖는다. 이러한 특징으로 PSM에서는 DML 문에서 특별한 문법을 사용할수 있는데,
    켐코드 타입의 변수를 DML에 사용하여 ROW를 삽입 또는 변경 가능하다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>문법</p>

        <div class="informalfigure">
          <div xmlns="" class="mediaobject"><img src="resources/insert_record.png"/></div>
        </div>

        <div class="informalfigure">
          <div xmlns="" class="mediaobject"><img src="resources/update_setrow.png"/></div>
        </div>

        <div class="informalfigure">
          <div xmlns="" class="mediaobject"><img src="resources/record_type_variable.png"/></div>
        </div>
      </li><li>
        <p>예제</p>

        <pre class="programlisting">create table student (id varchar(16), name varchar(16), grade varchar(2));

declare
    new_student student%rowtype;
    modify_student student%rowtype;
begin
    /* 1학년 학생 입학 */
    new_student.id      := '00000001';
    new_student.name    := 'studentname1';
    new_student.grade   := '1';
    insert into student values new_student;
    commit;

    /* 학생 진급 */
    modify_student.id      := '00000001';
    modify_student.name    := 'studentname1';
    modify_student.grade   := '2';
    update student set row = modify_student where id = modify_student.id;
    commit;
end;
/

select * from student;

ID               NAME             GRADE
---------------- ---------------- -----
00000001         studentname1     2

1 row selected.</pre>
      </li></ul></div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_control.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_subprogram.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제3장 제어 구조 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제5장 서브 프로그램</td></tr></table></div><div xmlns="" align="center"/></body></html>