<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제5장 서브 프로그램</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbPSM 안내서"/><link rel="up" href="index.html" title="Tibero tbPSM 안내서"/><link rel="prev" href="chapter_composite.html" title="제4장 복합 타입"/><link rel="next" href="chapter_package.html" title="제6장 패키지"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제5장 서브 프로그램</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_composite.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_package.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_subprogram"/>제5장 서브 프로그램</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_subprogram.html#d5e3337">5.1. 개요</a></span></dt><dt><span class="section"><a href="chapter_subprogram.html#d5e3356">5.2. 서브 프로그램의 구분</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_subprogram.html#d5e3359">5.2.1. 프러시저</a></span></dt><dt><span class="section"><a href="chapter_subprogram.html#d5e3390">5.2.2. 함수</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_subprogram.html#d5e3411">5.3. 서브 프로그램의 파라미터</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_subprogram.html#d5e3413">5.3.1. 파라미터</a></span></dt><dt><span class="section"><a href="chapter_subprogram.html#d5e3434">5.3.2. 파라미터 모드</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_subprogram.html#d5e3484">5.4. 중복 선언</a></span></dt><dt><span class="section"><a href="chapter_subprogram.html#d5e3506">5.5. 정의자 권한과 호출자 권한</a></span></dt></dl></div>
  

  <p>본 장에서는 서브 프로그램을 작성하는 방법을 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3337"/>5.1. 개요</h2></div></div></div>
    

    <p><span><strong class="guibutton">서브 프로그램</strong></span>(subprogram)은 다른 <span>tbPSM</span> 프로그램 내에서 호출할 수 있는 프로그램 블록이다. 서브 프로그램을 호출할
    때에는 해당 서브 프로그램 내에서 사용할 파라미터를 함께 전달해야 한다.<a id="d5e3342" class="indexterm"/></p>

    <p>서브 프로그램의 실행이 모두 끝나면 해당 서브 프로그램을 호출한 뒷부분부터 프로그램의 실행은 계속된다. 서브 프로그램은
    항상 이름을 가져야 하며, 서브 프로그램 내에서 또 다른 서브 프로그램을 호출할 수 있다.</p>

    <p>서브 프로그램을 이용함으로써 얻을 수 있는 장점은 다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>모듈성(modularity)</p>

        <p>기능별로 각각의 모듈로 분리하여 프로그램을 작성할 수 있다. 이러한 모듈은 복잡한 모듈이 될 수도 있고 작은 모듈일
        수도 있다.</p>
      </li><li>
        <p>재사용성(reusability), 관리의 편의성(maintainability)</p>

        <p>서브 프로그램은 정해진 특정 기능을 수행하므로, 동일한 기능을 필요로 하는 여러 프로그램에서 해당 서브 프로그램을
        공통적으로 이용할 수 있다. 재사용성은 관리의 편의성(maintainability)을 의미하기도 한다.</p>
      </li><li>
        <p>추상화(abstraction)</p>

        <p>기능이 같다면 서브 프로그램 내부를 변경하더라도 프로그램 전체에 영향을 주지 않는다. 즉, 인터페이스에 변화가
        없으며 문제가 발생되지 않는다.</p>
      </li></ul></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3356"/>5.2. 서브 프로그램의 구분</h2></div></div></div>
    

    <p>서브 프로그램은 결과 값의 반환 여부에 따라 프러시저(procedure)와 함수(function)로 구분된다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3359"/>5.2.1. 프러시저<a id="d5e3361" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">프러시저</strong></span>는 함수와는 다르게 반환값이 없다.</p>

      <p>프러시저를 선언하는 방법은 다음과 같다.</p>

      <pre class="programlisting">[CREATE [OR REPLACE]] PROCEDURE <span><strong class="guibutton">프러시저_이름</strong></span> [(파라미터[, 파라미터])] 
    [AUTHID {DEFINER | CURRENT_USER}] {AS | IS}
[PRAGMA AUTONOMOUS_TRANSACTION;]
[선언부]
BEGIN
[실행부]
[예외 처리부]
END;</pre>

      <p>프러시저는 한 개 이상의 파라미터를 가질 수 있으며, 두 개 이상의 파라미터를 갖는 경우 각 파라미터는 콤마(,)로
      분리하여 사용한다.</p>

      <p><span><strong class="guibutton">프러시저_이름</strong></span>과 동일한 이름을 갖는 프러시저가 이미 존재하는 경우에도
      <span><strong class="guibutton">OR REPLACE</strong></span> 문이 삽입된 경우 해당 프러시저를 생성할 수 있다. 또한 동일한
      이름을 갖는 프러시저가 이미 존재하는 경우 프러시저의 내용은 새롭게 작성된 프러시저의 내용으로 갱신된다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 새로운 직원 정보를 EMP 테이블에 삽입하는 프러시저이다.</p>

      <pre class="programlisting">CREATE OR REPLACE PROCEDURE NEW_EMP (<span><strong class="guibutton">ename VARCHAR2, deptno NUMBER</strong></span>) <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
IS
    <span><strong class="guibutton">salary</strong></span> NUMBER;
    <span><strong class="guibutton">deptno_not_found EXCEPTION;</strong></span>
BEGIN
    IF deptno = 5 THEN
        salary := 30000;
    ELSIF deptno = 6 THEN
        salary := 35000;
    ELSE
        <span><strong class="guibutton">RAISE deptno_not_found;</strong></span>                                    <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
    END IF;

    <span><strong class="guibutton">INSERT INTO EMP (ENAME, SALARY, DEPTNO)</strong></span>                        <em class="lineannotation"><span class="lineannotation">... ③ ...</span></em>
        <span><strong class="guibutton">VALUES (ename, salary, deptno);</strong></span>
EXCEPTION
WHEN deptno_not_found THEN
    -- Report Unknown Deptno
    <span><strong class="guibutton">ROLLBACK;</strong></span>                                                      <em class="lineannotation"><span class="lineannotation">... ④ ...</span></em>
END NEW_EMP;</pre>

      <p>① 두 개의 입력 파라미터를 받는다.</p>

      <p>② 입력된 부서 번호에 따라 봉급(salary)을 결정하고, 만약 미리 정해진 부서 번호가 아니면 예외 상황을
      발생시킨다. 사용자가 정의한 예외 상황을 발생시키는 것은 RAISE 문을 이용한다. 이때 사용자가 정의한 예외 상황은 선언부에
      미리 정의되어 있어야 한다.</p>

      <p>③ 봉급이 결정되면 EMP 테이블에 새로운 로우를 삽입한다.</p>

      <p>④ 프러시저를 종료한다. 프러시저 또는 함수의 맨 마지막에 COMMIT 또는 ROLLBACK 문을 포함시킨다. 단,
      하나의 트랜잭션에서 여러 프러시저나 함수를 호출하는 경우에는 모든 프러시저와 함수를 호출한 후에 커밋 또는 롤백을 수행해야
      한다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3390"/>5.2.2. 함수<a id="d5e3392" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">함수</strong></span>는 프러시저와는 다르게 반환값이 있다. 따라서
      <span><strong class="guibutton">RETUN 문</strong></span>이 반드시 삽입되어야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>함수를 선언하는 방법은 다음과 같다.</p>

      <pre class="programlisting">[CREATE [OR REPLACE]] FUNCTION 함수_이름 [(파라미터[, 파라미터])] 
RETURN 반환_타입 [AUTHID {DEFINER | CURRENT_USER}] {AS | IS}
    [PRAGMA AUTONOMOUS_TRANSACTION;]
    [선언부]
BEGIN
    [실행부]
    RETURN 반환값;
    [예외 처리부]
END;</pre>

      <p>RETURN 문 다음에는 함수의 선언부에서 해당 함수가 반환할 값의 데이터 타입을 미리 지정해야 한다.</p>

      <p>만약 예외 처리부가 있는 경우에는 예외 처리부가 시작하기 직전에 반환할 값을 입력하고, 예외 처리부가 없는 경우에는
      실행부의 마지막에 반환할 값을 입력한다.</p>

      <p>다음은 함수의 예이다. salary 값을 반환하는 NEW_EMP 함수이다.</p>

      <pre class="programlisting"><span><strong class="guibutton">CREATE OR REPLACE FUNCTION NEW_EMP</strong></span> (ename VARCHAR, deptno INT) <span><strong class="guibutton">
RETURN NUMBER IS</strong></span>     <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
    ...
BEGIN
    ...
    <span><strong class="guibutton">RETURN salary;</strong></span>   <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
EXCEPTION
    ...
END NEW_EMP;</pre>

      <p>① 반환값의 데이터 타입을 선언한다.</p>

      <p>② RETURN 문장을 포함한다.</p>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3411"/>5.3. 서브 프로그램의 파라미터</h2></div></div></div>
    

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3413"/>5.3.1. 파라미터</h3></div></div></div>
      

      <p>실제 파라미터의 값은 프러시저가 호출될 때 프러시저에 전달되며, 프러시저 내에서 형식 파라미터를 사용하여 참조된다.
      이때 값뿐만 아니라 변수에 대한 제한도 함께 전달된다.</p>

      <p>프러시저의 내부에 선언된 변수는 다른 프러시저의 인수로 전달된다. 이를 <span><strong class="guibutton">실제
      파라미터</strong></span>라고 한다. 또한 프러시저의 인수 부분에 선언된 파라미터는 <span><strong class="guibutton">형식
      파라미터</strong></span>라고 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p><span><strong class="guibutton">실제 파라미터<a id="d5e3424" class="indexterm"/></strong></span></p>

            <p>실제 파라미터는 호출될 때 프러시저에 전달되는 값을 포함하고, 반환할 때 프러시저로부터 결과를 받는다. 실제
            파라미터의 값은 프러시저에서 사용될 값이다.</p>
          </li><li>
            <p><span><strong class="guibutton">형식 파라미터<a id="d5e3430" class="indexterm"/></strong></span></p>

            <p>형식 파라미터는 실제 파라미터의 값에 대한 위치 지정자이다. 프러시저가 호출될 때 형식 파라미터는 실제
            파라미터의 값을 할당 받고, 프러시저 내에서 형식 파라미터에 의해 참조된다. 프러시저가 호출될 때 실제 파라미터는 형식
            파라미터의 값을 할당 받는다. 이 할당은 필요하다면 타입 변환을 실행한다.</p>
          </li></ul></div>

      <p>프러시저를 선언할 때는 형식 파라미터의 데이터 타입에 대한 제한이 없다. 데이터 타입에 대한 제한은 실제 프로그램
      내에서 선언한 프러시저를 사용할 때 명시한다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3434"/>5.3.2. 파라미터 모드<a id="d5e3436" class="indexterm"/></h3></div></div></div>
      

      <p>형식 파라미터는 다음과 같이 4개의 모드를 제공한다. 만약 모드를 지정하지 않으면 디폴트는 IN 모드로
      선언된다.</p>

      <p>다음은 각 모드에 대한 설명이다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">모드</th><th>설명</th></tr></thead><tbody><tr><td align="left"><p>IN 모드<a id="d5e3451" class="indexterm"/></p></td><td><p>실제 파라미터의 값은 프러시저가 호출될 때 프러시저에
              전달한다.</p><p>프러시저 내에서 형식 파라미터는 읽기 전용으로 간주된다. 즉, 값을 변경할 수
              없다는 뜻이다. 프러시저가 끝나고 제어가 호출 환경에 반환될 때 실제 파라미터는 변경되지
              않는다.</p></td></tr><tr><td align="left"><p>OUT 모드<a id="d5e3460" class="indexterm"/></p></td><td><p>프러시저가 호출될 때 실제 파라미터가 가지는 값은 무시된다.</p><p>프러시저
              내에서 형식 파라미터는 쓰기 전용으로 간주된다. 즉, 할당만 될 수 있고 읽을 수는 없다. 프러시저가 끝나고 제어가
              호출 환경에 반환될 때 형식 파라미터의 내용은 실제 파라미터에 전달된다.</p></td></tr><tr><td align="left"><p>INOUT 모드<a id="d5e3469" class="indexterm"/></p></td><td><p>IN 모드와 OUT 모드의 조합이다. 실제 파라미터의 값은 프러시저가 호출될 때 프러시저에
              전달한다.</p><p>프러시저 내에서 형식 파라미터는 읽거나 쓸 수 있다. 프러시저가 끝나고 제어가 호출
              환경에 반환될 때 형식 파라미터의 내용은 실제 파라미터에 할당된다.</p></td></tr><tr><td align="left"><p>NOCOPY 모드<a id="d5e3478" class="indexterm"/></p></td><td><p>실제 파라미터가 형식 파라미터에 전달될 때 복사 여부를
              결정한다.</p><p>NOCOPY 모드가 선언된 경우에는 복사하지 않고, 단순히
              참조(reference)만 하므로 서브 프로그램의 호출 속도를 높일 수 있다. 단, OUT 모드 또는 IN OUT
              모드에만 사용할 수 있다.</p></td></tr></tbody></table>
      </div>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3484"/>5.4. 중복 선언<a id="d5e3486" class="indexterm"/></h2></div></div></div>
    

    <p><span>tbPSM</span>에서는 서브 프로그램의 이름을 중복 선언(Overloading)하는 것을
    허용한다. 단, 다음과 같은 몇 가지 제약조건이 있다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>중복 선언은 패키지 내의 서브 프로그램이나 선언부에 정의된 서브 프로그램 사이에서만 가능하다.</p>
      </li><li>
        <p>파라미터의 이름만 다른 경우에는 중복 선언을 할 수 없다.</p>
      </li><li>
        <p>파라미터의 모드만 다른 경우에는 중복 선언을 할 수 없다.</p>
      </li><li>
        <p>파라미터의 서브타입만 다른 경우에는 중복 선언을 할 수 없다.</p>
      </li><li>
        <p>함수에서 반환값의 타입만 다른 경우에는 중복 선언을 할 수 없다.</p>
      </li></ul></div>

    <div class="literallayout"><p/></div>

    <p>다음은 중복 선언의 예이다.</p>

    <pre class="programlisting">DECLARE
    PROCEDURE compute_mass(age NUMBER, name VARCHAR2) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Type of age is NUMBER');
    END;
    PROCEDURE compute_mass(age DATE, name VARCHAR2) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Type of age is DATE');
    END;
BEGIN
    compute_mass(24, '<span>Tibero</span>');                 -- 첫 번째 프러시저 호출
    compute_mass(date '2010/10/24', '<span>Tibero</span>');  -- 두 번째 프러시저 호출
END;
/
Type of age is NUMBER
Type of age is DATE

PSM completed
SQL&gt;</pre>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3506"/>5.5. 정의자 권한과 호출자 권한</h2></div></div></div>
    

    <p><span>tbPSM</span>에서는 다음과 같이 두 개의 권한을 정의하고 있다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p><span><strong class="guibutton">정의자 권한</strong></span>(Definer's Rights)<a id="d5e3514" class="indexterm"/></p>

        <p>서브 프로그램이 처음 정의될 때 해당 스키마(schema)가 가진 권한으로 항상 수행되며, 그 스키마가 소유한
        객체만 볼 수 있다. 따라서 항상 같은 스키마에 같은 객체를 보게 된다.</p>
      </li><li>
        <p><span><strong class="guibutton">호출자 권한</strong></span>(Invoker's Rights)<a id="d5e3520" class="indexterm"/></p>

        <p>서브 프로그램을 수행하는 주최자(또는 호출자)의 스키마가 가진 권한으로 수행되며, 호출자가 소유한 스키마의 객체만
        볼 수 있다.</p>

        <p>호출자 권한으로 정의한 경우 다음과 같은 장점이 있다.</p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>프로그램의 유연성</p>

            <p>소스 코드를 재사용할 수 있어 하나의 프로그램으로 여러 사용자에게 프로그래밍의 유연성을 제공할 수
            있다.</p>
          </li><li>
            <p>중요한 데이터 보호</p>

            <p>중요한 정보에 접근하는 프로그램은 정의자 권한으로 생성하고, 다시 이 프로그램을 호출자 권한으로 생성하면
            다수의 사용자로부터 중요한 데이터를 보호할 수 있다.</p>
          </li></ul></div>
      </li></ul></div>

    <p>정의자 권한으로 선언할 때에는 AUTHID 절에 <span><strong class="guibutton">DEFINER</strong></span>를 정의하고, 호출자
    권한으로 선언할 때에는 <span><strong class="guibutton">CURRENT_USER</strong></span>로 정의한다.<a id="d5e3534" class="indexterm"/> <a id="d5e3536" class="indexterm"/></p>

    <p>예를 들면 다음과 같이 선언한다.</p>

    <pre class="programlisting">CREATE PROCEDURE count_total_days_per_year(year NUMBER) 
AUTHID <span><strong class="guibutton">{CURRENT_USER | DEFINER}</strong></span> IS
   ....
BEGIN
   ....
END;</pre>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_composite.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_package.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제4장 복합 타입 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제6장 패키지</td></tr></table></div><div xmlns="" align="center"/></body></html>