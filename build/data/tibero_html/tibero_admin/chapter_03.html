<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제3장 파일과 데이터 관리</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero 관리자 안내서"/><link rel="up" href="index.html" title="Tibero 관리자 안내서"/><link rel="prev" href="chapter_01.html" title="제2장 관리의 기본"/><link rel="next" href="chapter_04.html" title="제4장 스키마 객체 관리"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제3장 파일과 데이터 관리</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_01.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_04.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_03"/>제3장 파일과 데이터 관리</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_03.html#sect_file_ts">3.1. 데이터 저장 구조</a></span></dt><dt><span class="section"><a href="chapter_03.html#d5e2414">3.2. 테이블 스페이스</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_03.html#d5e2421">3.2.1. 테이블 스페이스 구성</a></span></dt><dt><span class="section"><a href="chapter_03.html#d5e2478">3.2.2. 테이블 스페이스 생성, 제거</a></span></dt><dt><span class="section"><a href="chapter_03.html#d5e2537">3.2.3. 테이블 스페이스 변경</a></span></dt><dt><span class="section"><a href="chapter_03.html#d5e2594">3.2.4. 테이블 스페이스 정보 조회</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_03.html#sect_lf">3.3. 로그 파일</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_03.html#d5e2702">3.3.1. 로그 파일 구성</a></span></dt><dt><span class="section"><a href="chapter_03.html#d5e2762">3.3.2. 로그 파일 생성, 제거</a></span></dt><dt><span class="section"><a href="chapter_03.html#d5e2834">3.3.3. 로그 파일 정보 조회</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_03.html#sect_cf">3.4. 컨트롤 파일</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_03.html#d5e2943">3.4.1. 컨트롤 파일 변경</a></span></dt><dt><span class="section"><a href="chapter_03.html#d5e2973">3.4.2. 컨트롤 파일 정보 조회</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 <span>Tibero</span>의 파일과 데이터를 관리하는 방법을 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_file_ts"/>3.1. 데이터 저장 구조</h2></div></div></div>
    

    <p><span>Tibero</span>의 데이터를 저장하는 구조는 다음과 같이 두 가지 영역으로
    나뉜다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>논리적 저장 영역</p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>데이터베이스의 스키마 객체를 저장하는 영역이다.</p>
          </li><li>
            <p>논리적 저장 영역은 다음과 같은 포함 관계가 있다.</p>

            <pre class="programlisting">데이터베이스 &gt; 테이블 스페이스 &gt; 세그먼트 &gt; 익스텐트</pre>
          </li></ul></div>
      </li><li>
        <p>물리적 저장 영역</p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>운영체제와 관련된 파일을 저장하는 영역이다.</p>
          </li><li>
            <p>물리적 저장 영역은 다음과 같은 포함 관계가 있다.</p>

            <pre class="programlisting">데이터 파일 &gt; 운영체제의 데이터 블록</pre>
          </li></ul></div>
      </li></ul></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2414"/>3.2. 테이블 스페이스<a id="d5e2416" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">테이블 스페이스</strong></span>는 논리적 저장 영역과 물리적 저장 영역에 공통적으로 포함된다.
    논리적 저장 영역에는 <span>Tibero</span>의 모든 데이터가 저장되며, 물리적 저장 영역에는 데이터 파일이
    하나 이상 저장된다. 테이블 스페이스는 논리적 저장 영역과 물리적 저장 영역을 연관시키기 위한 단위이다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2421"/>3.2.1. 테이블 스페이스 구성</h3></div></div></div>
      

      <p>테이블 스페이스는 크게 두 가지 구성으로 <span>Tibero</span>의 데이터를 저장한다.</p>

      <h4><a id="d5e2425"/>테이블 스페이스의 논리적 구성</h4>

      <p>테이블 스페이스는 세그먼트(Segment), 익스텐트(Extent), 데이터 블록(Block)으로
      구성된다.<a id="d5e2427" class="indexterm"/></p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">구성요소</th><th>설명</th></tr></thead><tbody><tr><td align="left">세그먼트<a id="d5e2439" class="indexterm"/></td><td>익스텐트의 집합이다. 하나의 테이블, 인덱스 등에 대응되는 것으로 CREATE TABLE 등의 문장을
              실행하면 생성된다.</td></tr><tr><td align="left">익스텐트<a id="d5e2444" class="indexterm"/></td><td>연속된 데이터 블록의 집합이다. 세그먼트를 처음 만들거나 세그먼트의 저장 공간이 더 필요한 경우
              <span>Tibero</span>는 테이블 스페이스에서 연속된 블록의 주소를 갖는
              데이터 블록을 할당 받아 세그먼트에 추가한다.</td></tr><tr><td align="left">데이터 블록<a id="d5e2450" class="indexterm"/></td><td>데이터베이스에서 사용하는 데이터의 최소 단위이다. <span>Tibero</span>는 데이터를 블록(Block) 단위로 저장하고
              관리한다.</td></tr></tbody></table>
      </div>

      <p>다음은 테이블 스페이스의 논리적 구성을 나타내는 그림이다.</p>

      <div class="figure"><a id="fig_tablespace_logical"/><p class="title"><b>[그림 3.1] 테이블 스페이스의 논리적 구성</b></p><div class="figure-contents">
        

        <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="585"><tr><td align="left"><img src="resources/tbadmin_1.png" align="top" width="585" alt="테이블 스페이스의 논리적 구성"/></td></tr></table></div>
      </div></div><br class="figure-break"/>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>논리적 저장 영역을 관리하는 방법에 대한 자세한 내용은 <a href="chapter_04.html" title="제4장 스키마 객체 관리">“제4장 스키마 객체 관리”</a>를
        참고한다.</p>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      <p/>

      <h4><a id="d5e2466"/>테이블 스페이스의 물리적 구성</h4>

      <p>테이블 스페이스는 물리적으로 여러 개의 데이터 파일로 구성된다. <span>Tibero</span>는 데이터 파일 외에도 컨트롤 파일과 로그 파일을 이용하여 데이터를 저장할 수 있다.</p>

      <p>빈번하게 사용되는 두 테이블 스페이스(예: 테이블과 인덱스)는 물리적으로 서로 다른 디스크에 저장하는 것이 좋다.
      왜냐하면 한 테이블 스페이스를 액세스하는 동안에 디스크의 헤드가 그 테이블 스페이스에 고정되어 있기 때문에 다른 테이블 스페이스를
      액세스할 수 없다. 따라서 서로 다른 디스크에 각각의 테이블 스페이스를 저장하여 동시에 액세스하는 것이 데이터베이스 성능을
      향상시키는 데 도움이 된다.</p>

      <p>다음은 테이블 스페이스의 물리적 구성을 나타내는 그림이다.</p>

      <div class="figure"><a id="fig_tablespace_physical"/><p class="title"><b>[그림 3.2] 테이블 스페이스의 물리적 구성</b></p><div class="figure-contents">
        

        <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="605"><tr><td align="left"><img src="resources/tbadmin_2.png" align="top" width="605" alt="테이블 스페이스의 물리적 구성"/></td></tr></table></div>
      </div></div><br class="figure-break"/>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>테이블 스페이스 안에서 특정한 데이터 파일을 사용할 수 있도록 임의로 지정할 수 없다. 또한 테이블 스페이스 내의
        모든 데이터 블록은 구분되지 않고 저장 공간에 할당된다.</p>
      </div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2478"/>3.2.2. 테이블 스페이스 생성, 제거</h3></div></div></div>
      

      <p>테이블 스페이스는 생성되는 유형에 따라 <span><strong class="guibutton">시스템 테이블 스페이스</strong></span>(System
      Tablespace)와 <span><strong class="guibutton">비시스템 테이블 스페이스</strong></span>(Non System
      Tablespace)로 구분된다.<a id="d5e2483" class="indexterm"/><a id="d5e2485" class="indexterm"/> 시스템 테이블 스페이스는 데이터베이스가 생성될 때 자동으로 생성되는 테이블 스페이스이며, 비시스템
      테이블 스페이스는 일반 사용자가 생성한 테이블 스페이스이다.</p>

      <p>본 절에서는 비시스템 테이블 스페이스를 생성하고 제거하는 방법을 설명한다.</p>

      <p/>

      <p/>

      <h4><a id="d5e2490"/>테이블 스페이스 생성</h4>

      <p>테이블 스페이스를 생성하기 위해서는 <span><strong class="guibutton">CREATE TABLESPACE</strong></span> 문을
      사용해야 한다. 테이블 스페이스의 이름, 테이블 스페이스에 포함되는 데이터 파일과 데이터 파일의 크기, 익스텐트의 크기 등을
      설정할 수 있다.<a id="d5e2493" class="indexterm"/></p>

      <p>다음은 하나의 데이터 파일 my_file.dtf로 구성되는 테이블 스페이스 my_space를 생성하는
      예이다.</p>

      <pre class="programlisting">CREATE TABLESPACE my_space
    DATAFILE '/usr/<span>tibero</span>/dtf/my_file.dtf' SIZE 50M
    EXTENT MANAGEMENT LOCAL UNIFORM SIZE 256K; </pre>

      <p>데이터 파일 my_file.dtf는 SQL 문장을 실행함과 동시에 생성된다. 만약 동일한 이름의 파일이 이미 사용
      중이라면, 에러를 반환하게 된다. 데이터 파일 my_file.dtf의 크기는 50MB이며, 테이블 스페이스의 크기도 50MB가
      된다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p><span>Tibero</span>에서는 데이터 파일마다 데이터 블록을 2^22개까지
        관리한다. 따라서 데이터 파일의 최대 크기는 "데이터 블록의 크기 * 2^22"이다. 예를 들어 데이터 블록의 크기가
        8KB라고 한다면 데이터 파일의 최대 크기는 32GB이다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p><span>Tibero</span>에서는 하나의 테이블 스페이스 내의 모든 익스텐트의 크기를 항상
      일정하게 관리한다. 예를 들어 하나의 익스텐트의 크기가 256KB이고, 데이터 블록의 크기가 4KB라고 한다면 하나의 익스텐트에는
      총 64개의 데이터 블록이 포함된다. 또한 하나의 테이블 스페이스를 두 개 이상의 데이터 파일로 구성할 수도 있다.</p>

      <p>예를 들면 다음과 같다.</p>

      <pre class="programlisting">CREATE TABLESPACE my_space2
    DATAFILE '/usr/<span>tibero</span>/dtf/my_file21.dtf' SIZE 20M,   <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
             '/usr/<span>tibero</span>/dtf/my_file22.dtf' SIZE 30M    <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
    EXTENT MANAGEMENT LOCAL UNIFORM SIZE 64K;            <em class="lineannotation"><span class="lineannotation">... ③ ...</span></em></pre>

      <p>① 20MB 크기의 데이터 파일 my_file21.dtf를 정의한다.</p>

      <p>② 30MB 크기의 데이터 파일 my_file22.dtf를 정의한다. 테이블 스페이스 my_space2의 전체 크기는
      총 50MB가 된다.</p>

      <p>③ 테이블 스페이스 my_space2는 하나의 익스텐트의 크기가 64KB로 설정한다.</p>

      <div class="literallayout"><p/></div>

      <p>하나의 테이블 스페이스에 포함되는 데이터 파일의 개수는 데이터베이스와 시스템 환경에 따라 달라진다. 하나의 테이블
      스페이스에 많은 데이터가 저장되면 여러 개의 데이터 파일로 테이블 스페이스를 생성해야 한다. 단, 운영체제에 따라 동시에 처리할
      수 있는 데이터 파일의 최대 개수가 달라질 수 있으므로 범위 내에서 데이터 파일의 개수를 조정해야 한다.</p>

      <p>데이터 파일의 크기는 데이터베이스의 크기를 추정하여 설정해야 한다. 테이블 스페이스를 생성할 때 설정된 크기보다 더
      많은 공간이 필요할 것에 대비하여 데이터 파일의 크기가 자동으로 확장되도록 설정할 수도 있다.</p>

      <p>다음은 CREATE TABLESPACE 문의 DATAFILE 절에 AUTOEXTEND 절을 추가하여 저장 공간이 더
      필요할 것에 대비하여 1MB씩 확장하도록 설정하는 예이다.</p>

      <pre class="programlisting">CREATE TABLESPACE my_space
    DATAFILE '/usr/<span>tibero</span>/dtf/my_file.dtf' SIZE 50M
    AUTOEXTEND ON NEXT 1M
    EXTENT MANAGEMENT LOCAL UNIFORM SIZE 256K;</pre>

      <p><span>Tibero</span>에서는 데이터 블록을 할당한 정보를 테이블 스페이스에 비트맵
      형태로 저장한다. 따라서 테이블 스페이스 내의 익스텐트의 최대 개수는 "테이블 스페이스의 크기 / 익스텐트의 크기"보다 작은 값이
      된다.</p>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e2524"/>테이블 스페이스 제거</h4>

      <p>테이블 스페이스를 제거하기 위해서는 <span><strong class="guibutton">DROP TABLESPACE</strong></span> 문을 사용해야
      한다. 단, 테이블 스페이스를 제거하면 그 안에 포함되어 있는 모든 스키마 객체가 제거되므로 주의해야 한다.<a id="d5e2527" class="indexterm"/></p>

      <p>다음은 테이블 스페이스를 제거하는 예이다.</p>

      <pre class="programlisting">DROP TABLESPACE my_space;</pre>

      <p>이 SQL 문장을 실행하면 데이터베이스에서 테이블 스페이스는 제거되지만 테이블 스페이스를 구성하는 데이터 파일은
      삭제되지 않는다. 데이터 파일까지 제거하려면 다음과 같이 <span><strong class="guibutton">INCLUDING</strong></span> 절을 삽입하여
      DROP TABLESPACE 문을 실행해야 한다.</p>

      <pre class="programlisting">DROP TABLESPACE my_space INCLUDING CONTENTS AND DATAFILES;</pre>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>테이블 스페이스를 생성하거나 제거하면 그러한 내용이 컨트롤 파일에 동시에 반영된다. CREATE
        TABLESPACE, DROP TABLESPACE 문에 대한 자세한 내용은 "<span>Tibero</span> SQL 참조 안내서"를 참고한다.</p>
      </div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2537"/>3.2.3. 테이블 스페이스 변경</h3></div></div></div>
      

      <p>테이블 스페이스의 저장 공간이 더 필요한 경우 데이터 파일이 자동으로 확장하도록 설정하는 방법도 있지만
      <span><strong class="guibutton">ALTER TABLESPACE</strong></span> 문에서 <span><strong class="guibutton">ADD
      DATAFILE</strong></span> 절을 삽입하여 새로운 데이터 파일을 테이블 스페이스에 추가하는 방법도
      있다.<a id="d5e2542" class="indexterm"/></p>

      <p>다음은 테이블 스페이스 my_space에 새로운 데이터 파일 my_file02.dtf를 추가하는 예이다.</p>

      <pre class="programlisting">ALTER TABLESPACE my_space ADD DATAFILE 'my_file02.dtf' SIZE 20M;</pre>

      <p>데이터 파일을 추가할 때 위의 예처럼 절대 경로를 명시하지 않으면 디폴트로 설정된 디렉터리에 데이터 파일이 생성된다.
      이때 생성되는 데이터 파일의 개수는 하나 이상이 될 수 있으며, 각 데이터 파일에 대한 크기를 자동으로 확장하도록 설정할 수
      있다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>데이터 파일의 절대 경로를 명시하지 않았을 때 디폴트로 생성되는 위치는 초기화 파라미터 파일($<span>TB_</span>HOME/config/$<span>TB_</span>SID.tip)에 설정된 DB_CREATE_FILE_DEST이다. 단,
        해당 파라미터가 정의되지 않았으면 디폴트 위치는 $<span>TB_</span>HOME/database/$<span>TB_</span>SID이다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>또한 데이터 파일은 ALTER DATABASE 문을 통해 크기를 변경할 수도 있다. ALTER DATABASE 문을
      사용하면 데이터 파일의 크기를 늘리거나 줄이는 것이 모두 가능하다. 단, 데이터 파일의 크기를 줄이는 경우 데이터 파일 안에
      저장되어 있는 스키마 객체의 전체 크기보다 작을 경우에는 에러가 발생된다.</p>

      <p>다음은 데이터 파일 my_file01.dtf의 크기를 변경하는 예이다.</p>

      <pre class="programlisting">ALTER DATABASE DATAFILE 'my_file01.dtf' RESIZE 100M;</pre>

      <div class="literallayout"><p/></div>

      <p>특정 테이블 스페이스에 읽고 쓰는 모든 접근을 허용하지 않으려면 ALTER TABLESPACE 문에서
      <span><strong class="guibutton">OFFLINE</strong></span> 절을 이용하여 테이블 스페이스를 오프라인 상태로 변경하면
      된다.</p>

      <p>테이블 스페이스 오프라인은 NORMAL과 IMMEDIATE 두 가지 모드를 지원한다.<a id="d5e2561" class="indexterm"/></p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">모드</th><th>설명</th></tr></thead><tbody><tr><td align="left">NORMAL<a id="d5e2573" class="indexterm"/></td><td>체크포인트를 수행한 후 테이블 스페이스 오프라인을 수행한다. 향후 테이블 스페이스 온라인을 수행할 때
              미디어 복구가 필요없다.</td></tr><tr><td align="left">IMMEDIATE<a id="d5e2579" class="indexterm"/></td><td>체크포인트를 수행하지 않고 테이블 스페이스 오프라인을 수행한다. 향후 테이블 스페이스 온라인을 수행할
              때 미디어 복구가 필요하다. 따라서 ARCHIVELOG 모드에서만 가능하다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 테이블 스페이스 my_space를 NORMAL 모드로 오프라인 상태로 만든 후 다시 온라인 상태로 만드는
      예이다.</p>

      <pre class="programlisting">ALTER TABLESPACE my_space OFFLINE [NORMAL]; 
ALTER TABLESPACE my_space ONLINE;</pre>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>SYSTEM, UNDO, TEMP 테이블 스페이스는 오프라인 상태로 변경할 수 없다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 테이블 스페이스 my_space를 IMMEDIATE 모드로 오프라인 상태로 만든 후 미디어 복구를 수행한 뒤
      다시 온라인 상태로 만드는 예이다.</p>

      <pre class="programlisting">ALTER TABLESPACE my_space OFFLINE IMMEDIATE; 
ALTER DATABASE RECOVER AUTOMATIC TABLESPACE my_space;
ALTER TABLESPACE my_space ONLINE;</pre>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>미디어 복구에 대한 자세한 내용은 <a href="chapter_backuprecovery.html#sect_admin_bar_media_recovery" title="11.3.3. 미디어 복구">“11.3.3. 미디어 복구”</a>를 참고한다.</p>
      </div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2594"/>3.2.4. 테이블 스페이스 정보 조회<a id="d5e2596" class="indexterm"/></h3></div></div></div>
      

      <p><span>Tibero</span>에서는 테이블 스페이스를 효율적으로 관리하기 위해 다음 표에
      나열된 뷰(정적 뷰, 동적 뷰 포함)를 통해 테이블 스페이스의 정보를 제공하고 있다.</p>

      <p>테이블 스페이스 내의 익스텐트의 크기 및 개수, 할당된 서버, 포함된 데이터 파일의 이름 및 크기, 세그먼트의 이름 및
      종류, 크기 등의 정보를 제공한다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="160" align="left"/><col/></colgroup><thead><tr><th align="left">뷰</th><th>설명</th></tr></thead><tbody><tr><td align="left">DBA_TABLESPACES<a id="d5e2611" class="indexterm"/><a id="d5e2613" class="indexterm"/></td><td><span>Tibero</span> 내의 모든 테이블 스페이스의 정보를 조회하는
              뷰이다.</td></tr><tr><td align="left">USER_TABLESPACES<a id="d5e2620" class="indexterm"/><a id="d5e2622" class="indexterm"/></td><td>현재 사용자에 속한 테이블 스페이스의 정보를 조회하는 뷰이다.</td></tr><tr><td align="left">V$TABLESPACE<a id="d5e2628" class="indexterm"/><a id="d5e2630" class="indexterm"/></td><td><span>Tibero</span> 내의 모든 테이블 스페이스에 대한 간략한 정보를
              조회하는 뷰이다.</td></tr></tbody></table>
      </div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>정적 뷰와 동적 뷰에 대한 자세한 내용은 "<span>Tibero</span> 참조 안내서"를 참고한다.</p>
      </div>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_lf"/>3.3. 로그 파일</h2></div></div></div>
    

    <p><span><strong class="guibutton">로그 파일</strong></span><a id="d5e2643" class="indexterm"/>은 Redo 로그를 저장하는 파일이다. <span><strong class="guibutton">Redo 로그</strong></span>는
    데이터베이스에서 발생하는 모든 변경 내용을 포함하며, 데이터베이스에 치명적인 에러가 발생한 경우 커밋된 트랜잭션의 갱신된 내용을
    복구하는 핵심적인 데이터 구조이다.</p>

    <p>다음은 Redo 로그의 구조를 나타내는 그림이다.</p>

    <div class="figure"><a id="fig_redolog"/><p class="title"><b>[그림 3.3] Redo 로그의 구조</b></p><div class="figure-contents">
      

      <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="500"><tr><td align="left"><img src="resources/redolog.png" align="top" width="500" alt="Redo 로그의 구조"/></td></tr></table></div>
    </div></div><br class="figure-break"/>

    <h3><a id="d5e2652"/>Redo 로그<a id="d5e2653" class="indexterm"/></h3>

    <p><a href="chapter_03.html#fig_redolog" title="[그림 3.3] Redo 로그의 구조">[그림 3.3]</a>에서 보듯이 Redo 로그는 두 개 이상의 로그 그룹(Log
    Group)으로 구성된다. <span>Tibero</span>에서는 이러한 로그 그룹을 순환적(Circular)으로
    사용한다.</p>

    <p>예를 들어 세 개의 로그 그룹으로 Redo 로그를 구성하는 경우 먼저 로그 그룹 1에 로그를 저장한다. 로그 그룹 1에
    로그가 가득 차면, 그 다음 로그 그룹 2, 3에 로그를 저장한다. 로그 그룹 3까지 로그가 가득 차면 로그 그룹 1부터 다시
    저장한다. 이처럼 하나의 로그 그룹을 모두 사용하고 그 다음 로그 그룹을 사용하는 것을 <span><strong class="guibutton">로그
    전환</strong></span>(Log Switch)이라고 한다.<a id="d5e2660" class="indexterm"/><a id="d5e2662" class="indexterm"/></p>

    <p>Redo 로그에는 하나 이상의 로그 레코드(Log Record)가 저장된다. 로그 레코드에는 데이터베이스에서 발생하는 모든
    변경 내용이 포함되어 있으며, 이전에 변경된 값과 새로운 변경 값이 함께 저장된다.<a id="d5e2665" class="indexterm"/><a id="d5e2667" class="indexterm"/></p>

    <p><span>Tibero</span>는 동시에 하나의 로그 그룹만을 사용하는 데 현재 사용 중인 로그
    그룹을 활성화(active)된 로그 그룹이라고 한다.</p>

    <p>하나의 로그 그룹은 하나 이상의 로그 멤버로 구성할 수 있다. 이러한 구성을 다중화(multiplexing)라고 한다.
    단, 다중화를 하려면 동일한 그룹에 속해 있는 모든 로그 멤버의 크기는 일정해야 하며, 동일한 데이터를 저장하고 동시에 갱신되어야
    한다. 반면에 서로 다른 영역에 있는 로그 그룹은 각각 다른 개수의 로그 멤버를 포함할 수 있으며, 로그 멤버의 크기가 같지 않아도
    된다.<a id="d5e2672" class="indexterm"/><a id="d5e2674" class="indexterm"/></p>

    <p>하나의 로그 그룹을 여러 로그 멤버로 구성하는 이유는 일부 로그 멤버가 손상되더라도 다른 로그 멤버를 사용하기 위함이다.
    디스크가 대단히 신뢰성이 높거나 데이터가 손실되어도 큰 문제가 없다면 다중화를 하지 않아도 된다.</p>

    <p/>

    <h3><a id="d5e2678"/>ARCHIVELOG 모드 설정<a id="d5e2679" class="indexterm"/></h3>

    <p>Redo 로그에 저장된 내용을 제3의 저장 장치에 반영구적으로 저장할 수 있다. 이러한 과정을
    아카이브(Archive)<a id="d5e2682" class="indexterm"/><a id="d5e2684" class="indexterm"/>라고 하며, 디스크 상에 로그 파일이 손상될 경우를 대비하는 작업이다. 아카이브에 사용되는 저장 장치로는
    대용량 하드 디스크 또는 테이프 등이 있다.</p>

    <p><span>Tibero</span>에서는 Redo 로그를 사용하지 않을 때나 데이터베이스와 함께 사용
    중인 경우에도 동시에 아카이브를 수행할 수 있다. Redo 로그를 사용하는 중에 아카이브를 하려면 로그 아카이브 모드를
    <span><strong class="guibutton">ARCHIVELOG</strong></span>로 설정해야 한다.</p>

    <p>ARCHIVELOG 모드는 마운트(MOUNT) 상태에서 다음의 SQL 문장을 실행하여 설정할 수 있다.</p>

    <pre class="programlisting">SQL&gt; <span><strong class="guibutton">ALTER DATABASE ARCHIVELOG;</strong></span></pre>

    <p>ARCHIVELOG 모드에서는 아카이브가 되지 않은 로그 그룹은 재사용되지 않는다.</p>

    <p>예를 들어 로그 그룹 1를 전부 사용하고 나서 로그 그룹 2를 사용하려고 할 때 로그 그룹 2 이전에 저장된 로그가
    아카이브가 되지 않은 경우에는 로그 그룹 2가 아카이브가 될 때까지 대기해야 한다. 이때 읽기 전용이 아닌 모든 트랜잭션은 실행이
    잠시 중지된다. 로그 그룹 2가 아카이브가 되면 바로 활성화되어 로그를 저장한다. 또한 잠시 중지되었던 트랜잭션도 모두 다시
    실행된다. DBA는 이러한 일이 발생하지 않도록 로그 그룹의 개수를 충분히 설정해야 한다.</p>

    <p/>

    <h3><a id="d5e2695"/>NOARCHIVELOG 모드 설정<a id="d5e2696" class="indexterm"/></h3>

    <p>Redo 로그를 사용하는 중에 아카이브를 수행하지 않으려면, 로그 아카이브 모드를
    <span><strong class="guibutton">NOARCHIVELOG</strong></span>로 설정해야 한다. NOARCHIVELOG 모드에서는 아카이브가
    수행되지 않으며, 로그 그룹을 순환적으로 활성화하기 전에 아카이브되기를 기다리는 경우가 발생하지 않으므로 데이터베이스의 성능이
    향상된다.</p>

    <p>하지만 데이터베이스와 Redo 로그 자체에 문제가 발생하여 동시에 복구할 수 없는 경우라면 이전에 커밋된 트랜잭션에 의해
    갱신된 데이터를 모두 잃어버리게 된다. 따라서 NOARCHIVELOG 모드에서는 복구가 제한적으로 이루어지므로 항상 데이터베이스
    전체를 백업할 것을 권장한다.</p>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2702"/>3.3.1. 로그 파일 구성<a id="d5e2704" class="indexterm"/></h3></div></div></div>
      

      <p>로그 멤버는 기본적으로 하나의 로그 파일이다. Redo 로그를 구성할 때 각 로그 그룹과 로그 멤버에 서로 다른 로그
      파일을 할당해야 한다. 로그 파일은 데이터 파일과 서로 다른 디스크에 저장할 것을 권장한다. 로그 파일과 데이터 파일을 같은
      디스크에 저장하는 경우 디스크에 장애가 발생한다면 데이터베이스를 다시 복구할 수 없게 된다. 각 로그 그룹이 여러 개의 로그
      멤버로 구성된다면 최소한 로그 멤버 하나는 데이터 파일과 다른 디스크에 저장되어야 한다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2709"/>로그 멤버의 다중화<a id="d5e2710" class="indexterm"/></h4>

      <p>로그 그룹 하나에 포함된 로그 멤버는 시스템의 성능을 위해 서로 다른 디스크에 저장하는 것이 좋다. 같은 로그 그룹
      내의 모든 멤버는 같은 로그 레코드를 저장해야 한다. 모든 로그 멤버가 서로 다른 디스크에 존재하게 된다면 로그 레코드를 저장하는
      과정을 동시에 수행할 수 있다.</p>

      <p>다음은 같은 로그 그룹의 모든 로그 멤버를 서로 다른 디스크에 배치한 그림이다.</p>

      <div class="figure"><a id="fig_lmf_mul"/><p class="title"><b>[그림 3.4] 로그 멤버의 다중화</b></p><div class="figure-contents">
        

        <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="452"><tr><td align="left"><img src="resources/lmf_mul.png" align="top" width="452" alt="로그 멤버의 다중화"/></td></tr></table></div>
      </div></div><br class="figure-break"/>

      <p><a href="chapter_03.html#fig_lmf_mul" title="[그림 3.4] 로그 멤버의 다중화">[그림 3.4]</a>에서 Log Member 1-1은 로그 그룹 1의 첫 번째 로그
      멤버라는 의미이다. 하나의 디스크에 같은 그룹의 로그 멤버가 존재한다면 동시에 같은 로그 레코드를 저장할 수 없다. 이 때문에
      데이터베이스 시스템의 성능이 저하되는 원인이 되기도 한다.</p>

      <p>로그 아카이브 모드를 <span><strong class="guibutton">ARCHIVELOG</strong></span>로 설정했을 때 Redo 로그 안에
      활성화된 로그 그룹의 로그가 저장됨과 동시에 비활성화된 로그 그룹 중 하나에 대해서 아카이브가 수행된다. 활성화된 로그 그룹과
      아카이브 중인 로그 그룹이 한 디스크에 존재하게 된다면 이 또한 데이터베이스 시스템의 성능이 저하되는 원인이
      된다.<a id="d5e2723" class="indexterm"/> 따라서 서로 다른 로그 그룹의 로그 파일은 각각 다른 디스크에 저장하는 것이 시스템 성능을 높이는 데
      도움이 된다.</p>

      <div class="caution" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">주의</h3>
        <p>단, Instance Recovery 할 때 정합성이 깨진 로그 멤버에 접근할 경우 해당 멤버를 컨트롤 파일에서
        제거시킨다.</p>
      </div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e2730"/>로그 그룹의 다중화<a id="d5e2731" class="indexterm"/></h4>

      <p>다음은 두 개의 로그 멤버로 구성된 두 개의 로그 그룹을 서로 다른 디스크에 분리하여 배치한 그림이다.</p>

      <div class="figure"><a id="fig_lmg_mul"/><p class="title"><b>[그림 3.5] 로그 그룹의 다중화</b></p><div class="figure-contents">
        

        <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="500"><tr><td align="left"><img src="resources/lmg_mul.png" align="top" width="500" alt="로그 그룹의 다중화"/></td></tr></table></div>
      </div></div><br class="figure-break"/>

      <p><a href="chapter_03.html#fig_lmg_mul" title="[그림 3.5] 로그 그룹의 다중화">[그림 3.5]</a>에서 Log Member 1-1은 로그 그룹 1의 첫 번째 로그
      멤버라는 의미이다.</p>

      <p>로그 그룹의 크기와 개수를 정할 때는 아카이브 작업을 충분히 고려해야 한다. 로그 그룹의 크기는 제3의 저장 장치에
      빠르게 전달하고 저장 공간을 효율적으로 사용할 수 있도록 설정해야 한다. 또한 로그 그룹의 개수는 아카이브 중인 로그 그룹을
      대기하는 경우가 발생하지 않도록 해야 한다.</p>

      <p>로그 그룹의 크기와 개수는 데이터베이스를 실제로 운영하면서 변경해야 한다. 즉, 데이터베이스에 최적화된 파라미터를
      설정한 후 로그 그룹의 크기와 개수를 증가시켜가면서 데이터베이스 처리 성능에 무리가 가지 않는 범위에서 변경해야
      한다.</p>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2746"/>아카이브 로그의 저장과 다중화<a id="d5e2747" class="indexterm"/></h4>

      <p>아카이브된 로그가 저장되는 위치는 초기화 파라미터 LOG_ARCHIVE_DEST로 지정한다. 필요한 아카이브 로그를
      찾지 못하면 미디어 복구를 할 수 없기 때문에 아카이브 로그를 잘 보관하는 것이 중요하다.</p>

      <p>아카이브 로그 역시 다중화하여 여러 위치에 저장할 수 있다. 아카이브 로그를 다중화할 때는 초기화 파라미터
      LOG_ARCHIVE_DEST_1, LOG_ARCHIVE_DEST_2, ..., LOG_ARCHIVE_DEST_9를 사용한다.
      파라미터 문자열에서 'location='으로 저장위치를 지정하고, mandatory나 optional로 다중화 아카이브 로그
      저장에 실패하는 경우 동작을 지정한다(지정하지 않으면 optional로 처리된다).</p>

      <p>mandatory로 지정된 경우 해당위치에 다중화된 아카이브 로그 저장을 성공할 때까지 계속 시도한다. 계속 실패할
      경우 Redo 로그 그룹이 재사용되지 않아 데이터베이스 전체가 멈출 수 있다. optional로 지정된 위치는 아카이브 로그
      저장에 실패하더라도 재시도하지 않으며, 다른 작업이 정상적으로 계속 진행된다.</p>

      <a id="d5e2752" class="indexterm"/>

      <div class="example"><a id="d5e2754"/><p class="title"><b>[예 3.1] tip 설정 예시</b></p><div class="example-contents">
        

        

        <pre class="programlisting">LOG_ARCHIVE_DEST =   "/usr/<span>tibero</span>/log/archive"
LOG_ARCHIVE_DEST_1 = "location=/usr/<span>tibero</span>/archive1 mandatory"
LOG_ARCHIVE_DEST_2 = "location=/usr/<span>tibero</span>/archive2 mandatory"
LOG_ARCHIVE_DEST_3 = "location=/usr/<span>tibero</span>/archive3"
LOG_ARCHIVE_DEST_4 = "location=/usr/<span>tibero</span>/archive4 optional" </pre>
      </div></div><br class="example-break"/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2762"/>3.3.2. 로그 파일 생성, 제거</h3></div></div></div>
      

      <p>새로운 로그 그룹 또는 로그 그룹에 포함되어 있는 로그 멤버를 생성하거나 제거하려면 <span><strong class="guibutton">ALTER
      DATABASE</strong></span> 문을 사용해야 한다. 단, ALTER DATABASE 문을 사용하기 위해서는 시스템 특권이
      필요하다.<a id="d5e2766" class="indexterm"/></p><div class="literallayout"><p/></div><h4><a id="d5e2769"/>로그 파일
      생성<a id="d5e2770" class="indexterm"/></h4><p>새로운 로그 그룹을 생성하려면 ALTER DATABASE 문에
      <span><strong class="guibutton">ADD LOGFILE</strong></span> 절을 삽입해야 한다. 이 절은 로그 파일을 추가할 때 사용한다.
      단, 로그 파일을 추가할 때에는 로그 그룹 단위로만 해야 한다. 로그 멤버의 크기의 최소값은 512KB, 최대값은 2TB이다.
      <a id="d5e2773" class="indexterm"/></p>

      <p>다음은 두 개의 로그 멤버로 구성된 로그 그룹을 추가하는 예이다. 본 예제에서는 두 로그 멤버의 크기를 512KB로
      설정한다. 이때 두 로그 멤버의 크기는 항상 같아야 한다.</p>

      <pre class="programlisting">ALTER DATABASE <span><strong class="guibutton">ADD LOGFILE</strong></span> (
        '/usr/<span>tibero</span>/log/my_log21.log',
        '/usr/<span>tibero</span>/log/my_log22.log') SIZE 512K</pre>

      <div class="literallayout"><p/></div><p>또한 ADD LOGFILE 절에 로그 그룹의 번호를 지정할 수
      있는 GROUP 옵션을 추가할 수 있다. 로그 그룹의 번호를 설정하면 이후에 특정한 로그 그룹을 지칭하여 로그 멤버를 추가하는
      등의 작업을 수행할 수 있다. 다음은 로그 그룹에 번호를 설정하는 예이다.</p>

      <pre class="programlisting">ALTER DATABASE ADD LOGFILE <span><strong class="guibutton">GROUP 5</strong></span> (
        '/usr/<span>tibero</span>/log/my_log21.log',
        '/usr/<span>tibero</span>/log/my_log22.log') SIZE 512K </pre>

      <div class="literallayout"><p/></div>

      <p>기존의 로그 그룹에 새로운 로그 멤버를 추가하려면 <span><strong class="guibutton">ADD LOGFILE
      MEMBER</strong></span> 절을 삽입해야 한다. 이때 로그 파일에 할당된 서버 프로세스를 반드시 명시해야
      한다.<a id="d5e2790" class="indexterm"/></p>

      <p>다음의 SQL 문장은 로그 그룹 5에 새로운 로그 멤버를 추가하는 예이다.</p>

      <pre class="programlisting">ALTER DATABASE ADD LOGFILE MEMBER
        '/usr/<span>tibero</span>/log/my_log25.log' TO GROUP 5</pre>

      <p>새로운 로그 멤버를 추가할 때에는 로그 파일의 크기를 지정하면 안 된다. 로그 파일의 크기는 같은 로그 그룹 내의 로그
      멤버의 크기와 동일하게 설정한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2798"/>로그 파일 제거<a id="d5e2799" class="indexterm"/></h4>

      <p>로그 그룹을 제거하려면 <span><strong class="guibutton">DROP LOGFILE</strong></span> 절을 삽입해야
      한다.<a id="d5e2803" class="indexterm"/></p>

      <p>다음의 SQL 문장은 로그 그룹 5를 제거하는 예이다.</p>

      <pre class="programlisting">ALTER DATABASE DROP LOGFILE GROUP 5; </pre>

      <p>다음은 로그 그룹을 제거하기 전에 고려해야 할 사항이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>로그 그룹이 둘 이상인가?</p>

          <p><span>Tibero</span>는 로그 그룹을 최소한 두 개 이상 가져야
          한다.</p>
        </li><li>
          <p>로그 그룹을 제거한 후 남은 로그 그룹의 개수가 하나인가?</p>

          <p>남은 로그 그룹의 개수가 하나이면 에러를 반환한다.</p>
        </li><li>
          <p>현재 활성화되어 사용 중인 로그 그룹인가?</p>

          <p>로그 그룹은 제거되지 않는다.</p>
        </li><li>
          <p>ARCHIVELOG 모드에서 아카이브 되지 않은 로그 그룹인가?</p>

          <p>로그 그룹은 제거되지 않는다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>로그 그룹 내의 하나의 로그 멤버를 제거하기 위해서는 <span><strong class="guibutton">DROP LOGFILE
      MEMBER</strong></span> 절을 삽입해야 한다. 로그 그룹이 할당된 서버를 명시해야 하며 로그 그룹은 명시하지 않아도
      된다.<a id="d5e2826" class="indexterm"/></p>

      <p>다음의 SQL 문장은 로그 멤버 하나를 제거하는 예이다.</p>

      <pre class="programlisting">ALTER DATABASE DROP LOGFILE MEMBER '/usr/<span>tibero</span>/log/my_log25.log' </pre>

      <p>로그 멤버도 로그 그룹을 제거할 때처럼 로그 그룹 내에 남겨진 로그 멤버가 하나도 없는 경우 에러를 반환하게 된다.
      뿐만 아니라 현재 활성화되어 사용 중이거나 ARCHIVELOG 모드에서 아카이브 되지 않은 로그 그룹 내의 로그 멤버도 제거되지
      않는다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2834"/>3.3.3. 로그 파일 정보 조회</h3></div></div></div>
      

      <p><span>Tibero</span>에서는 Redo 로그 관리에 도움을 주기 위해 다음 표에 나열된
      동적 뷰를 제공하고 있다.</p>

      <p>Redo 로그의 그룹별 로그 파일, 다중화 정보, 갱신 날짜 등의 정보를 제공하며 DBA나 일반 사용자 모두가 이 뷰를
      사용할 수 있다.<a id="d5e2839" class="indexterm"/></p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">동적 뷰</th><th>설명</th></tr></thead><tbody><tr><td align="left">V$LOG<a id="d5e2851" class="indexterm"/><a id="d5e2854" class="indexterm"/></td><td>로그 그룹의 정보를 조회하는 뷰이다.</td></tr><tr><td align="left">V$LOGFILE<a id="d5e2859" class="indexterm"/><a id="d5e2862" class="indexterm"/></td><td>로그 파일의 정보를 조회하는 뷰이다.</td></tr></tbody></table>
      </div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>동적 뷰에 대한 자세한 내용은 "<span>Tibero</span> 참조 안내서"를 참고한다.</p>
      </div>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_cf"/>3.4. 컨트롤 파일<a id="d5e2870" class="indexterm"/><a id="d5e2872" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">컨트롤 파일</strong></span>은 데이터베이스 자체의 메타데이터를 보관하고 있는 바이너리 파일이다.
    최초의 컨트롤 파일은 <span>Tibero</span>를 설치할 때 함께 생성된다. 최초로 설정된 컨트롤 파일에 대한
    정보는 <span><strong class="guibutton">$<span>TB_</span>SID.tip</strong></span> 파일에 저장된다.</p>

    <p>컨트롤 파일은 <span>Tibero</span>에 의해서만 생성과 갱신을 할 수 있으며 DBA가 컨트롤 파일의
    내용을 조회하거나 갱신할 수는 없다.</p>

    <p>컨트롤 파일에는 다음과 같은 정보가 포함되어 있다.</p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">정보</th><th>설명</th></tr></thead><tbody><tr><td align="left">데이터베이스</td><td>데이터베이스 이름, $<span>TB_</span>SID.tip 파일의 이름 또는 생성되었거나 변경된 타임스탬프
            등이 있다.</td></tr><tr><td align="left">테이블 스페이스</td><td>테이블 스페이스를 구성하는 데이터 파일 또는 생성되었거나 변경된 타임스탬프 등이 있다.</td></tr><tr><td align="left">데이터 파일</td><td>데이터 파일의 이름과 위치 또는 생성되었거나 변경된 타임스탬프 등이 있다.</td></tr><tr><td align="left">Redo 로그</td><td>로그 그룹의 개수 및 이를 구성하는 로그 멤버(로그 파일)의 이름과 위치 또는 생성되었거나 변경된
            타임스탬프 등이 있다.</td></tr><tr><td align="left">체크포인트</td><td>최근 체크포인트를 수행한 타임스탬프 등이 있다.</td></tr></tbody></table>
    </div>

    <div class="literallayout"><p/></div>

    <p><span>Tibero</span>에서는 데이터베이스를 다시 기동할 때마다 먼저 컨트롤 파일을
    참조한다.</p>

    <p>참조하는 절차는 다음과 같다.</p>

    <div class="orderedlist"><ol type="1" compact="compact"><li>
        <p>테이블 스페이스와 데이터 파일의 정보를 얻는다.</p>
      </li><li>
        <p>데이터베이스에 실제 저장된 데이터 사전과 스키마 객체의 정보를 얻는다.</p>
      </li><li>
        <p>필요한 데이터를 읽는다.</p>
      </li></ol></div>

    <p><span>Tibero</span>에서 컨트롤 파일은 같은 크기, 같은 내용의 파일을 두 개 이상
    유지하기를 권장한다. 이는 Redo 로그 멤버를 다중화하는 방법과 유사하다. 같은 로그 그룹 내의 로그 멤버를 서로 다른 디스크에
    설치하는 것처럼 컨트롤 파일의 복사본을 서로 다른 디스크에 저장하는 것이 좋다. 이는 데이터베이스의 시스템 성능과 안정성을 유지하는
    데 매우 필요하다. 예를 들어 한 디스크에 컨트롤 파일의 복사본이 존재하는 경우 문제가 발생할 수 있다. 만약 이 디스크를 영구적으로
    사용할 수 없게 된다면 컨트롤 파일은 복구할 수 없는 상태가 된다. 따라서 컨트롤 파일은 Redo 로그와 연관하여 배치하는 것이
    좋다.</p>

    <div class="caution" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">주의</h3>
      <p>컨트롤 파일은 데이터베이스를 운영할 때 매우 중요한 파일이므로 컨트롤 파일이 손상되지 않도록 주의한다.</p>
    </div>

    <p/>

    <div class="literallayout"><p/></div>

    

    <p/>

    <h3><a id="d5e2927"/>컨트롤 파일의 다중화</h3>

    <p>다음은 컨트롤 파일을 다중화한 그림이다.</p>

    <div class="figure"><a id="fig_ctrlf_mul"/><p class="title"><b>[그림 3.6] 컨트롤 파일의 다중화</b></p><div class="figure-contents">
      

      <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="452"><tr><td align="left"><img src="resources/ctrlf_mul.png" align="top" width="452" alt="컨트롤 파일의 다중화"/></td></tr></table></div>
    </div></div><br class="figure-break"/>

    <p>위 그림에서 보듯이 디스크마다 하나의 로그 그룹에 여러 로그 멤버를 배치한 것처럼 컨트롤 파일의 복사본을 같은 위치에
    배치한다.</p>

    <p><span>Tibero</span>에서는 컨트롤 파일로부터 정보를 확인할 때 여러 복사본 중에서
    하나만 읽는다. 그리고 테이블 스페이스의 변경 등의 이유로 컨트롤 파일을 갱신해야 하는 경우에는 모든 복사본을 동시에 갱신한다.
    컨트롤 파일의 갱신을 유발하는 SQL 문장은 모두 DDL 문장이다. DDL 문장의 특징은 하나의 문장이 하나의 트랜잭션이 된다는
    것이다. 따라서 DDL 문장을 실행하면 바로 커밋되며, 갱신된 내용은 바로 디스크에 반영된다.</p>

    <p/>

    <div class="caution" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">주의</h3>
        <p>TAC 환경에서 컨트롤 파일을 다중화하는 경우 하나의 노드라도 특정 컨트롤 파일 write에 실패하게 되면 해당
        파일은 invalidate 처리되어야 한다. 따라서 모든 노드의 tip 파일에는 다중화할 컨트롤 파일의 개수와 각 컨트롤 파일
        경로가 동일하게 기재되어 있어야 한다.</p>
      </div>

    <p/>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2943"/>3.4.1. 컨트롤 파일 변경</h3></div></div></div>
      

      <p>DBA는 컨트롤 파일의 복사본을 추가하거나 제거할 수 있다. 컨트롤 파일은 DBMS에 대한 메타데이터이므로
      데이터베이스를 운영 중일 때에는 컨트롤 파일의 변경이 불가능하다. 따라서 컨트롤 파일의 복사본을 추가 또는 제거하기 위한 SQL
      문장은 존재하지 않는다. 반드시 데이터베이스를 종료한 후 컨트롤 파일을 변경해야 한다.</p>

      <p>이처럼 컨트롤 파일을 추가 또는 제거하기 위한 SQL 문장이 존재하지 않기 때문에 일반적인 운영체제 명령어를 사용하여
      변경 작업을 수행해야 한다. 그 다음 변경된 내용을 $<span>TB_</span>SID.tip 파일에 반영한다.</p>

      <p>다음은 UNIX Command에서 컨트롤 파일을 복사하는 예이다.</p><pre class="programlisting">$ <span><strong class="guibutton">cp /usr1/<span>tibero</span>/control01.ctl /usr3/<span>tibero</span>/control03.ctl</strong></span></pre><p>위의
      예에서 usr1과 usr3은 서로 다른 디스크에 존재하는
      디렉터리이다.</p><div class="literallayout"><p/></div><p><span>Tibero</span>는 데이터베이스를 다시 기동하면서 $<span>TB_</span>SID.tip 파일을 읽고, 변경된 내용에 따라 컨트롤 파일의 갱신을
      수행한다. 이때 유의할 점은 $<span>TB_</span>SID.tip 파일 내에 설정된 컨트롤 파일의 이름은 절대 경로를 포함한
      이름이어야 한다.</p>

      <p>디스크 에러 등의 원인으로 일부 컨트롤 파일에 장애가 발생했을 경우에도 하나 이상의 컨트롤 파일이 정상이면
      <span>Tibero</span>는 문제없이 운영된다.</p>

      <div class="literallayout"><p/></div>

      <p><span><strong class="guibutton">컨트롤 파일의 백업</strong></span><a id="d5e2962" class="indexterm"/>은 물리적 백업과 논리적 백업을 지원한다. 하지만 물리적 백업은 수동으로 모든 데이터 파일들도 함께
      백업을 해야하며 절차가 매우 중요하다. 절차를 제대로 지키지 않았을 시 추후 데이터 복구가 불가능하기 때문에, 실수할 확률이 있는
      물리적 백업은 보통 추천하지 않으며 책임져주지 않는다. 따라서 논리적 백업 방법으로 컨트롤 파일을 생성하는 SQL 문장을 백업하는
      것이 일반적이다. 또한 테이블 스페이스, 데이터 파일, Redo 로그를 새로 생성하거나 변경 또는 제거를 수행한 경우에는 바로
      컨트롤 파일을 백업하는 것이 관리 측면에서 안전하다. 물론 데이터베이스 전체를 백업할 때에도 컨트롤 파일 자체를 백업해야 한다.
      자세한 내용은 <a href="chapter_backuprecovery.html#sect_admin_backup_method" title="11.2.2. 백업 실행">“11.2.2. 백업 실행”</a>을 참고한다.</p>

      <div class="literallayout"><p/></div>

      <p>다음의 SQL 문장은 컨트롤 파일을 물리적 백업하는 예이다.</p>

      <pre class="programlisting">SQL&gt; ALTER DATABASE BACKUP CONTROLFILE TO
          '/<span>tibero</span>7/backup/ctrlfile1.ctl';</pre>

      <p>다음의 SQL 문장은 컨트롤 파일을 논리적 백업하는 예이다.</p>

      <pre class="programlisting">SQL&gt; ALTER DATABASE BACKUP CONTROLFILE TO TRACE AS
          '/<span>tibero</span>7/backup/ctrlfile1.sql' REUSE NORESETLOGS;</pre>

      <p>위 예에서 보듯이 백업할 컨트롤 파일의 복사본(ctrlfile1.ctl, ctrlfile1.sql)은 기존의 복사본과
      다른 디스크에 저장해야 하므로 반드시 절대 경로를 포함한 이름을 명시해야 한다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2973"/>3.4.2. 컨트롤 파일 정보 조회<a id="d5e2975" class="indexterm"/></h3></div></div></div>
      

      <p><span>Tibero</span>에서는 컨트롤 파일을 관리하는 데 도움을 주기 위해 다음 표에
      동적 뷰를 제공하고 있다.</p>

      <p>데이터베이스 생성 시간, 체크포인트 정보 등의 정보를 제공하며, DBA나 일반 사용자 모두가 이 뷰를 사용할 수
      있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">동적 뷰</th><th>설명</th></tr></thead><tbody><tr><td align="left">V$DATABASE<a id="d5e2990" class="indexterm"/><a id="d5e2992" class="indexterm"/></td><td>ARCHIVELOG 모드 여부와 체크포인트 등의 정보를 조회하는 뷰이다.</td></tr><tr><td align="left">V$CONTROLFILE<a id="d5e2998" class="indexterm"/><a id="d5e3000" class="indexterm"/></td><td>컨트롤 파일의 이름과 상태 등의 정보를 조회하는 뷰이다.</td></tr></tbody></table>
      </div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>동적 뷰에 대한 자세한 내용은 "<span>Tibero</span> 참조 안내서"를 참고한다.</p>
      </div>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_01.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_04.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제2장 관리의 기본 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제4장 스키마 객체 관리</td></tr></table></div><div xmlns="" align="center"/></body></html>