<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제11장 백업과 복구</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero 관리자 안내서"/><link rel="up" href="index.html" title="Tibero 관리자 안내서"/><link rel="prev" href="chapter_label_security.html" title="제10장 Tibero Label Security"/><link rel="next" href="chapter_07.html" title="제12장 분산 트랜잭션"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제11장 백업과 복구</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_label_security.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_07.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_backuprecovery"/>제11장 백업과 복구</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_bar_database_file">11.1. <span>Tibero</span> 구성 파일</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_bar_backup_strategy">11.2. 백업</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_backuprecovery.html#d5e8034">11.2.1. 백업 종류</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_backup_method">11.2.2. 백업 실행</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_bar_recovery_mechanism">11.3. 복구</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_backuprecovery.html#d5e8239">11.3.1. 부트 모드별 복구</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_bar_crash_recovery">11.3.2. 파손 복구</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_bar_media_recovery">11.3.3. 미디어 복구</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_bar_online_media_recovery">11.3.4. 온라인 미디어 복구</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_rmgr">11.4. 복구 관리자</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_backuprecovery.html#d5e8370">11.4.1. 기본 기능</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#sect_rmgr_option">11.4.2. 복구 관리자 옵션</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#d5e8744">11.4.3. 복구 관리자를 이용한 백업 및 복구 예제</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#d5e8958">11.4.4. 복구 관리자를 이용한 백업 삭제 예제</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_netbackup">11.5. <span>Tibero</span>와 NetBackup 연동</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_backuprecovery.html#d5e9018">11.5.1. NetBackup 환경설정</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#d5e9110">11.5.2. 복구 관리자 환경설정</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#d5e9175">11.5.3. 복구 관리자를 이용한 NetBackup 사용 예제</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_backuprecovery.html#sect_admin_fbdb">11.6. 플래시백 데이터베이스</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_backuprecovery.html#d5e9196">11.6.1. 기본 기능 및 특징</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#sect_fbdb_restriction">11.6.2. 전제 조건 및 제약 사항</a></span></dt><dt><span class="section"><a href="chapter_backuprecovery.html#sect_fbdb_example">11.6.3. 플래시백 데이터베이스 실행 예제</a></span></dt></dl></dd></dl></div>
  

  <p><span>Tibero</span>는 시스템의 예상치 못한 오류 등으로 인해 데이터베이스가 비정상적으로
  종료하거나 시스템에 물리적인 손상을 입은 상황을 대처하려고 다양한 백업과 복구 방법을 제공한다.</p>

  <p>본 장에서는 이러한 백업과 복구 방법을 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_admin_bar_database_file"/>11.1. <span>Tibero</span> 구성 파일</h2></div></div></div>
    

    <p><span>Tibero</span>의 파일은 컨트롤 파일(Control file), 데이터
    파일(Data file), 임시 파일(Temp file), 로그 파일(Log file)로 구성된다.</p>

    <p>플래시백 데이터베이스(Flashback Database) 기능 사용 시에는 플래시백 로그 파일(Flashback Log
    File)이 추가된다. 플래시백 데이터베이스 기능에 대해서는 <a href="chapter_backuprecovery.html#sect_admin_fbdb" title="11.6. 플래시백 데이터베이스">“11.6. 플래시백 데이터베이스”</a>를
    참고한다.</p>

    <p>각 파일의 특징과 역할은 다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p><span><strong class="guibutton">컨트롤 파일(Control file)</strong></span><a id="d5e7945" class="indexterm"/></p>

        <p>컨트롤 파일은 <span>Tibero</span>를 구성하는 모든 파일의 위치와 데이터베이스의 이름 등
        데이터베이스의 구조를 저장하는 파일이다. 특히, <span>Tibero</span>가 사용하는 데이터 파일, 로그 파일 등의 상태 정보가 기록된다. 컨트롤 파일은 <span>Tibero</span>를 기동할 때 복구가 필요한지를 판단하는 데 사용된다.</p>

        <p>컨트롤 파일은 데이터베이스의 복구에 매우 중요한 파일이므로 다른 물리적 파티션에 여러 개 지정하기를 권장한다. 여러
        개를 유지하면 한 파티션에 장애가 발생하여 컨트롤 파일을 사용하지 못하더라도 다른 컨트롤 파일을 이용하여 복구할 수
        있다.</p>

        <p>컨트롤 파일은 현재의 데이터베이스를 구성하는 파일에 관한 정보를 담고 있으므로 반드시 최신 것으로 유지해야 한다.
        컨트롤 파일의 백업은 현재의 컨트롤 파일 자체를 백업하는 방식으로 이루어지지 않고, 컨트롤 파일을 생성하는
        <span><strong class="guibutton">CREATE CONTROLFILE</strong></span> 문을 백업해 두었다가 복구가 필요한 경우 백업해
        놓은 컨트롤 파일 생성문을 사용하여 컨트롤 파일을 다시 생성하는 방식으로 이루어진다.</p>

        <p>최신의 컨트롤 파일을 유지하기 위해서는 데이터베이스에 파일을 추가하거나 변경하는 등 구조상 변화가 있을 때마다
        컨트롤 파일의 생성문을 백업해야 한다. 컨트롤 파일 자체를 백업해 두었다가 사용하는 것은 NOARCHIVELOG 모드에서처럼
        데이터베이스 전체를 백업하는 경우에만 사용할 수 있다.</p>
      </li><li>
        <p><span><strong class="guibutton">데이터 파일(Data file)</strong></span><a id="d5e7959" class="indexterm"/></p>

        <p>데이터 파일은 사용자의 데이터를 저장하는 파일로써 로그 파일과 함께 데이터베이스를 구성하는 가장 중요한
        파일이다.</p>

        <p>Permanent 테이블 스페이스와 Undo 테이블 스페이스에서 정의한 파일로 테이블, 인덱스 등의 데이터베이스
        객체를 저장한다. 테이블 스페이스는 한 개 이상의 데이터 파일로 이루어지며, 한 데이터 파일은 하나의 테이블 스페이스에
        속한다. 데이터 파일은 사용자의 데이터가 물리적으로 저장되는 공간이므로 반드시 백업해야 한다.</p>
      </li><li>
        <p><span><strong class="guibutton">임시 파일(Temp file)</strong></span><a id="d5e7967" class="indexterm"/></p>

        <p>임시 파일은 데이터베이스가 메모리에서 처리할 수 없는 방대한 양의 데이터를 다루는 경우 임시로 사용하기 위한
        공간이다.</p>

        <p><span>Tibero</span>는 사용자의 질의를 처리하기 위해 정렬 등의 연산을 수행할
        때와 임시 테이블(Temporary Table)의 데이터를 저장할 때 데이터 파일을 사용한다. 데이터 파일은 임시 테이블
        스페이스(Temporary Tablespace)에서만 정의할 수 있고, 임시 테이블 스페이스는 하나 이상의 데이터 파일을 가질
        수 있다. 임시 파일은 데이터베이스를 구성하는 데이터가 물리적으로 저장되지는 않고 운영 중에 임시로 사용되는 영역이므로 백업할
        필요가 없다.</p>
      </li><li>
        <p><span><strong class="guibutton">로그 파일(Log file)</strong></span><a id="d5e7976" class="indexterm"/></p>

        <p>로그 파일은 로그를 저장하는 파일이다. 데이터 파일에 기록되는 내용을 시간 순으로 기록하는 파일로써 데이터베이스를
        복구할 때 사용한다. 로그 파일은 운영 중에 순환적으로 재사용되는 온라인 로그 파일과 재사용된 온라인 로그 파일을 보관하는
        아카이브 로그 파일로 나뉜다.<a id="d5e7980" class="indexterm"/><a id="d5e7983" class="indexterm"/></p>

        <p>ARCHIVELOG 모드로 운영 중일 때만 아카이브 로그 파일이 만들어진다. NOARCHIVELOG 모드에서는
        온라인 로그 파일만 사용한다. NOARCHIVELOG 모드에서는 재사용되어 없어진 로그 파일이 있을 수 있으므로 복구할 때
        많은 제약이 따른다. 로그 파일은 데이터베이스 복구할 때 복원된 데이터 파일을 최신 상태로 복구하기 위해, 데이터베이스가
        어떻게 변경되어 왔는지에 대한 모든 정보를 기록한다. 따라서 데이터 파일과 함께 반드시 백업을 해야 한다.</p>
      </li><li>
        <p><span><strong class="guibutton">플래시백 로그 파일(Flashback Log File)</strong></span><a id="d5e7990" class="indexterm"/></p>

        <p>플래시백 로그 파일은 플래시백 로그를 저장하는 파일이다. 데이터 파일이 변경되기 직전 내용들을 블록 단위로 기록하는
        파일로써 플래시백 데이터베이스 기능으로 데이터베이스를 가까운 과거로 되돌릴 때 사용한다. 일반적인 사용 방법과 특징은 로그
        파일과 같다.<a id="d5e7994" class="indexterm"/><a id="d5e7997" class="indexterm"/></p>

        <p>ARCHIVELOG 모드로 운영 중이어야만 플래시백 로그를 기록할 수 있다. 플래시백 아카이브 로그 파일을 오래
        보관할수록 플래시백 데이터베이스 기능으로 돌아갈 수 있는 과거가 더 오래된다. 하지만, 백업 파일 사용하여 복구 시 플래시백
        로그 파일은 모두 무용지물이 되기 때문에 일반 아카이브 로그 파일과 다르게 백업 대상이 아니다. 일반 로그 파일과 다르게
        Tibero Standby Cluster의 동기화 대상이 아니다.</p>
      </li></ul></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_admin_bar_backup_strategy"/>11.2. 백업</h2></div></div></div>
    

    <p><span><strong class="guibutton">백업(Backup)</strong></span><a id="d5e8005" class="indexterm"/><a id="d5e8007" class="indexterm"/>은 여러 가지 유형의 장애로부터 데이터베이스를 보호하는 것을 뜻한다. 즉, 시스템 장애가 발생했을 때 복구를
    하거나 시스템 작동을 유지하기 위한 절차 또는 기법이다.</p>

    <p><span>Tibero</span>는 데이터베이스를 백업하는 방법을 크게 두 가지로 나누어 수행할 수
    있다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>논리적 백업<a id="d5e8014" class="indexterm"/></p>

        <p>논리적 백업이란 테이블, 인덱스, 시퀀스와 같은 데이터베이스의 논리적 단위를 백업하는 것을 뜻한다. <span>Tibero</span>에서는 이를 위해 <span>tbExport</span>와 <span>tbImport</span> 유틸리티를 제공하고 있다. <span>tbExport</span>와 <span>tbImport</span>에 대한 자세한 내용은 "<span>Tibero</span> 유틸리티 안내서"를 참고한다.</p>
      </li><li>
        <p>물리적 백업<a id="d5e8025" class="indexterm"/></p>

        <p>물리적 백업이란 데이터베이스를 구성하는 물리적인 파일을 백업하는 것이며 운영체제에서 파일 복사 명령(COPY)으로
        백업하는 것을 뜻한다. 물리적 백업이 필요한 파일에는 데이터 파일과 아카이브 로그 파일<a id="d5e8028" class="indexterm"/>이 있다. 온라인 로그 파일은 NOARCHIVELOG 모드에서 데이터베이스 전체를 백업하여 복구할
        경우에만 의미가 있다.<a id="d5e8030" class="indexterm"/></p>

        <div class="caution" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">주의</h3>
          <p>데이터베이스가 운영 중일 때 운영체제의 파일 복사 명령을 사용하는 것은 안전하지 않으므로 주의한다.</p>
        </div>
      </li></ul></div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8034"/>11.2.1. 백업 종류</h3></div></div></div>
      

      <p>다음은 <span>Tibero</span>가 제공하는 백업의 종류이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>모드별 백업</p>

          <p>데이터베이스를 ARCHIVELOG 모드로 운영할 때와 그렇지 않았을 때 사용할 수 있는 백업 방법이
          다르다.</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">모드</th><th>설명</th></tr></thead><tbody><tr><td align="left">ARCHIVELOG 모드<a id="d5e8052" class="indexterm"/></td><td><p>온라인 백업(Online Backup) 또는 Hot Backup이라
                  한다.<a id="d5e8056" class="indexterm"/><a id="d5e8058" class="indexterm"/></p><p>데이터베이스가 운영 중일 때 백업할 수 있다. 백업이 가능한
                  파일은 컨트롤 파일의 생성문과 데이터 파일, 아카이브 로그 파일 등이 있다.</p><p>복구는
                  백업된 아카이브 로그 파일의 시점에 따라 데이터 파일의 백업 시점 전으로 복구할 수
                  있다.</p></td></tr><tr><td align="left">NOARCHIVELOG 모드<a id="d5e8064" class="indexterm"/></td><td><p>오프라인 백업(Offline Backup) 또는 Cold Backup이라
                  한다.<a id="d5e8068" class="indexterm"/><a id="d5e8070" class="indexterm"/></p><p>기본적으로 데이터베이스는 NOARCHIVELOG
                  모드이다.</p><p>데이터베이스를 구성하는 전체 파일은 반드시 <span>Tibero</span>가 정상적으로 종료된 상태에서 백업한다.
                  백업 때문에 서비스가 중지되면 안 된다. 복구는 데이터베이스를 백업받은 시점으로부터 복구할 수
                  있다.</p></td></tr></tbody></table>
          </div>
        </li><li>
          <p>Consistent 백업<a id="d5e8077" class="indexterm"/></p>

          <p><span>Tibero</span>를 정상적으로 종료한 상태에서 백업하는 방법이다. 실행
          예는 <a href="chapter_backuprecovery.html#sect_admin_backup_method" title="11.2.2. 백업 실행">“11.2.2. 백업 실행”</a>의 <a href="chapter_backuprecovery.html#sect_consistent_backup" title="11.2.2. Consistent 백업???TITLE???">"Consistent 백업"</a>을
          참고한다.</p>
        </li><li>
          <p>Inconsistent 백업<a id="d5e8085" class="indexterm"/></p>

          <p><span>Tibero</span>의 데이터베이스가 운영 중일 때 백업하거나 정상적으로
          종료되지 않은 상태에서 백업하는 방법이다. 실행 예는 <a href="chapter_backuprecovery.html#sect_admin_backup_method" title="11.2.2. 백업 실행">“11.2.2. 백업 실행”</a>의 <a href="chapter_backuprecovery.html#sect_inconsistent_backup" title="11.2.2. Inconsistent 백업???TITLE???">"Inconsistent 백업"</a>을 참고한다.
          <span><strong class="guibutton">단, NOARCHIVELOG 모드에서는 정합성 문제가 발생할 수 있으므로 이 방법은 허용되지
          않는다.</strong></span></p>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_admin_backup_method"/>11.2.2. 백업 실행</h3></div></div></div>
      

      <p>본 절에서는 <span>Tibero</span>가 제공하는 물리적 및 논리적인 백업 방법에 따라 백업을
      실행하는 예를 설명한다.</p>

      <div class="literallayout"><p/></div>

      <p>데이터 파일이나 로그 파일의 경우에는 데이터베이스 상태에 따라서 백업 받는 방법이 다르므로 이를 각각 데이터베이스가
      운영 중인 경우(Inconsistent 백업)와 그렇지 않은 경우(Consistent 백업)로 나누어서 설명한다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8101"/>컨트롤 파일 백업</h4>

      <p>컨트롤 파일은 물리적인 백업과 논리적인 백업을 모두 지원하지만, <span>Tibero</span>에서는 컨트롤 파일의 논리적인 백업을 추천한다. 물리적 백업은 제약사항과 사용법이 복잡하기 때문에 실수를
      방지하기 위해 보통 사용하지 않는 것이 좋다. 물리적 백업시 데이터의 정합성을 맞춰주기 위해 모든 데이터 파일을 백업한 후
      마지막에 컨트롤 파일을 백업해 주어야 한다. 데이터베이스의 구조에 변화가 일어난 경우에는 컨트롤 파일의 생성문을 백업하는 논리적
      백업을 사용하는 것을 권장한다.</p>

      <p>다음은 컨트롤 파일을 물리적 백업으로 <span>tibero</span>6/backup 디렉터리에 있는 ctrlfile1.ctl 파일에,
      논리적 백업으로 컨트롤 파일의 생성문을 ctrlfile1.sql 파일에 백업하는 예이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>컨트롤 파일의 물리적 백업</p>

          <div class="example"><a id="d5e8109"/><p class="title"><b>[예 11.1] 컨트롤 파일의 물리적 백업</b></p><div class="example-contents">
            

            

            <p/>

            <pre class="programlisting">SQL&gt; <span><strong class="guibutton">alter database backup controlfile to </strong></span>
     <span><strong class="guibutton">  '/<span>tibero</span>7/backup/ctrlfile1.ctl';</strong></span>

Altered.</pre>
          </div></div><br class="example-break"/>
        </li><li>
          <p>컨트롤 파일의 논리적 백업</p>

          <div class="example"><a id="d5e8118"/><p class="title"><b>[예 11.2] 컨트롤 파일의 논리적 백업</b></p><div class="example-contents">
            

            

            <pre class="programlisting">SQL&gt; <span><strong class="guibutton">alter database backup controlfile to trace as</strong></span>
     <span><strong class="guibutton">  '/<span>tibero</span>7/backup/ctrlfile1.sql' reuse NORESETLOGS;</strong></span>

Altered.</pre>
          </div></div><br class="example-break"/>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>생성된 ctrlfile1.sql 파일은 다음과 같은 내용을 포함한다.</p>

      <div class="example"><a id="d5e8126"/><p class="title"><b>[예 11.3] 백업된 컨트롤 파일 생성문</b></p><div class="example-contents">
        

        

        <pre class="programlisting">CREATE CONTROLFILE REUSE DATABASE "inventory"
 LOGFILE
 GROUP 0 (
 '/disk1/log001.log',
 '/disk2/log002.log'
 ) SIZE 1M,
 GROUP 1 (
 '/disk1/log003.log',
 '/disk2/log004.log'
 ) SIZE 1M,
 GROUP 2 (
 '/disk1/log005.log',
 '/disk2/log006.log'
 ) SIZE 1M
 NORESETLOGS
 DATAFILE
 '/disk1/system001.dtf',
 '/disk1/undo001.dtf'
 NOARCHIVELOG
 MAXLOGFILES 255
 MAXLOGMEMBERS 8
 MAXDATAFILES 100
 MAXBACKUPSET 500
 CHARACTER SET MSWIN949
 NATIONAL CHARACTER SET UTF16
 ; </pre>
      </div></div><br class="example-break"/>

      <p>RESETLOGS는 컨트롤 파일의 생성문에 지정한 대로 만들어진다. 이 생성문은 트레이스 파일을 생성한 후
      RESETLOGS를 필요로 할 경우에 사용하며, RESETLOGS가 필요하지 않은 경우는 NORESETLOGS로 수정하여 컨트롤
      파일을 생성할 때 적용할 수 있다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>컨트롤 파일의 생성문에는 임시 파일을 생성하는 내용이 없다. 컨트롤 파일을 생성한 후 <span>Tibero</span>를 기동하면 임시 파일은 존재하지 않는다. 컨트롤 파일을 새로 생성한 경우 반드시 임시 파일을 추가해야
        임시 파일을 이용한 기능을 사용할 수 있다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>생성된 컨트롤 파일은 $<span>TB_</span>SID.tip 파일에 경로를 설정한다.</p>

      <div class="example"><a id="d5e8136"/><p class="title"><b>[예 11.4] 컨트롤 파일 경로 설정</b></p><div class="example-contents">
        

        

        <pre class="programlisting">CONTROL_FILES=$<span>TB_</span>HOME/database/$<span>TB_</span>SID/</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>다음과 같이 MOUNT나 OPEN 상태에서 컨트롤 파일의 목록을 조회하려면 동적 뷰 V$CONTROLFILE를
      조회한다.</p><div class="example"><a id="example_controlfile_search"/><p class="title"><b>[예 11.5] 컨트롤 파일 조회</b></p><div class="example-contents">
          

          

          <pre class="programlisting">SQL&gt; <span><strong class="guibutton">SELECT NAME FROM V$CONTROLFILE;</strong></span>

NAME
------------------------------------------------------------
/disk1/c1.ctl
/disk2/c2.ctl

2 selected.</pre>
        </div></div><p><br class="example-break"/></p><div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
          <p>컨트롤 파일을 다시 생성하기 위해서는 $<span>TB_</span>SID.tip 파일에 설정된 컨트롤 파일의 위치를 <a href="chapter_backuprecovery.html#example_controlfile_search" title="[예 11.5] 컨트롤 파일 조회">[예 11.5]</a>의 질의 결과와 동일하게 설정한 후 CREATE
          CONTROLFILE 문을 실행해야 한다.</p>
        </div>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="sect_consistent_backup"/>Consistent
      백업<a id="d5e8156" class="indexterm"/></h4>

      <p>본 절에서는 <span>Tibero</span>가 정상적으로 종료한 후에 백업하는 방법을
      설명한다.</p>

      <div class="literallayout"><p/></div>

      <p>Consistent 백업을 실행 하기에 앞서 백업할 컨트롤 파일, 데이터 파일, 로그 파일을 조회한다.</p>

      <p>다음은 MOUNT나 OPEN 상태에서 동적 뷰 <span><strong class="guibutton">V$DATAFILE</strong></span>를 통해
      데이터 파일을 조회하는 방법이다. 여기서 MOUNT는 <span>Tibero</span>의 인스턴스가 시작된 상태이며, OPEN은 컨트롤 파일에 정의한 모든 파일이 오픈된 상태를
      의미한다.<a id="d5e8166" class="indexterm"/><a id="d5e8168" class="indexterm"/></p>

      <div class="example"><a id="d5e8170"/><p class="title"><b>[예 11.6] 데이터 파일의 조회</b></p><div class="example-contents">
        

        

        <pre class="programlisting">SQL&gt; <span><strong class="guibutton">SELECT NAME FROM V$DATAFILE;</strong></span>

NAME
------------------------------------------------------------
/disk1/system001.dtf
/disk2/undo001.dtf
/disk3/user001.dtf

3 selected.</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>다음은 온라인 로그 파일을 MOUNT나 OPEN 상태에서 조회하는 방법이다.</p>

      <div class="example"><a id="d5e8176"/><p class="title"><b>[예 11.7] 온라인 로그 파일의 조회</b></p><div class="example-contents">
        

        

        <pre class="programlisting">SQL&gt; <span><strong class="guibutton">SELECT MEMBER FROM V$LOGFILE;</strong></span>

MEMBER
------------------------------------------------------------
/disk1/log001.log
/disk2/log002.log
/disk2/log003.log
/disk3/log004.log
/disk3/log005.log
/disk1/log006.log

6 selected.</pre>
      </div></div><br class="example-break"/>

      <p>온라인 로그 파일은 ARCHIVELOG 모드가 아닌 경우에는 백업하지 않는 것이 좋다. ARCHIVELOG 모드에서는
      온라인 로그 파일이 아카이브되기 때문에 아카이브된 파일을 백업하면 안 된다. 참고로 아카이브된 파일은
      <code class="filename">LOG_ARCHIVE_DEST</code> 초기화 파라미터에 설정된 위치에 저장된다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      <p>데이터베이스는 다음과 같이 NORMAL 모드로 종료해야 한다.</p>

      

      <pre class="programlisting">SQL&gt; <span>tbdown</span> NORMAL;
<span>Tibero</span> instance was terminated.</pre>

      <p>데이터베이스가 정상적으로 종료되면 운영체제별로 제공하는 파일 복사 명령을 사용하여 백업한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="sect_inconsistent_backup"/>Inconsistent
      백업<a id="d5e8193" class="indexterm"/></h4>

      <p>본 절에서는 <span>Tibero</span>가 운영 중일 때 백업하는 방법을 설명한다.</p>

      <div class="literallayout"><p/></div>

      <p>데이터베이스가 운영 중이면 운영체제의 명령어를 사용해 데이터 파일을 복사하는 것은 안전하지 않다. 이러면 다음과 같은
      문장을 실행하여 <span>Tibero</span>에 백업의 시작과 종료를 통보해야 한다.</p>

      <pre class="programlisting">alter tablespace {tablespace name} begin backup
...
alter tablespace {tablespace name} end backup</pre>

      <p>begin backup과 end backup 문장 사이에는 해당 테이블 스페이스의 변경 사항에 대한 로그가 늘어나기
      때문에 데이터베이스에 부담이 가중되게 된다. begin backup을 시작한 이후에는 신속하게 백업을 완료하고 end backup
      상태로 복귀시켜야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>Inconsistent 백업의 전체 과정은 다음과 같다.<a id="d5e8204" class="indexterm"/></p>

      <div class="orderedlist"><ol type="1"><li>
          <p>먼저 백업할 테이블 스페이스를 선정한다.</p>

          <div class="example"><a id="d5e8209"/><p class="title"><b>[예 11.8] Inconsistent 백업 - 테이블 스페이스의 선정</b></p><div class="example-contents">
            

            

            <pre class="programlisting">SQL&gt; select name,type from v$tablespace;

NAME                           TYPE
------------------------------ ----
SYSTEM                         DATA
UNDO                           UNDO
USER                           DATA
TEMP                           TEMP

3 selected.</pre>
          </div></div><br class="example-break"/>
        </li><li>
          <p>백업할 테이블 스페이스에 속한 데이터 파일을 조회한 후 begin backup, end backup 명령어를
          사용하여 백업을 수행한다. 예를 들어 USER 테이블 스페이스를 백업할 경우를 가정하고 수행한다.</p>

          <div class="example"><a id="d5e8214"/><p class="title"><b>[예 11.9] Inconsistent 백업 - begin backup, end backup 명령어의 사용</b></p><div class="example-contents">
            

            

            <pre class="programlisting">SQL&gt; select f.name
     from v$tablespace t join v$datafile f on t.ts# = f.ts#
     where t.name = 'USER';

NAME
------------------------------------------------------------
/disk3/user001.dtf

1 selected

SQL&gt; alter tablespace SYSTEM begin backup;

Altered.

SQL&gt; !cp /disk3/user001.dtf /backup/
SQL&gt; alter tablespace  SYSTEM end backup;

Altered.</pre>
          </div></div><br class="example-break"/>
        </li></ol></div>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_admin_bar_recovery_mechanism"/>11.3. 복구</h2></div></div></div>
    

    <p><span>Tibero</span>를 운영하다 보면, 예상치 못한 장애로 인해 정상적인 데이터베이스
    운영이 어려운 상황이 발생할 수 있다. <span><strong class="guibutton">복구</strong></span>는 장애가 발생하는 경우 복원하는 일련의
    과정이다.<a id="d5e8224" class="indexterm"/><a id="d5e8226" class="indexterm"/></p>

    <p>복구를 하려면 백업된 데이터베이스가 있어야 한다. <span>Tibero</span>는 데이터베이스에서 일어나는 모든 변화를 로그 파일에 기록한다. 따라서 백업 이후에 데이터베이스에 일어난 모든
    변화에 대해서는 로그를 적용하면 복구할 수 있다. 로그 파일에는 커밋되지 않은 트랜잭션이 수정한 데이터도 포함되어 있다. 복구할 때
    아카이브 로그 파일과 로그 파일 모두 사용할 수 있다.</p>

    <div class="literallayout"><p/></div>

    <p>복구 과정은 다음과 같이 두 가지 경우로 수행할 수 있다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>데이터 파일에 기록되지 않는 변화를 로그를 사용하여 적용하는 과정</p>

        <p>데이터 파일에 모든 로그의 변화를 기록하는 과정을 통해서 데이터베이스는 안정된 상태가 된다. 즉, 데이터베이스
        운영상의 특정 시점까지 모든 작업이 반영되고 그 이후의 변화는 발생하지 않아야 한다. 데이터베이스에 정상적인 복구가 이루어져
        안정된 상태가 되어야만 기동할 수 있다.</p>
      </li><li>
        <p>커밋되지 않는 데이터로 복구하는 과정</p>

        <p>데이터베이스를 종료할 때 커밋하지 않은 트랜잭션이 수정한 내용으로 복구하는 과정이다.</p>
      </li></ul></div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8239"/>11.3.1. 부트 모드별 복구</h3></div></div></div>
      

      <p><span>Tibero</span>는 부트 모드별로 발생되는 작업을 복구 측면에서 보면 다음과
      같다.</p><div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>NOMOUNT 모드<a id="d5e8246" class="indexterm"/></p>

            <p>NOMOUNT 모드로는 언제나 복구할 수 있다. 이 모드에서는 데이터베이스와 컨트롤 파일을 생성할 수 있다.
            MOUNT 모드로 동작하기 위해서는 컨트롤 파일이 있어야 한다. 컨트롤 파일이 없거나 컨트롤 파일에 장애가 발생한
            경우에는 NOMOUNT 모드로 동작하며 컨트롤 파일을 생성하면 MOUNT 모드로 동작할 수 있다.</p>
          </li><li>
            <p>MOUNT 모드<a id="d5e8251" class="indexterm"/></p>

            <p>MOUNT 모드에서는 데이터 파일, 온라인 로그 파일, 컨트롤 파일 사이의 상태를 검사하여 <span>Tibero</span>를 기동할 준비를 한다. 세 파일이 모두 최신 상태이면 OPEN 모드로 동작할 수 있다. 파일에
            물리적인 장애가 발생하였거나, 복원된 파일이라면 미디어 복구가 필요하며 MOUNT 모드로 동작한다. MOUNT
            모드에서는 제한된 뷰의 조회가 가능하고, 미디어 복구를 수행할 수 있다.</p>
          </li><li>
            <p>OPEN 모드<a id="d5e8257" class="indexterm"/></p>

            <p><span>Tibero</span>의 데이터 파일, 온라인 로그 파일, 컨트롤 파일이
            일관성을 유지할 때에만 OPEN 모드로 동작할 수 있다. OPEN 모드에서 <span>Tibero</span>는 세 파일을 열고 정상으로 동작한다. 일반 사용자는 데이터베이스를 이용할 수 있다. 오프라인
            상태인 테이블 스페이스에 사용자가 접근하려면 우선 해당 테이블 스페이스를 온라인 상태로 전환해야 한다. 이때 다른
            파일들과 일관성을 유지하기 위해 해당 테이블 스페이스에 온라인 미디어 복구를 수행해야 한다.</p>
          </li></ul></div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_admin_bar_crash_recovery"/>11.3.2. 파손 복구<a id="d5e8265" class="indexterm"/><a id="d5e8267" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">파손 복구</strong></span>(Crash Recovery)는 <span>Tibero</span>를 운영하는 중에 정전, 시스템 이상, 강제 종료 등으로 데이터베이스가 비정상적으로 종료되었을 때 사용자의
      명령 없이 자동으로 복구되는 것을 의미한다. 복구가 완료되면 <span>Tibero</span>가 정상적으로 동작한다.</p>

      <p>파손 복구는 온라인 로그 파일의 내용 중 아직 데이터 파일에 반영되지 않은 부분을 기록하여 <span>Tibero</span>가 비정상적으로 종료되기 직전에 운영 시점의 상태로 복구하는 과정과 이러한 상태로 복구된 시점에서 커밋되지
      않은 트랜잭션이 발생시킨 변화를 되돌리는 과정으로 나눌 수 있다.</p>

      <p>파손 복구의 모든 과정은 파일의 손상이 없으면 DBA의 도움 없이 자동으로 이루어진다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>평균 파손 복구 시간 설정<a id="d5e8280" class="indexterm"/></p>

            <p><span>Tibero</span>는 평균 파손 복구 시간을 설정 할수 있는
            기능(Mean Crash Recovery Time)을 제공하고 있다. Mean Crash Recovery Time(이하
            MCRT)은 파손 복구시 필요한 I/O 횟수를 통제함으로써 평균 파손 복구 시간을 조절한다.</p>

            <p>MCRT는 다음 파라미터를 설정해서 조절할 수 있다.</p>

            <div class="informaltable">
                <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">_MCRT_TARGET</td><td>평균 파손 복구 시간을 설정한다. (기본값: 1800, 단위: 초)</td></tr></tbody></table>
              </div>
          </li></ul></div>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_admin_bar_media_recovery"/>11.3.3. 미디어 복구<a id="d5e8302" class="indexterm"/></h3></div></div></div>
      

      <p><span>Tibero</span>를 구성하는 파일이 물리적인 손상이나 정상적으로 동작할 수 없는
      경우가 발생할 수 있다. 이러한 경우 데이터베이스가 정상적으로 동작할 수 있도록 복구하는 과정이 <span><strong class="guibutton">미디어
      복구</strong></span>(Media Recovery)이다.</p>

      <p>미디어 복구 과정은 자동으로 이루어지지 않는다. DBA가 상황을 파악해서 필요한 과정을 지시하는 일련의 작업이
      필요하다. 복구 완료시점을 오류가 발생하기 이전의 가장 최근 시점까지로 할지, 과거의 특정 시점까지로 할지 여부에 따라서
      <span><strong class="guibutton">완전 복구</strong></span>(Complete Recovery)와 <span><strong class="guibutton">불완전
      복구</strong></span>(Incomplete Recovery)로 구분된다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8311"/>완전 복구<a id="d5e8312" class="indexterm"/></h4>

      <p>온라인 로그 파일의 가장 최근 로그까지 모두 반영하는 미디어 복구이다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8316"/>불완전 복구<a id="d5e8317" class="indexterm"/></h4>

      <p>온라인 로그 파일의 최근까지가 아닌 그 이전의 특정 시점까지 복구하는 것을 말한다. 불완전 복구 후에는 반드시
      RESETLOGS 모드로 <span>Tibero</span>를 기동해야 한다. RESETLOGS는 온라인 로그 파일을
      초기화하는 것이며, 현재 온라인 로그 파일로 데이터베이스를 시작하지 않을 때 사용한다.</p>

      <p>RESETLOGS가 필요한 경우는 다음과 같다. </p><div class="itemizedlist"><ul type="disc" compact="compact"><li>
            <p>불완전 미디어 복구를 한 경우</p>
          </li><li>
            <p>RESETLOGS로 컨트롤 파일을 생성한 경우</p>
          </li></ul></div><p>RESETLOGS로 시작하면 새로운 데이터베이스가 만들어진 것과 같다. RESETLOGS 이전의
      데이터 파일, 로그 파일과 RESETLOGS 이후의 파일은 서로 호환되지 않는다. RESETLOGS 이전의 백업 파일이나 로그
      파일을 이용하여 RESETLOGS 이후로 복구할 수 없다. 또한 RESETLOGS 이후의 파일을 RESETLOGS 이전 상태로
      불완전 복구를 하는 것도 불가능하다. 따라서 RESETLOGS 모드로 기동한 경우에는 반드시 새로 백업을 하기를
      권장한다.</p>

      <div class="literallayout"><p/></div>

      <p><span><strong class="guibutton">RESETLOGS</strong></span>로 데이터베이스를 기동하는 방법은 다음과 같다.</p>

      <div class="example"><a id="d5e8330"/><p class="title"><b>[예 11.10] RESETLOGS를 이용한 데이터베이스의 기동</b></p><div class="example-contents">
        

        

        <pre class="programlisting">$ <span>tbboot</span> -t RESETLOGS</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>미디어 복구 과정은 MOUNT 모드에서만 이루어진다. 백업된 파일을 사용하여 오류가 발생한 파일을 복원하는 과정과
      복원된 파일을 백업한 시점으로부터 최근 또는 특정 시점까지 반영되지 않은 변화를 로그 파일을 사용하여 복구하는 과정으로 나눌 수
      있다. 단순한 복원 과정만으로는 <span>Tibero</span>의 정상적인 운영이 불가능하다.</p>

      <p>미디어 복구를 위해 장애가 발생한 파일을 찾아 복구해야 한다. 이를 위해 다음과 같은 뷰를 제공한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>V$LOGFILE</p>
        </li><li>
          <p>V$CONTROLFILE</p>
        </li><li>
          <p>V$LOG</p>
        </li><li>
          <p>V$RECOVER_FILE</p>
        </li><li>
          <p>V$RECOVERY_FILE_STATUS</p>
        </li></ul></div>

      <p>미디어 복구는 로그 파일을 하나씩 데이터베이스에 순서대로 반영하여 진행한다. 데이터베이스는 현재 복구에 필요한 로그
      파일만을 반영할 수 있다. 현재 필요한 로그 파일을 찾기 위해 <span><strong class="guibutton">시퀀스 번호</strong></span>가
      사용된다.<a id="d5e8351" class="indexterm"/> 시퀀스 번호는 데이터베이스가 생성된 이후로 만들어진 로그 파일의 일련 번호이며, 모든 로그 파일은
      하나의 유일한 시퀀스 번호를 갖는다. 시퀀스 번호가 큰 로그 파일이 최근 로그 파일이다. 시퀀스 번호는 아카이브 로그 파일의 경우
      파일 이름을 통해 알 수 있고, 온라인 로그 파일의 경우 <span><strong class="guibutton">V$LOG</strong></span> 뷰를 통해 알 수
      있다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_admin_bar_online_media_recovery"/>11.3.4. 온라인 미디어 복구<a id="d5e8356" class="indexterm"/></h3></div></div></div>
      

      <p><span>Tibero</span>를 운영하는 도중에 일부 데이터 파일이 물리적으로 손상되거나
      정상적으로 동작할 수 없는 경우가 발생할 수 있다. 이러한 경우에 OPEN 모드에서 해당 데이터 파일이 포함된 테이블 스페이스만
      미디어 복구를 수행할 수 있다. 이것이 <span><strong class="guibutton">온라인 미디어 복구</strong></span>(Online Media
      Recovery)이다. 온라인 미디어 복구는 완전 복구만 가능하다.</p>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_admin_rmgr"/>11.4. 복구 관리자<a id="d5e8364" class="indexterm"/></h2></div></div></div>
    

    <p><span>Tibero</span>는 다양한 백업 및 복구 시나리오를 제공한다. 숙련된 데이터베이스
    관리자라면 상황에 맞는 적절한 방법을 선택하고 활용할 수 있을 것이다. 허나 너무 다양한 기능을 제공함으로써 오히려 사용자에게 혼란을
    줄 수도 있다. 이러한 면을 보완하기 위하여 <span>Tibero</span>는 복구 관리자(이하 RMGR)를 제공한다.</p>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8370"/>11.4.1. 기본 기능</h3></div></div></div>
      

      <p>RMGR은 다양한 백업/복구 시나리오를 지원하도록 구성되어 있다. <span>Tibero</span>에서 제공되는 RMGR의 기능은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>Online Full Backup<a id="d5e8377" class="indexterm"/></p>

          <p><span>Tibero</span> 데이터베이스에 속한 전체 데이터 파일을 온라인 백업한다.
          온라인 백업을 위해서는 데이터베이스가 ARCHIVELOG 모드이여야 한다. RMGR은 자동으로 데이터베이스의 Begin
          Backup 기능을 사용하여 모든 테이블 스페이스를 Hot Backup 상태로 만들고 백업을 진행한다.</p>

          <p>백업을 완료하면 데이터베이스의 End Backup 기능을 사용하여 모든 테이블 스페이스를 Hot Backup
          상태로부터 해제한다. 명령과 옵션들을 통해 백업이 진행/완료되어 하나의 Backup Set(백업 셋)이 생성되면,
          V$BACKUP_SET을 통해 진행 상황 및 해당 Backup Set에 사용한 옵션들을 확인할 수 있다.</p>
        </li><li>
          <p>Incremental Backup<a id="d5e8384" class="indexterm"/></p>

          <p>RMGR를 통해 온라인 백업을 받았으면 이를 이용하여 Incremental Backup을 할 수 있다.
          Incremental Backup이란 백업을 받을 때 전체 파일을 받는 것이 아니라 이전 백업과의 차이만을 기록하는
          방식으로 백업에 소모되는 디스크 공간을 획기적으로 줄일 수 있다.</p>

          <p>Incremental Backup을 하려면 이전에 RMGR를 통해 Online Full Backup을 받았어야
          한다. 현재 데이터베이스와 백업본과의 차이를 구하여 백업 파일을 만든다. 이러한 기능은 RMGR를 통해서만 사용할 수
          있다.</p>
        </li><li>
          <p>Block Change Tracking<a id="d5e8390" class="indexterm"/></p>

          <p>Incremental Backup은 이전 백업과 현재 운영 중인 데이터 파일 간의 변경된 사항만을 기록하여야
          하기 때문에 전체 데이터 파일을 스캔하여 백업본과의 차이점을 구하는 동작을 수행한다. 이러한 동작은 데이터 파일이 큰
          경우에는 데이터 파일을 모두 스캔하는 오버헤드가 크기 때문에 백업되는 파일의 용량은 적지만 시간이 오래 걸리는 단점이
          있다. 이런 단점을 보완하기 위해 <span>Tibero</span> 서버가 마지막 백업시점 이후의 데이터 파일의 변화
          내역을 기록하고 백업할 때 활용한다. 이 기능은 어떤 블록만 백업하면 될지 추적하기가 쉽기 때문에 Incremental
          Backup의 수행속도가 비약적으로 빨라질 수 있다. 이를 위해 RMGR 및 <span>Tibero</span> 서버는 Block Change Tracking(BCT)기능을 제공한다.</p>

          <p>BCT 기능을 사용하기 위해서는 <span>Tibero</span> 서버 tip 파일에 BCT 관련 파라미터를 설정하고 BCT 기능을 컨트롤하는 DDL을 수행해야 하며,
          LGWR AIO 기능과는 호환되지 않는다.</p>

          <div class="example"><a id="d5e8398"/><p class="title"><b>[예 11.11] <span>Tibero</span> 서버 tip 파일에 BCT 설정</b></p><div class="example-contents">
              

              

              <pre class="programlisting">BLOCK_CHANGE_TRACKING="/database/emp/emp_change.bct"</pre>
            </div></div><p><br class="example-break"/></p>

          <p/>

          <div class="example"><a id="d5e8404"/><p class="title"><b>[예 11.12] BCT 기능 사용</b></p><div class="example-contents">
              

              

              <pre class="programlisting">SQL&gt; ALTER SYSTEM ENABLE BLOCK CHANGE TRACKING;

System altered.     </pre>
            </div></div><p><br class="example-break"/></p>

          <p>RMGR은 Incremental Backup을 수행할 때 이 BCT 파일을 사용하여 백업할 블록들의 리스트를
          빠른 시간내에 탐색하여 백업을 효과적으로 수행할 수 있다. 해당 파일이 운영 중에 삭제되거나 장애가 생길 때에
          <span>Tibero</span> 서버는 자동적으로 BCT 기능을 중지하며 사용자는 다시
          BCT 기능을 DDL로 수행해야 한다.</p>

          <p/>

          <p>수동으로 BCT 기능을 중지하기 위해서는 다음의 DDL을 수행한다.</p>

          <div class="example"><a id="d5e8411"/><p class="title"><b>[예 11.13] BCT 기능 해제</b></p><div class="example-contents">
            

            

            <pre class="programlisting">SQL&gt; ALTER SYSTEM DISABLE BLOCK CHANGE TRACKING;

System altered.      </pre>
          </div></div><br class="example-break"/>

          <p>RMGR은 <span>Tibero</span> 서버에 현재 BCT 기능이 켜져있는지를 질의하여 이전
          백업부터의 블록 변화가 BCT 파일에 온전히 기록이 되었는지 확인한 후 유효한 BCT 파일이 존재할 때만 BCT를 이용한
          Incremental Backup을 수행한다. <span>Tibero</span> 서버는 Incremental Backup이 끝나면 백업이 끝난 시점부터 변경된 사항들을 BCT 파일에
          기록하게 된다.</p>
        </li><li>
          <p>Automatic Recovery<a id="d5e8419" class="indexterm"/></p>

          <p>RMGR을 이용하여 만들어진 백업본을 이용하여 자동 복구를 진행한다. 백업 정보는 컨트롤 파일에 저장이
          되어있다. 컨트롤 파일에 저장된 정보를 기반으로 Online Full Backup/Incremental Backup 정보를
          분석하여 자동으로 Merge 후 복구를 진행한다. 컨트롤 파일이 접근 불가능할때에는 백업된 컨트롤 파일을 이용하여 복구를
          진행한다. 단, 이때에는 특정 옵션을 사용하여 백업이 존재하는 백업 경로를 명시해주어야 한다.</p>

          <div class="caution" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">주의</h3>
              <p><span>TAC</span> 환경에서 RMGR을 이용한 복구를 진행하기 위해서는 구성
              노드 중 한 개의 노드만 떠있는 상황에서 복구를 진행해야 한다.</p>
            </div>
        </li><li>
          <p>Datafile/Tablespace 단위 백업 및 복구<a id="d5e8428" class="indexterm"/></p>

          <p>전체 데이터베이스를 백업/복구하는 대신에 필요한 데이터 파일 또는 테이블 스페이스만 대상으로 백업/복구 작업을
          수행할 수 있다. 복구할 때에는 데이터 파일 또는 테이블 스페이스는 각 백업 파일들을 가져온 후 복구 자체는 전체 복구로
          MOUNT 모드에서 진행된다.</p>
        </li><li>
          <p>Delete Backup Set<a id="d5e8433" class="indexterm"/></p>

          <p>RMGR을 이용하여 컨트롤 파일에 등록된 Backup Set(백업 셋)을 삭제할 수 있다. 삭제 대상이 되는
          Target Backup Set은 Backup Set ID를 직접 지정할 수 있으며(--bakcup-set 옵션), 특정
          시간을 명시하여 특정 시간 이전에 생성된 Backup Set들을 모두 지정할 수 있다(--beforetime
          옵션).</p>

          <p>삭제하고자 하는 Backup Set이 존재하는 백업 경로는 컨트롤 파일을 참조하여 결정하므로, 백업이 이루어진
          이후에 백업 경로가 변경된 경우에는 삭제하고자 하는 Backup Set이 존재하는 백업 경로(-o 옵션)를 명시해주어야
          한다. 만약 컨트롤 파일에 등록된 Backup Set을 사용자가 수동으로 삭제하였거나, 잘못된 백업 경로를 명시하여 백업
          경로에서 삭제 대상으로 지정된 Backup Set을 찾을 수 없는 경우에는 컨트롤 파일에 등록된 Backup Set
          Entry만을 삭제하고 종료할 수 있다(--cf-only 옵션).</p>
        </li><li>
          <p>Standby Backup<a id="d5e8439" class="indexterm"/></p>

          <p>RMGR을 이용하여 Tibero Standby Cluster 환경의 standby에서 백업을 진행할 수 있다.
          Standby의 백업 파일을 이용하여 standby, primary 모두 복구가 가능하다. Standby 환경에서 백업을
          진행할 때는 다음과 같은 제약사항이 추가된다. </p><div class="itemizedlist"><ul type="circle" compact="compact"><li>
                <p>--for-standby 옵션은 사용할 수 없다.</p>
              </li><li>
                <p>-w, --with-archivelog 옵션을 사용하려면 primary 접속에 필요한 정보를
                <span>tbdsn</span>.tbr에 설정한 후에 primary의 SID를
                $<span>TB_</span>SID.tip 파일에 초기화 파라미터
                RMGR_PRIMARY_SID로 설정해야 한다.</p>

                <div class="example"><a id="d5e8449"/><p class="title"><b>[예 11.14] Primary SID 설정</b></p><div class="example-contents">
                  

                  

                  <pre class="programlisting"># <span>tbdsn</span>.tbr
primary=(
        (INSTANCE=(HOST=168.1.1.33)
                  (PORT=8629)
                  (DB_NAME=tibero)
        )
)
# $<span>TB_</span>SID.tip
RMGR_PRIMARY_SID=primary </pre>
                </div></div><br class="example-break"/>
              </li></ul></div>
        </li></ul></div>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_rmgr_option"/>11.4.2. 복구 관리자 옵션</h3></div></div></div>
      

      <p>RMGR은 셸 명령으로 실행되며 다양한 옵션을 지정하여 원하는 기능을 사용할 수 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="140" align="left"/><col/></colgroup><thead><tr><th align="left">옵션</th><th>설명</th></tr></thead><tbody><tr><td align="left">backup</td><td>RMGR를 통해 백업을 진행하여 Backup Set을 생성한다.</td></tr><tr><td align="left">recover</td><td>RMGR로 백업한 Backup Set을 원하는 경로에 복원하여 복구를 진행한다.</td></tr><tr><td align="left">delete</td><td>RMGR로 받아놓은 백업본 중 사용자 입력으로 주어진 조건에 맞는 Backup Set을
              삭제한다.</td></tr><tr><td align="left">--userid</td><td><p>데이터베이스에 접속할 사용자명과 패스워드 및 SID를 아래와 같은 형식으로
              지정한다.</p><pre class="programlisting">--userid USERID[[/PASSWD][@SID]]</pre><p>화면상에
              비밀번호 노출을 원치 않을 때에는 비밀번호를 공백으로 입력한 후 비밀번호를 입력하라는 문구가 나오면 비공개로 번호를
              입력할 수 있다. </p><pre class="programlisting">--userid USERID/[@SID] </pre><p>OS
              인증을 받은 계정으로 로그인하는 경우 Userid와 Passwd를 입력하지 않아도 로그인 가능하다(단, 현재는
              backup과 delete 기능만 가능). </p><pre class="programlisting">--userid / </pre></td></tr><tr><td align="left">-h, --help</td><td>RMGR의 옵션 사용법을 출력한다.</td></tr><tr><td align="left">--interval</td><td><p>RMGR 백업/복구 진행률을 확인하여 출력해주는 실시간 시간 간격을 초 단위로
              조절한다.</p><p>기본값은 1 초이며, 최소 0.01 초까지 설정 가능하다. 0으로 설정하는 경우
              실시간 진행률을 확인하지 않는다.</p></td></tr><tr><td align="left">-v, --verbose</td><td>RMGR 백업/복구를 진행하는 경우 각 데이터 파일마다의 절대 경로를 출력한다.</td></tr><tr><td align="left">-s, --silent</td><td>RMGR 백업/복구를 진행하는 경우 각 데이터 파일마다의 진행률을 출력하지 않는다.</td></tr><tr><td align="left">-l, --log-level</td><td><p>클라이언트 측 RMGR 로그(<span>tbrmgr_trace.log</span>)의 기록 레벨을
              설정한다.</p><p>레벨은 1부터 5까지 있으며 숫자가 커질 수록 더 자세히 기록된다. 기본 레벨은
              4이다.</p></td></tr><tr><td align="left">-L</td><td><p><span>tbrmgr_trace.log</span>의 기록될 위치를 지정한다.
              </p><p>기본 경로는 <span>$TB_HOME/client/tbrmgr_log/</span>이다.</p></td></tr><tr><td align="left">-o</td><td><p>백업, 복구 및 삭제에 사용될 디렉터리 경로를 지정한다.</p><p>백업할 때
              옵션을 사용하지 않을 경우 RMGR_BACKUP_DEST가 기본 경로로 설정된다. 복구의 경우 옵션을 사용하지
              않으면 각 Backup Set마다 백업된 경로를 자동으로 찾아간다.</p><p>옵션을 사용할 경우 모든
              Full/Incremental Backup Set 및 아카이브 로그 백업 셋들이 해당 경로에 있어야 한다.
              콤마(,)로 구분된 다중경로를 16개까지 지원한다. 백업을 제외한 복구 및 삭제에서 다중경로 옵션을 사용하는 경우,
              명시한 디렉터리 경로는 모두 유효해야 한다.</p><pre class="programlisting"><span>tbrmgr </span> backup -o /backup/
<span>tbrmgr </span> backup -o /backup1/,/backup2/</pre><p>아카이브
              로그의 경우 다중경로 삭제 기능을 지원하지 않는다.</p></td></tr><tr><td align="left">-n</td><td><p>NetBackup을 사용하는 경우 백업/복구에 사용될 NetBackup 경로를 지정한다.
              </p><p>백업할 때 옵션을 사용하지 않을 경우 RMGR_NBU_BACKUP_DEST가 기본 경로로
              설정된다. 이외 특이 사항은 -o 옵션과 동일하며, 복구/삭제가 동작할 때 -o와 -n을 동시에 사용할 수
              있다.</p><p>USE_NBU_FOR_BACKUPSET 파라미터를 Y로 사용할 경우 기본 백업/경로는
              로컬이 아닌 NetBackup 경로가 우선적이다.</p></td></tr><tr><td align="left">-i, --incremental</td><td>가장 최신 백업에 대한 Incremental backup을 수행한다.</td></tr><tr><td align="left">-C, --cumulative</td><td>마지막 Full backup에 대한 Incremental backup을 수행한다.</td></tr><tr><td align="left">-w, --with-archivelog</td><td><p>백업/복구를 수행할 때 hot backup을 복구하기 위한 아카이브 로그 파일도 함께
              백업/복원한다.</p><p>기본적으로 클러스터 환경에서는 모든 Instance들이 Shared disk로
              모두 같은 LOG_ARCHIVE_DEST를 공유해야 정상적으로 동작한다. 이는 Active stroage를 사용하는
              경우도 마찬가지이다.</p><p>NetBackup을 사용하는 경우
              USE_NBU_FOR_ARCHIVELOG=Y인 경우엔 옵션 사용 불가하다.</p><p>백업된 아카이브
              로그 파일은 다음의 형식으로 관리된다. </p><pre class="programlisting">bkl_&lt;<span class="emphasis"><em>BACKUPSET#</em></span>&gt;_t&lt;<span class="emphasis"><em>THREAD#</em></span>&gt;-r&lt;<span class="emphasis"><em>RESETLOGS_TSN</em></span>&gt;-s&lt;<span class="emphasis"><em>SEQUENCE#</em></span>&gt;.arc</pre><p>예를
              들어 BACKUPSET#는 1, THREAD#는 0, RESETLOGS TSN는 0, SEQEUNCE#는 1인 경우
              파일명은 'bkl_1_t0-r0-s1.arc'이 된다. </p></td></tr><tr><td align="left">-a, --archive-only</td><td><p>가장 최근에 백업한 아카이브 로그 백업 셋 이후에 생성된 아카이브 로그 파일들을 모두
              백업한다. 복구할 때 필요한 경우 자동으로 함께 사용된다.</p><pre class="programlisting"><span>tbrmgr</span> backup --archive-only</pre><p>특정
              Redo 스레드의 아카이브 로그의 특정 시퀀스를 지정하여 해당 시퀀스 이상부터 최신까지의 아카이브 로그 파일들을
              백업할 수도 있다(--thread, --from-seq 옵션).</p><pre class="programlisting"><span>tbrmgr</span> backup --archive-only --thread &lt;<span class="emphasis"><em>THREAD#</em></span>&gt; --from-seq &lt;<span class="emphasis"><em>SEQUENCE#</em></span>&gt;</pre><p>NetBackup을
              사용하는 경우 USE_NBU_FOR_ARCHIVELOG=Y인 경우엔 옵션 사용 불가하다.</p></td></tr><tr><td align="left">-p, --parallel</td><td><p>복구 전용 Process의 스레드들은 각자 하나의 데이터 파일을 담당하는데, 스레드 개수를
              명시하여 여러 스레드를 할당하여 병렬적으로 백업/복구를 수행한다. 기본값은 1이며 최대값은 16이다. 이는
              (RECO_PROC_WTHR_CNT - _CACHE_RECO_DOP -3)/2로 조정할 수 있다.
              </p><pre class="programlisting"><span>tbrmgr</span> backup --parallel &lt;<span class="emphasis"><em>THREAD_COUNT</em></span>&gt;</pre></td></tr><tr><td align="left">-u, --skip-unused</td><td>아직 사용되지 않은 깨끗한 블록은 백업하지 않는다. 보통 백업에 소용되는 시간은 늘어나고 생성되는 파일
              크기를 줄일 수 있다.</td></tr><tr><td align="left">-c, --compress</td><td><p>백업을 수행할 때 데이터를 압축하여 저장한다. </p><p>LOW, MEDIUM,
              BASIC, HIGH로 옵션을 추가하여 압축 정도를 지정할 수 있다. 옵션을 지정하지 않으면 BASIC 옵션으로
              압축이 진행된다. LOW &gt; MEDIUM &gt; BASIC &gt; HIGH 순으로 압축속도가 빠르며,
              HIGH &gt; BASIC &gt; MEDIUM &gt; LOW 순으로 압축률이
              높다.</p><pre class="programlisting"><span>tbrmgr</span> backup --compress [LOW|MEDIUM|BASIC|HIGH]</pre></td></tr><tr><td align="left">-d, --datafile</td><td><p>백업/복구할 대상 데이터 파일을 지정한다. 지정할 때에는 데이터 파일 번호를 명시해야 하며,
              콤마(,)를 사용하여 여러 개를 명시할 수 있다.</p><pre class="programlisting"><span>tbrmgr</span> backup  --datafile &lt;<span class="emphasis"><em>DATAFILE#1,DATAFILE#2,...</em></span>&gt;</pre></td></tr><tr><td align="left">-t, --tablespace</td><td><p>백업/복구할 대상 테이블 스페이스를 지정한다. 지정할 때에는테이블 스페이스 이름을 명시해야
              하며, 콤마(,)를 사용하여 여러 개를 명시할 수 있다.</p><pre class="programlisting"><span>tbrmgr</span> backup --tablespace &lt;<span class="emphasis"><em>TABLESPACE_NAME1,TABLESPCE_NAME2,...</em></span>&gt;</pre></td></tr><tr><td align="left">-T, --skip-tablespace</td><td><p>백업/복구 대상에서 제외할 테이블 스페이스를 지정한다. 지정할 때에는테이블 스페이스 이름을
              명시해야 하며, 콤마(,)를 사용하여 여러 개를 명시할 수
              있다.</p><pre class="programlisting"><span>tbrmgr</span> backup --skip-tablespace &lt;<span class="emphasis"><em>TABLESPACE_NAME1,TABLESPACE_NAME2,...</em></span>&gt;</pre></td></tr><tr><td align="left">--skip-readonly</td><td>백업/복구 대상에서 Read only 테이블 스페이스들은 제외한다.</td></tr><tr><td align="left">--skip-offline</td><td>백업/복구 대상에서 Offline 테이블 스페이스들은 제외한다.</td></tr><tr><td align="left">--untiltime</td><td><p>시간기반 불완전 복구를 수행한다.</p><p>옵션에서 지정한 시간까지 변경된
              내용만 복구된다.</p><p>시간은 YYYYMMDDHH24MISS의
              형식이다.</p><pre class="programlisting"><span>tbrmgr</span> recover --untiltime &lt;<span class="emphasis"><em>YYYYMMDDHH24MISS</em></span>&gt;</pre></td></tr><tr><td align="left">--untilchange</td><td><p>변경 기반 불완전 복구를 수행한다.</p><p>옵션에서 지정한 TSN까지 변경된
              내용만 복구된다.</p><pre class="programlisting"><span>tbrmgr</span> recover --untilchange &lt;<span class="emphasis"><em>TSN</em></span>&gt;</pre></td></tr><tr><td align="left">--from-seq</td><td><p>해당 옵션 사용하여 아카이브 로그의 특정 시퀀스를 지정할 수 있고, 해당 시퀀스 부터 마지막
              시퀀스, 또는 특정 시퀀스까지 백업/복구한다(--to-seq 옵션).</p><p>무조건 Redo 스레드를
              지정해주어야 한다(--thread 옵션).</p><pre class="programlisting"><span>tbrmgr</span> backup --thread &lt;<span class="emphasis"><em>THREAD#</em></span>&gt; --from-seq &lt;<span class="emphasis"><em>SEQUENCE#</em></span>&gt;</pre></td></tr><tr><td align="left">--to-seq</td><td><p>해당 옵션 사용하여 아카이브 로그의 특정 시퀀스를 지정할 수 있고, 해당 시퀀스까지 모두
              복구한다.</p><p>무조건 Redo 스레드를 지정해주고(--thread 옵션), 구간을 정해주어야
              한다(--from-seq 옵션).</p><pre class="programlisting"><span>tbrmgr</span> recover --thread &lt;<span class="emphasis"><em>THREAD#</em></span>&gt; --from-seq &lt;<span class="emphasis"><em>SEQUENCE#</em></span>&gt; --to-seq &lt;<span class="emphasis"><em>SEQUENCE#</em></span>&gt;</pre></td></tr><tr><td align="left">--thread</td><td>아카이브 로그 백업/복구할 때 Redo 스레드를 지정한다.</td></tr><tr><td align="left">--arc-dest-force</td><td>아카이브 로그 백업/복구할 때 대상 구간에 임의의 아카이브 로그 파일을 찾을 수 없어도 실패하지 않고
              진행되게 한다.</td></tr><tr><td align="left">--delete-original</td><td>아카이브 로그 백업/복구 후 백업 본이 아닌 원본 파일들을 삭제한다.</td></tr><tr><td align="left">--with-password-file</td><td>MOUNT 모드에서 SYS 계정 로그인에 필요한 password file을 함께
              백업/복구한다.</td></tr><tr><td align="left">--no-rollback</td><td>백업 도중 취소/실패하는 경우 기존에 백업한 파일들을 롤백하지 않고 보존한다.</td></tr><tr><td align="left">--continue</td><td>백업 파일을 가져오지 않고 복구만 진행한다. 주로 아카이브 로그 파일들을 소량씩 가져오며 불완전 복구를
              단계적으로 하려고할 때 사용할 수 있다. MOUNT 모드에서만 사용 가능하다.</td></tr><tr><td align="left">--for-standby</td><td><p>Standby 구축을 위한 백업/복구를 진행한다. </p><p>모든 데이터
              파일들과 복구에 필요한 아카이브 로그 파일, 그리고 온라인 Redo 로그 파일들까지 백업/복구한다. 클러스터 환경에
              대한 제약 사항이 --with-archivelog와 동일하다. NetBackup 연동을 지원하지
              않는다.</p></td></tr><tr><td align="left">--recover-to</td><td><p>Backup Set을 지정한 특정 경로에 가져온 후 복구를 수행한다. 데이터베이스와 컨트롤
              파일이 알고 있는 파일들의 경로도 함께 변경된다. Active storage 경로도
              가능하다.</p><pre class="programlisting"><span>tbrmgr</span> recover --recover-to &lt;<span class="emphasis"><em>NEW_DIRECTORY</em></span>&gt; </pre></td></tr><tr><td align="left">--restore-only</td><td><p>대상 백업 데이터 파일들을 가져온 후 복구는 수행하지 않는다.
              </p><p>MOUNT 또는 NORMAL 모드에서 사용 가능하며, NORMAL 모드에서는 무조건
              Offline 테이블 스페이스들을 지정해야 한다.</p><pre class="programlisting"><span>tbrmgr</span> recover --restore-only</pre></td></tr><tr><td align="left">--restore-archive-only</td><td><p>대상 백업 아카이브 로그 파일들을 가져온 후 복구는 수행하지 않는다. 무조건
              --from-seq, --to-seq, --thread 옵션을 함께 사용해야 한다. MOUNT 또는 NORMAL
              모드에서 사용 가능하다. </p><p>NetBackup을 사용하는 경우
              USE_NBU_FOR_ARCHIVELOG=Y인 경우엔 옵션 사용이 불가하다.</p></td></tr><tr><td align="left">--wallet</td><td><p>암호화된 테이블 스페이스에 접근하기 위한 인증작업을 수행한다.</p><p>사용자가
              명시한 PASSWORD를 통해 WALLET을 열고 복구를 시작한다.
              </p><pre class="programlisting"><span>tbrmgr</span> recover --wallet &lt;<span class="emphasis"><em>WALLET_PASSWORD</em></span>&gt;</pre></td></tr><tr><td align="left">-b, --backup-set</td><td>지정한 Backup Set을 삭제하거나 복구 시에는 지정한 Backup Set부터 탐색하여
              가져온다.</td></tr><tr><td align="left">--archivelog</td><td>컨트롤 파일에 기록된 아카이브 로그들을 삭제하고, 사용자가 경로를 지정한 경우에는 해당 경로에 있는
              아카이브 로그들도 삭제한다. --beforetime, --beforechange 혹은
              --sent-to-standby 옵션과 같이 사용되어야 한다.</td></tr><tr><td align="left">--before-time</td><td><p>명시한 시점 이전의 Backup Set들 혹은 아카이브 로그들을 삭제한다.
              </p><p>시간은 YYYYMMDDHH24MISS의
              형식이다.</p><pre class="programlisting"><span>tbrmgr</span> delete --before-time &lt;<span class="emphasis"><em>YYYYMMDDHH24MISS</em></span>&gt;</pre></td></tr><tr><td align="left">--beforechange</td><td>명시한 TSN 이전의 아카이브 로그들을 삭제한다.</td></tr><tr><td align="left">--cf-only</td><td>실제 Backup Set 혹은 아카이브 로그의 물리적 파일은 삭제하지 않고 컨트롤 파일에서만 정보를
              삭제한다. 백업 파일을 사용자가 수동으로 삭제하였거나, 삭제 대상 Backup Set을 물리적으로 찾지 못할 때
              사용 가능하다.</td></tr><tr><td align="left">--sent-to-standby</td><td>Standby로 전송이 완료된 아카이브 로그들을 삭제한다. --archivelog 옵션과 같이
              사용되어야 하며, --beforetime 또는 --beforechange와 같이 사용될 수 있다.</td></tr><tr><td align="left">--switch</td><td><p>데이터베이스의 파일이름을 Backup Set의 백업 파일의 이름으로 바꿔준다. 테이블
              스페이스를 지정할 수 있다. NetBackup을 사용한 Backup Set에 대해서는 지원하지
              않는다.</p><pre class="programlisting"><span>tbrmgr</span> recover --switch </pre></td></tr><tr><td align="left">--no-image-logging</td><td>백업을 수행할 때 기존의 image logging 방식이 아닌 block consistency
              check 방식을 이용한다. standby에서 백업을 수행할 경우 옵션 사용 여부 상관없이 block
              consistency check 방식으로 진행한다. 백업에 소요되는 시간은 늘어나지만 백업하는 동안 발생하는 온라인
              redo 로그의 크기는 줄어든다.</td></tr></tbody></table>
      </div>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8744"/>11.4.3. 복구 관리자를 이용한 백업 및 복구 예제<a id="d5e8746" class="indexterm"/></h3></div></div></div>
      

      <p>본 절에서는 다음의 백업/복구 시나리오를 통해서 RMGR을 이용한 백업/복구를 설명한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_1" title="[예 11.15] Online Full Backup 시나리오">Online Full Backup
          시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_2" title="[예 11.16] Compress 옵션과 Skip Unused 옵션을 적용한 Online Full Backup 시나리오">Compress 옵션과 Skip Unused
          옵션을 적용한 Online Full Backup 시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_3" title="[예 11.17] With Archive Log 옵션을 적용한 Online Full Backup 시나리오">With Archive Log 옵션을 적용한
          Online Full Backup 시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_4" title="[예 11.18] With Archive Log 옵션을 적용한 Incremental Backup 시나리오">With Archive Log 옵션을 적용한
          Incremental Backup 시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_5" title="[예 11.19] Online Full Backup을 이용한 복구 시나리오">Online Full Backup을 이용한 복구
          시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_6" title="[예 11.20] Online Full Backup과 Archive Log Backup을 이용한 복구 시나리오">Online Full Backup과
          Archive Log Backup을 이용한 복구 시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_7" title="[예 11.21] Online Full Backup과 Incremental Backup을 이용한 복구 시나리오">Online Full Backup과
          Incremental Backup을 이용한 복구 시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_8" title="[예 11.22] Tablespace 기반 복구 시나리오">Tablespace 기반 복구
          시나리오</a></p>
        </li></ul></div>

      <div class="caution" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">주의</h3>
        <p><span>RMGR의 Online(Full / Incremental) Backup을 통해 생성된 Backup
        Set을 이용하여 복구를 수행하기 위해서는 Archive Log File이 반드시 필요하다. 따라서 Archive Log
        File이 유실될 경우에 대비하여 Online(Full / Incremental) Backup의 경우 Archive Log
        File도 함께 Backup (--with-archivelog 옵션) 해두는 것이 바람직하다.
        TAC</span> 환경에서는 RMGR을 이용한
        Archive Log Backup이 지원되지 않는다.</p>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      <p>RMGR은 대부분의 과정을 자동으로 진행하기 때문에 사용자가 실행 명령을 통해 작업을 명시해준 이후에는 특별히 관리해야
      할 사항이 없다. RMGR이 작업을 진행하는 동안에는 작업의 진행 과정을 살펴볼 수 있다.</p>

      <p>RMGR을 통해 Backup을 진행한 이후에는 V$BACKUP_SET을 통해 Backup Set 정보를 조회할 수
      있으며, V$BACKUP_ARCHIVED_LOG를 통해 Archive Log Backup 정보를 조회할 수 있다.
      V$BACKUP_SET_TABLESPACE를 조회하면 각 Backup Set에 대한 테이블 스페이스 정보를 확인할 수
      있다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>데이터 파일이 Raw Device 파일 및 <span>Tibero
        </span>Active Storage인
        경우에도 RMGR을 이용한 백업 및 복구가 가능하다. 단, Active Storage를 사용할 때 미리 Active
        Storage Instance를 설정 및 부팅을 해야 한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e8787"/>Online Full Backup 시나리오</h4>

      <p>RMGR을 이용하여 임의의 백업 경로에서 Online Full Backup을 수행할 수 있으며(-o 옵션), 백업
      경로를 명시하지 않은 경우에는 RMGR_BACKUP_DEST가 기본 dest로 설정된다.</p>

      <div class="example"><a id="ex_backuprecovery_1"/><p class="title"><b>[예 11.15] Online Full Backup 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbrmgr</span> backup -o<span> /home/tbrdb/work/7/backup/  </span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - ONLINE backup
=============================================
DB connected
archive log check succeeded
 100.00% |=======================================&gt;|  12800/12800  blks 0.08s
Synchronizing...
 100.00% |=======================================&gt;|  25600/25600  blks 0.18s
Synchronizing...
 100.00% |=======================================&gt;|  12800/12800  blks 0.10s
Synchronizing...
 100.00% |=======================================&gt;|   1280/1280   blks 0.02s
Synchronizing...
Database full backup succeeded
DB disconnected
RMGR backup ends

$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         1 2018/06/11
2018/06/11                                                            36321
     36338             0          0     453588 NO         NO
NO

1 row selected.

SQL&gt; select * from V$BACKUP_ARCHIVED_LOG;

0 row selected.</pre>
        </div></div><p><br class="example-break"/></p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8801"/>Compress 옵션과 Skip Unused 옵션을 적용한 Online Full Backup
      시나리오</h4>

      <p>데이터를 압축하여 Backup Set을 생성하는 Compress(-c) 옵션과 실제로 사용되지 않은 블록을 백업
      대상에서 제외하는 Skip Unused(-u) 옵션을 함께 적용하여 Online Full Backup을 수행할 수
      있다.</p>

      <div class="example"><a id="ex_backuprecovery_2"/><p class="title"><b>[예 11.16] Compress 옵션과 Skip Unused 옵션을 적용한 Online Full Backup
          시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbrmgr</span> backup -c -u -o<span> /home/tbrdb/work/7/backup/  </span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - ONLINE backup
=============================================
DB connected
archive log check succeeded
 100.00% |=======================================&gt;|  12800/12800  blks 1.00s
Synchronizing...
 100.00% |=======================================&gt;|  25600/25600  blks 1.85s
Synchronizing...
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
 100.00% |=======================================&gt;|   1280/1280   blks 0.06s
Synchronizing...
Database full backup succeeded
DB disconnected
RMGR backup ends
</pre>
        </div></div><p><br class="example-break"/></p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8813"/>With Archive Log 옵션을 적용한 Online Full Backup
      시나리오</h4><p>RMGR을 이용한 Backup을 수행하는 경우 with Archive
      Log(--with-archivelog) 옵션을 적용함으로써, 백업 경로에 데이터 파일에 대한 백업과 함께 Archive Log
      Backup을 생성할 수 있다. Online Backup을 이용하여 복구를 수행하기 위해서는 Archive Log가 반드시
      필요하므로, Archive Log Backup을 생성함으로써 원본 Archive Log File이 유실되는 경우에도 정상적으로
      복구를 진행할 수 있다.</p>

      <p/>

      <p>백업된 아카이브 로그 파일은 다음의 형식으로 관리된다.</p>

      <pre class="programlisting">bkl_&lt;<span class="emphasis"><em>BACKUPSET#</em></span>&gt;_t&lt;<span class="emphasis"><em>THREAD#</em></span>&gt;-r&lt;<span class="emphasis"><em>RESETLOGSTSN</em></span>&gt;-s&lt;<span class="emphasis"><em>SEQUENCE#</em></span>&gt;.arc</pre>

      <p>예를 들어 BACKUPSET#는 1, THREAD#는 0, RESETLOGS TSN는 0, SEQEUNCE#는 1인
      경우 파일명은 'bkl_1_t0-r0-s1.arc'이 된다.</p>

      <div class="literallayout"><p/></div>

      <p>V$BACKUP_SET을 조회함으로써 각 Backup Set에 Archive Log Backup이 존재하는지 확인할 수
      있으며, V$BACKUP_ARCHIVED_LOG를 조회함으로써 Archive Log Backup의 정보를 확인할 수
      있다.</p>

      <div class="example"><a id="ex_backuprecovery_3"/><p class="title"><b>[예 11.17] With Archive Log 옵션을 적용한 Online Full Backup 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbrmgr</span> backup --with-archivelog -o<span> /home/tbrdb/work/7/backup/  </span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - ONLINE backup
=============================================
DB connected
archive log check succeeded
 100.00% |=======================================&gt;|  12800/12800  blks 0.08s
Synchronizing...
 100.00% |=======================================&gt;|  25600/25600  blks 0.18s
Synchronizing...
 100.00% |=======================================&gt;|  12800/12800  blks 0.08s
Synchronizing...
 100.00% |=======================================&gt;|   1280/1280   blks 0.02s
Synchronizing...
Database full backup succeeded
DB disconnected
RMGR backup ends

$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         1 2016/06/16
2016/06/16                                                           34386 
     34441             0          0     453588 NO         NO
YES


1 row selected.

SQL&gt; set line 200
SQL&gt; col MIN_LOG_TIME for a20
SQL&gt; col MAX_LOG_TIME for a20
SQL&gt; col RESETLOG_TIME for a20
SQL&gt; select * from V$BACKUP_ARCHIVED_LOG a;

    SET_ID MIN_LOG_TSN MAX_LOG_TSN MIN_LOG_TIME         MAX_LOG_TIME
---------- ----------- ----------- -------------------- --------------------
         1       34386       34441 2016/06/16           2016/06/16

MIN_LOG_SEQUENCE MAX_LOG_SEQUENCE RESETLOG_TSN RESETLOG_TIME
---------------- ---------------- ------------ --------------------
               2                2            0

1 row selected.</pre>
        </div></div><p><br class="example-break"/></p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8838"/>With Archive Log 옵션을 적용한 Incremental Backup
      시나리오</h4>

      <p>앞서 Online Full Backup을 통해 생성된 Full Backup Set이 최소 1개 이상 존재하는 경우에는
      가장 최신의 Backup Set과 현재 상태를 비교하여 변경사항만을 백업하는 Incremental Backup을 수행할 수 있다.
      변경사항만을 백업하므로 Full Backup Set에 비해 Backup Set의 Size를 획기적으로 줄일 수 있지만, 앞선
      Backup Set이 유실되어 비교 대상이 사라지게 되면 Backup Set을 데이터베이스 복구에 사용할 수 없는 위험성이
      존재한다.</p>

      <p>V$BACKUP_SET을 조회함으로써 각 Backup Set이 Incremental Backup Set인지 확인할 수
      있으며, Incremental Backup의 경우 비교 대상이 되는 Backup Set(Base Set)의 ID를 확인할 수
      있다. Full Backup Set의 경우 Base Set이 존재하지 않으므로 Base Set ID가 0으로
      표기된다.</p>

      <div class="example"><a id="ex_backuprecovery_4"/><p class="title"><b>[예 11.18] With Archive Log 옵션을 적용한 Incremental Backup 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbrmgr</span> backup -i --with-archivelog -o<span> /home/tbrdb/work/7/backup/ </span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - INCREMENTAL backup
=============================================
DB connected
archive log check succeeded
 100.00% |=======================================&gt;|  12800/12800  blks 0.04s
Synchronizing...
 100.00% |=======================================&gt;|  25600/25600  blks 0.04s
Synchronizing...
 100.00% |=======================================&gt;|  12800/12800  blks 0.02s
Synchronizing...
 100.00% |=======================================&gt;|   1280/1280   blks 0.02s
Synchronizing...
Database incremental backup succeeded
DB disconnected
RMGR backup ends

$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         1 2016/06/16
2018/06/11                                                            34386
     34441             0          0     453588 NO         NO
YES

         2 2016/06/16
2018/06/11                                                            34448
     35234             0          1      23730 NO         YES
YES


2 rows selected.

SQL&gt; set line 200
SQL&gt; col MIN_LOG_TIME for a20
SQL&gt; col MAX_LOG_TIME for a20
SQL&gt; col RESETLOG_TIME for a20
SQL&gt; select * from V$BACKUP_ARCHIVED_LOG a;

    SET_ID MIN_LOG_TSN MAX_LOG_TSN MIN_LOG_TIME         MAX_LOG_TIME
---------- ----------- ----------- -------------------- --------------------
         1       34386       34441 2016/06/16           2016/06/16
         2       34448       35234 2016/06/16           2016/06/16


MIN_LOG_SEQUENCE MAX_LOG_SEQUENCE RESETLOG_TSN RESETLOG_TIME
---------------- ---------------- ------------ --------------------
               2                2            0
               6                6            0

2 row selected.</pre>
        </div></div><p><br class="example-break"/></p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8854"/>Online Full Backup을 이용한 복구 시나리오</h4>

      <p>RMGR은 Online Full Backup을 통해 생성된 Backup Set을 이용하여 복구를 수행할 수 있다. 아래
      예제는 Backup Set에 Archive Log Backup이 존재하지 않는 경우로, 이 경우에는 원본 Archive Log
      File을 가지고 있어야 복구를 진행할 수 있다.</p>

      <div class="example"><a id="ex_backuprecovery_5"/><p class="title"><b>[예 11.19] Online Full Backup을 이용한 복구 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         1 2016/06/16
2016/06/16                                                           34386 
     34441             0          0     453588 NO         NO
NO

1 row selected.

SQL&gt; quit
Disconnected.

$ <span>tbrmgr</span> recover -o<span> /home/tbrdb/work/7/backup/  </span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - recovery
=============================================
<span>Tibero</span> instance terminated (ABNORMAL mode).

Control file #0 (<span>/home/tbrdb/work/7/database/TB7/c1.ctl</span>) is accessible
Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (MOUNT mode).
DB Connected

RMGR BEGIN RESTORE
 full backup set_id: 1
 last incremental backup set_id: 1

Applying FULL BACKUP (set_id:1, ts_id:0, df_id:0)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:1, df_id:1)
 100.00% |=======================================&gt;|  25600/25600  blks 0.20s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:3, df_id:2)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:4, df_id:3)
 100.00% |=======================================&gt;|   1280/1280   blks 0.00s
Synchronizing...
Database restore succeeded
recoverSQL: ALTER DATABASE RECOVER AUTOMATIC
Database automatic recovery succeeded
DB disconnected

<span>Tibero</span> instance terminated (NORMAL mode).

Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (NORMAL mode).
RMGR recovery ends</pre>
        </div></div><p><br class="example-break"/></p>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8879"/>Online Full Backup과 Archive Log Backup을 이용한 복구
      시나리오</h4>

      <p>RMGR은 Online Full Backup을 통해 생성된 Backup Set을 이용하여 데이터베이스 복구를 수행할 수
      있다. 아래 예제는 원본 Archive Log File이 유실된 경우로, with Archive
      Log(--with-archivelog) 옵션을 통해 Archive Log Backup을 Restore하는 경우에는 정상적으로
      복구가 진행되지만, with Archive Log(--with-archivelog) 옵션을 적용하지 않고 복구를 수행하는 경우에는
      복구에 실패하는 것을 확인할 수 있다.</p>

      <div class="example"><a id="ex_backuprecovery_6"/><p class="title"><b>[예 11.20] Online Full Backup과 Archive Log Backup을 이용한 복구 시나리오</b></p><div class="example-contents">
        

        

        <pre class="programlisting">$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         1 2016/06/16
2016/06/16                                                           34386 
     34441             0          0     453588 NO         NO
YES

1 row selected.

SQL&gt; set line 200
SQL&gt; col MIN_LOG_TIME for a20
SQL&gt; col MAX_LOG_TIME for a20
SQL&gt; col RESETLOG_TIME for a20
SQL&gt; select * from V$BACKUP_ARCHIVED_LOG a;

    SET_ID MIN_LOG_TSN MAX_LOG_TSN MIN_LOG_TIME         MAX_LOG_TIME
---------- ----------- ----------- -------------------- --------------------
         1       34386       34441 2016/06/15           2016/06/16

MIN_LOG_SEQUENCE MAX_LOG_SEQUENCE RESETLOG_TSN RESETLOG_TIME
---------------- ---------------- ------------ --------------------
               2                2            0

1 row selected.

SQL&gt; quit
Disconnected.

<span><strong class="guibutton">$ <span>tbrmgr</span> recover -o<span> /home/tbrdb/work/7/backup/  </span></strong></span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - recovery
=============================================
<span>Tibero</span> instance terminated (ABNORMAL mode).

Control file #0 (<span>/home/tbrdb/work/7/database/TB7/c1.ctl</span>) is accessible
Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (MOUNT mode).
DB Connected

RMGR BEGIN RESTORE
 full backup set_id: 1
 last incremental backup set_id: 1

Applying FULL BACKUP (set_id:1, ts_id:0, df_id:0)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:1, df_id:1)
 100.00% |=======================================&gt;|  25600/25600  blks 0.20s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:3, df_id:2)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:4, df_id:3)
 100.00% |=======================================&gt;|   1280/1280   blks 0.00s
Synchronizing...
Database restore succeeded
recoverSQL: ALTER DATABASE RECOVER AUTOMATIC
<span><strong class="guibutton">RMGR Error: recovery failed (automatic recovery failed)
SVR Error:  Unable to find archive log file for thread 0 from change 34428.</strong></span>


<span><strong class="guibutton">$ <span>tbrmgr</span> recover --with-archivelog -o<span> /home/tbrdb/work/7/backup/  </span></strong></span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - recovery
=============================================
<span>Tibero</span> instance terminated (ABNORMAL mode).

Control file #0 (<span>/home/tbrdb/work/7/database/TB7/c1.ctl</span>) is accessible
Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (MOUNT mode).
DB Connected

RMGR BEGIN RESTORE
 full backup set_id: 1
 last incremental backup set_id: 1

Applying FULL BACKUP (set_id:1, ts_id:0, df_id:0)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:1, df_id:1)
 100.00% |=======================================&gt;|  25600/25600  blks 0.20s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:3, df_id:2)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:4, df_id:3)
 100.00% |=======================================&gt;|   1280/1280   blks 0.00s
Synchronizing...
Database restore succeeded
recoverSQL: ALTER DATABASE RECOVER AUTOMATIC
<span><strong class="guibutton">Database automatic recovery succeeded</strong></span>
DB disconnected

<span>Tibero</span> instance terminated (NORMAL mode).

Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (NORMAL mode).
RMGR recovery ends</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8913"/>Online Full Backup과 Incremental Backup을 이용한 복구
      시나리오</h4>

      <p>RMGR은 Online Full Backup을 통해 생성된 Backup Set과 Incremental Backup을
      통해 생성된 Backup Set을 자동으로 Merge하여 복구를 진행한다.</p>

      <div class="example"><a id="ex_backuprecovery_7"/><p class="title"><b>[예 11.21] Online Full Backup과 Incremental Backup을 이용한 복구 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         1 2016/06/16
2018/06/11                                                            34386
     34441             0          0     453588 NO         NO
YES

         2 2016/06/16
2018/06/11                                                            34448
     35234             0          1      23730 NO         YES
YES


2 rows selected.

SQL&gt; set line 200
SQL&gt; col MIN_LOG_TIME for a20
SQL&gt; col MAX_LOG_TIME for a20
SQL&gt; col RESETLOG_TIME for a20
SQL&gt; select * from V$BACKUP_ARCHIVED_LOG a;

    SET_ID MIN_LOG_TSN MAX_LOG_TSN MIN_LOG_TIME         MAX_LOG_TIME
---------- ----------- ----------- -------------------- --------------------
         1       34386       34441 2016/06/16           2016/06/16
         2       34448       35234 2016/06/16           2016/06/16

MIN_LOG_SEQUENCE MAX_LOG_SEQUENCE RESETLOG_TSN RESETLOG_TIME
---------------- ---------------- ------------ --------------------
               2                2            0
               6                6            0

2 row selected.

SQL&gt; quit
Disconnected.

$ <span>tbrmgr</span> recover --with-archivelog -o<span> /home/tbrdb/work/7/backup</span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - recovery
=============================================
<span>Tibero</span> instance terminated (ABNORMAL mode).

Control file #0 (<span>/home/tbrdb/work/7/database/TB7/c1.ctl  </span>) is accessible
Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (MOUNT mode).
DB Connected

RMGR BEGIN RESTORE
 full backup set_id: 1
 last incremental backup set_id: 2

Applying FULL BACKUP (set_id:1, ts_id:0, df_id:0)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:1, df_id:1)
 100.00% |=======================================&gt;|  25600/25600  blks 0.20s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:3, df_id:2)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Applying FULL BACKUP (set_id:1, ts_id:4, df_id:3)
 100.00% |=======================================&gt;|   1280/1280   blks 0.00s
Synchronizing...
Applying INCREMENTAL BACKUP (set_id:2, ts_id:0, df_id:0)
 100.00% |=======================================&gt;|  12800/12800  blks 0.60s
Synchronizing...
Applying INCREMENTAL BACKUP (set_id:2, ts_id:1, df_id:1)
 100.00% |=======================================&gt;|  25600/25600  blks 1.20s
Synchronizing...
Applying INCREMENTAL BACKUP (set_id:2, ts_id:3, df_id:2)
 100.00% |=======================================&gt;|  12800/12800  blks 0.80s
Synchronizing...
Applying INCREMENTAL BACKUP (set_id:2, ts_id:4, df_id:3)
 100.00% |=======================================&gt;|   1280/1280   blks 0.00s
Synchronizing...
Database restore succeeded
recoverSQL: ALTER DATABASE RECOVER AUTOMATIC
Database automatic recovery succeeded
DB disconnected

<span>Tibero</span> instance terminated (NORMAL mode).

Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (NORMAL mode).
RMGR recovery ends</pre>
        </div></div><p><br class="example-break"/></p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8936"/>Tablespace 기반 복구 시나리오</h4>

      <p/>

      <p>RMGR은 사용자가 Tablespace Name으로 지정한(--tablespace 옵션) 특정 테이블 스페이스에
      대해서만 복구를 수행할 수 있다. V$BACKUP_SET_TABLESPACE을 조회함으로써 각 Backup Set에 포함된 테이블
      스페이스를 확인할 수 있다.</p>

      <div class="example"><a id="ex_backuprecovery_8"/><p class="title"><b>[예 11.22] Tablespace 기반 복구 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col NAME for a20
SQL&gt; select * from V$TABLESPACE a;

       TS# NAME                 TYPE BIGFILE FLASHBACK_ON
---------- -------------------- ---- ------- ------------
         0 SYSTEM               DATA NO      NO
         1 UNDO                 UNDO NO      NO
         2 TEMP                 TEMP NO      NO
         3 USR                  DATA NO      NO
         4 SYSSUB               DATA NO      NO

5 rows selected.

SQL&gt; select * from V$BACKUP_SET_TABLESPACE;

    SET_ID        TS#
---------- ----------
         1          0
         1          1
         1          3
         1          4

4 rows selected.

SQL&gt; quit
Disconnected.

$ <span>tbrmgr</span> recover --tablespace USR -o<span> /home/tbrdb/work/7/backup/  </span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
RMGR - recovery
=============================================
<span>Tibero</span> instance terminated (ABNORMAL mode).

Control file #0 (<span>/home/tbrdb/work/7/database/TB7/c1.ctl</span>) is accessible
Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (MOUNT mode).
DB Connected

RMGR BEGIN RESTORE
 full backup set_id: 1
 last incremental backup set_id: 1

Applying FULL BACKUP (set_id:1, ts_id:3, df_id:2)
 100.00% |=======================================&gt;|  12800/12800  blks 0.00s
Synchronizing...
Database restore succeeded
recoverSQL: ALTER DATABASE RECOVER AUTOMATIC
Database automatic recovery succeeded
DB disconnected

<span>Tibero</span> instance terminated (NORMAL mode).

Listener port = 45648

<span>Tibero</span> 7

<span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.
<span>Tibero</span> instance started up (NORMAL mode).
RMGR recovery ends</pre>
        </div></div><p><br class="example-break"/></p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8958"/>11.4.4. 복구 관리자를 이용한 백업 삭제 예제</h3></div></div></div>
      

      <p>본 절에서는 다음의 백업 삭제 시나리오를 통해서 RMGR을 이용한 백업 삭제를 설명한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_9" title="[예 11.23] Backup Set ID에 기반한 백업 삭제 시나리오">Backup Set ID에 기반한 백업 삭제
          시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_backuprecovery_10" title="[예 11.24] Backup Date에 기반한 백업 삭제 시나리오">Backup Date에 기반한 백업 삭제
          시나리오</a></p>
        </li></ul></div>

      <p>RMGR을 이용하여 Backup Set을 삭제하는 경우, 삭제 대상이 되는 Target Backup Set은 두 가지
      방식으로 지정할 수 있다. 첫 번째로 Backup Set ID(--backup_set 옵션)를 명시하여 해당 Backup
      Set만을 삭제할 수 있으며, 두 번째로 Backup Date(--beforetime 옵션)를 명시하여 명시한 Backup
      Date 이전에 백업이 이루어진 모든 Backup Set들을 삭제할 수 있다.</p>

      <p>RMGR은 컨트롤 파일을 참조하여 삭제 대상으로 지정된 Backup Set의 존재 유무와 백업 경로를 확인한 후 삭제를
      진행한다. 따라서 컨트롤 파일에서 참조할 수 없는 Backup Set은 RMGR을 이용하여 삭제할 수 없으며, Backup
      Set이 존재하는 백업 경로가 백업할 때 컨트롤 파일에 등록된 백업 경로와 다른 경우에는 Backup Dest(-o 옵션)를 직접
      명시해주어야 변경된 백업 경로에서 실제 백업된 파일에 대한 삭제를 진행할 수 있다.</p>

      <p>컨트롤 파일에 등록되어 있는 Backup Set 정보는 V$BACKUP_SET을 통해 조회할 수 있으며, 각
      Backup Set에 속하는 Archive Log 정보는 V$BACKUP_ARCHIVED_LOG를 통해 조회할 수
      있다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>컨트롤 파일에 등록된 Backup Set을 사용자가 수동으로 삭제하였거나, 잘못된 백업 경로를 명시하여 백업
        경로에서 삭제 대상으로 지정된 Backup Set을 찾을 수 없는 경우에는 컨트롤 파일에 등록된 Backup Set
        Entry만을 삭제하고 종료한다. 또한 테이프 장비에 저장된 경우 역시 컨트롤 파일에 등록된 Backup Set Entry만을
        삭제하고 종료한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8974"/>Backup Set ID에 기반한 백업 삭제 시나리오</h4>

      <p>RMGR은 사용자가 Backup Set ID로 지정한(--backup_set 옵션) 특정 Backup Set만을
      선택적으로 삭제할 수 있다.</p>

      <p>다음 예제에서는 RMGR을 이용하여 Backup Set ID = 1에 해당하는 Backup Set을
      삭제한다.</p>

      <div class="example"><a id="ex_backuprecovery_9"/><p class="title"><b>[예 11.23] Backup Set ID에 기반한 백업 삭제 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         1 2018/06/11
2018/06/11                                                            37093
     37109             0          0     453588 NO         NO
YES

         2 2018/06/11
2018/06/11                                                            37361
     37377             0          0     453588 NO         NO
YES

         3 2018/06/11
2018/06/11                                                            37390
     37406             0          0     453588 NO         NO
YES


3 rows selected.

SQL&gt; quit
Disconnected.

$ <span>tbrmgr</span> delete --backup_set 1 -o<span> /home/tbrdb/work/7/backup</span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - delete
=============================================
DB connected
 #1 of #3 backup sets erased
RMGR delete ends

$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         2 2018/06/11
2018/06/11                                                            37361
     37377             0          0     453588 NO         NO
YES

         3 2018/06/11
2018/06/11                                                            37390
     37406             0          0     453588 NO         NO
YES


2 rows selected.</pre>
        </div></div><p><br class="example-break"/></p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e8991"/>Backup Date에 기반한 백업 삭제 시나리오</h4>

      <p>RMGR은 사용자가 Backup Date로 지정한(--beforetime 옵션) 시간 이전에 생성된 모든 Backup
      Set을 삭제할 수 있다.</p>

      <p>다음 예제에서는 RMGR을 이용하여 "2016년 06월 17일 12시" 이전에 생성된 모든 Backup Set을
      삭제한다. Backup Date는 YYYYMMDDHH24MISS 형태로 명시한다.</p>

      <div class="example"><a id="ex_backuprecovery_10"/><p class="title"><b>[예 11.24] Backup Date에 기반한 백업 삭제 시나리오</b></p><div class="example-contents">
        

        

        <pre class="programlisting">$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

    SET_ID START_TIME
---------- ----------------------------------------------------------------
FINISH_TIME                                                       START_TSN
---------------------------------------------------------------- ----------
FINISH_TSN RESETLOGS_TSN   BASE_SET   SIZE(KB) IS_PARTIAL IS_INCREMENTAL
---------- ------------- ---------- ---------- ---------- --------------
WITH_ARCHIVELOG
---------------
         2 2018/06/11
2018/06/11                                                            37361
     37377             0          0     453588 NO         NO
YES

         3 2018/06/11
2018/06/11                                                            37390
     37406             0          0     453588 NO         NO
YES

2 rows selected.

SQL&gt; quit
Disconnected.

$ <span>tbrmgr</span> delete --beforetime 20180612120000 -o<span> /home/tbrdb/work/7/backup/  </span>
==================================================================
= Recovery Manager(RMGR) starts                                  =
=                                                                =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved. =
==================================================================
=============================================
  RMGR - delete
=============================================
DB connected
 #2 of #2 backup sets erased
RMGR delete ends

$ <span>tbsql</span> sys/<span>tibero</span>

SQL&gt; set line 200
SQL&gt; col START_TIME for a20
SQL&gt; col FINISH_TIME for a20
SQL&gt; select * from V$BACKUP_SET a;

0 rows selected.</pre>
      </div></div><br class="example-break"/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_admin_netbackup"/>11.5. <span>Tibero</span>와 NetBackup 연동</h2></div></div></div>
    

    <p>NetBackup은 엔터프라이즈 백업 및 복구 소프트웨어로서, 다양한 환경에 대한 완벽하고 유연한 데이터 보호 솔루션을
    제공한다.</p>

    <p><span>Tibero</span>에서 복구 관리자를 사용해서 Veritas NetBackup으로
    백업 파일 저장 및 복원할 수 있다. 아래에서 소개할 <span>Tibero</span>와 NetBackup 연동을 위해서는 NetBackup과 <span>Tibero</span>가 정상적으로 설치되어 있어야 한다.</p>

    <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>1. NetBackup 연동을 위해서는 TmaxData 기술지원에 요청하여 NetBackup 연동이 가능한
        Tibero를 별도로 제공 받아야 한다.</p>

        <p>2. NetBackup 설치 및 관리에 대한 자세한 내용은 "NetBackup Documentation"을
        참고한다.</p>
      </div>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9018"/>11.5.1. NetBackup 환경설정</h3></div></div></div>
      

      <p>복구 관리자를 사용해서 NetBackup의 백업 파일 저장 및 복원하기 위해서 라이브러리를 연결하고, NetBackup
      서버 및 클라이언트의 기본 정보를 설정해야 한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9024"/>NetBackup에 필요한 <span>Tibero</span> 라이브러리 연결 설정</h4>

      <p>초기 상태에는 $TB_HOME/client/lib에 있는 dummy 라이브러리들과 연결되어 있다. dummy
      라이브러리들은 사용하지 않으면 삭제하거나 직접 NetBackup 관련 라이브러리를 연결해주어야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>32bit 환경</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>libnbclientcST32.so</p>
            </li><li>
              <p>libnbbasecST32.so</p>
            </li><li>
              <p>libxbsa.so</p>
            </li><li>
              <p>libvxcPBXST.so</p>
            </li></ul></div>
        </li><li>
          <p>64bit 환경</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>libnbclientcST.so</p>
            </li><li>
              <p>libnbbasecST.so</p>
            </li><li>
              <p>libxbsa64.so</p>
            </li><li>
              <p>libvxcPBXST.so</p>
            </li></ul></div>
        </li></ul></div>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9053"/>NetBackup 서버 및 클라이언트 기본 설정</h4>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>NetBackup 서버가 설치된 머신의 /etc/hosts 파일에 해당 머신의 호스트와 IP 주소 및
          NetBackup 클라이언트가 설치된 머신들의 호스트와 IP 주소를 추가한다.</p>
        </li><li>
          <p>NetBackup 서버가 설치된 머신에서 NetBackup이 설치된 경로에 db/altnames 디렉터리를
          생성한 후 NetBackup 클라이언트가 설치된 머신들의 호스트를 이름으로 가지는 빈 파일을 생성한다.</p>
        </li><li>
          <p>NetBackup 클라이언트가 설치된 머신의 /etc/hosts 파일에 NetBackup 서버가 설치된 머신의
          호스트와 IP 주소를 추가하고, 해당 머신의 호스트와 IP 주소를 추가한다.</p>
        </li><li>
          <p>NetBackup 클라이언트가 설치된 머신에서 NetBackup이 설치된 경로에 있는 bp.conf 파일에
          다음의 내용을 추가한다.</p>

          <pre class="programlisting">SERVER=[<span class="emphasis"><em>NetBackup 서버가 설치된 머신의 호스트</em></span>] 
CLIENT_NAME=[<span class="emphasis"><em>NetBackup 클라이언트가 설치된 머신의 호스트</em></span>] </pre>
        </li></ul></div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9071"/>복구 관리자를 위한 NetBackup 관리자 환경설정</h4>

      <p>다음은 복구 관리자를 사용하기 위해서 NetBackup 관리자 환경을 설정하는 방법에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>NetBackup 관리자 콘솔이 설치된 머신의 /etc/hosts에 NetBackup 마스터가 설치된 머신의
          호스트와 IP 주소를 추가한다.</p>
        </li><li>
          <p>NetBackup 관리자 콘솔 실행한 후 NetBackup 마스터가 설치된 머신의 root와 해당하는 비밀번호로
          접속한다.</p>
        </li><li>
          <p>NetBackup 관리자 콘솔의 <span><strong class="guibutton">[Master Server]</strong></span> 탭에서
          <span><strong class="guibutton">'Configure Disk Storage Servers'</strong></span>를 선택하여
          NetBackup 마스터에서 사용할 디스크를 'AdvancedDisk'로 선택한다. ReadyStream 이후 실제 백업에
          사용할 디렉터리를 선택한다.</p>
        </li><li>
          <p>NetBackup 관리자 콘솔 <span><strong class="guibutton">[Policies]</strong></span> 탭에서 New
          Policy를 생성한다. Policy의 이름은 NBU_BACKUP_POLICY_NAME,
          NBU_ARCHIVE_POLICY_NAME iparam에서 설정한 값으로 생성한다.</p>

          <p><span><strong class="guibutton">[Attributes]</strong></span> 탭의 <span><strong class="guibutton">'Policy
          type'</strong></span>을 'DataStore'로 생성하고 그외는 임의로 설정한다.
          <span><strong class="guibutton">[Clients]</strong></span> 탭에서 <span><strong class="guibutton">[New]</strong></span>
          버튼을 클릭하고 NetBackup 클라이언트를 설치한 머신을 등록한다.</p>
        </li><li>
          <p>NetBackup 관리자 콘솔의 <span><strong class="guibutton">[Host Properties]</strong></span> 탭에
          있는 <span><strong class="guibutton">[Clients]</strong></span> 탭에 앞서 등록한 NetBackup 클라이언트 머신이
          표시되고 실제 정보와 일치하는지 확인한다.</p>
        </li><li>
          <p>복구 관리자의 옵션 중 -p, --parallel 옵션을 사용할 수 있도록 아래와 같이 설정한다.</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>Storage unit 설정에서 해당 스토리지에 Maximum concurrent jobs를
              parallel로 실행될 thread 개수의 최대값으로 설정한다(<span>Tibero</span>는 최대 16개를 parallel로 사용하고
              있다).</p>
            </li><li>
              <p>Master server 설정에서 <span><strong class="guibutton">[Global
              Attribute]</strong></span> 탭에 있는 Maximum jobs per client 값을 하나의
              클라이언트에서 parallel로 실행될 thread 개수의 최대값으로 설정한다.</p>
            </li><li>
              <p>Master server 설정에서 <span><strong class="guibutton">[Client
              Attribute]</strong></span> 탭에 있는 Maximum data streams 값을 하나의 클라이언트에서
              parallel로 실행될 thread 개수의 최대값으로 설정한다.</p>
            </li><li>
              <p>Policy 설정에 있는 <span><strong class="guibutton">[Schedules Tab]</strong></span>의
              스케줄마다 설정에서 Media multiplexing 값을 하나의 클라이언트에서 parallel로 실행될
              thread 개수의 최대값으로 설정한다.</p>
            </li></ul></div>
        </li></ul></div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9110"/>11.5.2. 복구 관리자 환경설정</h3></div></div></div>
      

      <p>NetBackup에서는 백업 파일에 대한 권한 관리가 이루어지 때문에 복구 관리자를 위한 파라미터들이 정상적으로
      설정되지 않은 상태에서 백업이 수행되면 복구가 불가능해질 수 있다.</p>

      <p>다음은 복구 관리자의 환경설정에 사용되는 파라미터에 대한 설명이다. 각 파라미터는 <span><strong class="guibutton">동적
      설정</strong></span>이 가능하다.</p>

      <div class="informaltable">
          <table border="1"><colgroup><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">파라미터</th><th>설명</th></tr></thead><tbody><tr><td align="left">USE_NBU_FOR_BACKUPSET</td><td><p>다음은 설정값에 대한 설명이다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                      <p>Y : 복구 관리자에 의한 BackupSet 생성은 모두 NetBackup 서버에 전송되어
                      생성된다.</p>
                    </li><li style="list-style-type: circle">
                      <p>N : NetBackup 서버에 저장된 BackupSet을 가져올 수 있다.
                      (기본값)</p>
                    </li></ul></div><p>TAC 환경에서는 모든 노드가 동일한 값으로 설정되어 있어야
                한다.</p></td></tr><tr><td align="left">USE_NBU_FOR_ARCHIVELOG</td><td><p>설정 값이 Y일 경우 데이터베이스에서 생성되는 아카이브 로그가 NetBackup 서버에
                전송되어 생성되며, 복구할 때에도 NetBackup 머신에 존재하는 아카이브 로그를 읽어 복구를 진행한다.
                (기본값:
                N)</p><p><span><strong class="guibutton">[참고]</strong></span></p><p>USE_NBU_FOR_ARCHIVELOG=Y일
                경우 with-archivelog, archive-only, restore-archive-only 기능은
                지원하지 않는다.</p></td></tr><tr><td align="left">NBU_ARCHIVELOG_SEARCH</td><td><p>설정 값이 Y일 경우 NetBackup에 생성된 아카이브 로그들을
                v$archive_dest_files로 조회 가능하고 이를 읽어 복구할 수 있다.
                </p><p>(기본값: N)</p></td></tr><tr><td align="left">NBU_OBJ_OWNER_NAME</td><td>NetBackup을 통해 생성되는 백업 파일의 권한을 해당 파라미터에 설정한 값으로 설정해주며,
                복구할 때에는 해당 파라미터의 값이 아닌 클라이언트 머신에서 로그인한 username을 참고한다. (기본값:
                "")</td></tr><tr><td align="left">NBU_OBJ_OWNER_GROUP_NAME</td><td><p>NetBackup을 통해 생성되는 백업 파일의 권한을 해당 파라미터에 설정한 값으로
                설정해주며, 복구할 때에는 해당 파라미터의 값이 아닌 클라이언트 머신에서 로그인한 group anme을
                참고한다. </p><p>해당 값을 설정해주지 않으면 NBU_OBJ_OWNER_NAME으로 설정해준
                user name에만 권한이 있게된다. (기본값: "")</p></td></tr><tr><td align="left">NBU_CLIENT_COUNT</td><td><p><span>Tibero</span> 인스턴스가 위치하는 독립적인 머신을 숫자로
                설정한다. </p><p>0에서 10 사이로 설정해주어야 하며,
                NBU_ARCHIVELOG_SEARCH를 Y로 설정한 경우 NBU_CLIENT_COUNT의 값과
                NBU_CLIENT_HOSTNAME_#의 수가 같아야 한다. (기본값: 0)</p></td></tr><tr><td align="left">NBU_CLIENT_HOSTNAME_#</td><td>SID#N을 인스턴스 ID로 갖는 <span>Tibero</span> 인스턴스가 위치하는 머신의 호스트로 #을
                0부터 시작해 설정한다. (기본값: "")</td></tr><tr><td align="left">NBU_SKIP_HOST_CHECK</td><td>설정값이 Y일 경우 <span>Tibero</span> 인스턴스가 위치하는 머신의 호스트와
                NBU_CLIENT_HOSTNAME_0에 설정되어 있는 값이 같은지 비교하지 않는다. (기본값:
                N)</td></tr><tr><td align="left">NBU_BACKUP_INST_SID</td><td>NBU_CLIENT_HOSTNAME_0에 설정된 머신의 호스트에 해당하는 <span>Tibero</span> 인스턴스의 SID로 설정한다. (기본값:
                "")</td></tr></tbody></table>
        </div><div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
          <p>for-standby 기능은 지원하지 않는다.</p>
        </div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9175"/>11.5.3. 복구 관리자를 이용한 NetBackup 사용 예제</h3></div></div></div>
      

      <p>연동 절차가 모두 완료된 후 복구 관리자로 백업을 수행했을 때 아래와 같이 NetBackup에 백업한다는 메시지가
      찍히고 백업이 정상적으로 진행된다면 연동에 성공한 것이다.</p>

      <div class="example"><a id="ex_netbackup"/><p class="title"><b>[예 11.25] NetBackup 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">$ <span>tbrmgr</span> backup
==============================================================================
= Recovery Manager(RMGR) starts                                              =
=                                                                            =
= <span>TmaxData</span> Corporation Copyright (c) 2008-. All rights reserved.      =
==============================================================================
RMGR '-n' option not used (USE_NBU_FOR_BACKUPSET=Y)
:backing up to RMGR_NBU_BACKUP_DEST= /tibero/

==============================================================================
    RMGR - Backup (FULL)
==============================================================================
Initializing the backup progress, it may take few minutes...

BACKUP   (set_id:  1, ts_id:  0, df_id:  0)
 100.00% |===============================&gt;|  12800/12800  blks   16.01s
Synchronizing...
BACKUP   (set_id:  1, ts_id:  1, df_id:  1)
 100.00% |===============================&gt;|  25600/25600  blks   17.02s
Synchronizing...
BACKUP   (set_id:  1, ts_id:  3, df_id:  2)
 100.00% |===============================&gt;|  12800/12800  blks   16.01s
Synchronizing...
BACKUP   (set_id:  1, ts_id:  4, df_id:  3)
 100.00% |===============================&gt;|   1280/1280   blks   15.04s
Synchronizing...

Switching an online logfile...

Backing up the control file...
Control file backup seucceeded

Database backup succeeded

RMGR backup ends
$ <span>tbsql</span> sys/<span>tibero</span>
SQL&gt; select * from V$BACKUP_SET;

    SET_ID STATUS
---------- -------------------------------------
START_TIME           FINISH_TIME          ELAPSED(SEC)
-------------------- -------------------- ------------
START_TSN  FINISH_TSN RESETLOGS_TSN   SIZE(MB)   BASE_SET BACKUP_TYPE
---------- ---------- ------------- ---------- ---------- ------------
BACKUP_OPTION                            PARTIAL_BACKUP_OPTION
---------------------------------------- --------------------------------------
BACKUP_PATH
-------------------------------------------------------------------------------
          1 COMPLETED
2020/12/30           2020/12/30                    83
36321      36338             0            445          0  FULL
NET_BACKUP                               NONE
/tibero/

1 row selected.        </pre>
        </div></div><p><br class="example-break"/></p>

      <p>앞서 기술한 미지원 기능 목록을 제외한 나머지 복구 관리자 기능 역시 수행하여 위와 동일한 메시지를 확인할 수 있다면
      NetBackup 연동에 성공한 것으로 볼 수 있다. 복구 관리자에서 실제로 생성된 백업 파일 이름, 갯수와 NetBackup에서
      생성되는 파일 이름, 갯수가 다른 사실은 복구에 영향을 주지 않는다.</p>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_admin_fbdb"/>11.6. 플래시백 데이터베이스<a id="d5e9189" class="indexterm"/></h2></div></div></div>
    

    <p><span>Tibero</span>는 다양한 백업 및 복구 시나리오를 제공하지만, 백업 파일 용량이
    매우 클 때는 백업 파일 복원과 이후 복구까지 굉장히 오랜 시간이 걸릴 수 있다. 특히, 유저의 실수를 만회하고자 데이터베이스를 아주
    가까운 과거로 되돌리기 위해서도 백업 파일을 복원해야 한다는 점 때문에 시간 소요가 너무 크다.</p>

    <p>이러한 면을 보완하기 위하여 <span>Tibero</span>는 백업 파일 없이도 DB 전체를 과거로 되돌릴 수 있는 플래시백
    데이터베이스(Flashback Database) 기능을 제공한다.</p>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9196"/>11.6.1. 기본 기능 및 특징</h3></div></div></div>
      

      <p>플래시백 데이터베이스는 단어 의미 그대로 데이터베이스를 가까운 과거로 빠르게 되돌릴 수 있는 기능이다. SQL 명령어
      <span><strong class="guibutton">ALTER DATABASE</strong></span> 구문으로 플래시백 로그 파일 관리 및 플래시백 수행
      가능하다.</p>

      <p><span>Tibero</span> 플래시백 데이터베이스 기능의 특징은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>데이터베이스를 과거로 되돌리기 위한 플래시백 로그 파일을 따로 생성하고 관리한다. 추가적인 로그 파일을 생성하기
          때문에 데이터베이스 성능 저하는 불가피하다. 플래시백 로그 파일은 <a href="chapter_backuprecovery.html#sect_admin_bar_database_file" title="11.1. Tibero 구성 파일">“11.1. <span>Tibero</span> 구성 파일”</a>을 참고한다.</p>
        </li><li>
          <p>Flashback Marker 시점까지 데이터베이스를 과거로 되돌린 후 사용자가 입력한 시점까지 불완전
          복구한다. Flashback Marker는 블록의 변경되는 이미지를 플래시백 로그 파일에 로깅하는 기준이다.</p>

          <p>사용자가 SQL 구문을 통해 직접 추가할 수 있으며, 초기화 파라미터
          FLASHBACK_MARKER_INTERVAL(단위: 초)를 설정하여 백그라운드 작업으로 주기적으로 남기게 할 수 있다.
          Flashback Marker는 자주 남길 수록 플래시백 데이터베이스 기능 수행이 빠르지만, 그만큼 플래시백 로그가 많이
          생성되기에 데이터베이스 운영 성능이 더 저하된다.</p>
        </li><li>
          <p>백업 파일들 복원하지 않고 특정 과거 시점으로 데이터베이스를 회귀시킬 수 있다.</p>
        </li><li>
          <p>백업 파일 복원 후 불완전 복구와 효과는 같지만, 총 작업 시간이 백업 파일 복원 시간만큼
          절감된다.</p>
        </li><li>
          <p>현재의 Resetlogs TSN 이전으로도 회귀시킬 수 있다. 이 특징을 사용하면 사이트의 운영 장비가 아닌
          별도의 개발 장비에서 Resetlogs 부팅으로 특정 시나리오 테스트 후 데이터베이스를 재생성하지 않고 빠르게 기존 상태로
          원복할 수 있다.</p>
        </li><li>
          <p>Tibero Standby Cluster 사용 중 switchover/failover를 발생할 때 기존
          Primary Database를 재구축하지 않고 빠르게 stanby로 전환시킬 수 있다.</p>
        </li></ul></div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_fbdb_restriction"/>11.6.2. 전제 조건 및 제약 사항</h3></div></div></div>
      

      <p>플래시백 데이터베이스는 현재 존재하는 파일을 블록 단위로 과거로 돌리는 작업이기 때문에 다음과 같은 사항들이 고려되어야
      한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>지워지지 않고 실제 존재하는 정상적인 데이터 파일에 대해서만 플래시백 가능하다. 손상된 데이터 파일을 복구하는
          것은 불가하다.</p>
        </li><li>
          <p>플래시백하는 시점 이후로 추가된 파일은 자동으로 데이터베이스에서 삭제된다. 물리적 파일은 삭제하지 않기 때문에
          직접 관리해줘야한다.</p>
        </li><li>
          <p>Drop된 데이터 파일을 Drop되기 전으로 플래시백하려면, 해당 데이터 파일의 백업 파일이 존재해야만 한다.
          플래시백 수행 후 백업 파일을 복원하라는 가이드가 화면에 안내된다.</p>
        </li><li>
          <p>플래시백하는 시점 기준으로 테이블 스페이스는 rename되지만, 데이터 파일은 보존된다.</p>
        </li><li>
          <p>Offline된 테이블 스페이스 및 데이터 파일은 플래시백 대상에서 제외된다. 추후 drop해야
          한다.</p>
        </li><li>
          <p>크기가 Extend된 데이터 파일은 다시 줄어들지 않는다.</p>
        </li><li>
          <p>Shrink된 데이터 파일은 플래시백 불가하다. 단, 해당 데이터 파일을 offline시키면 이를 제외한 나머지
          데이터베이스에 대해서는 플래시백 가능하다. 이후 해당 파일에 대해서는 직접 백업 파일을 복원하여 불완전
          복구해야한다.</p>
        </li><li>
          <p>컨트롤 파일을 재생성했다면 이전까지 축적한 플래시백 로그 정보는 사라진다. 플래시백 로깅을 다시 활성화해야
          하며, Flashback Marker도 처음부터 다시 생성된다. 즉, 컨트롤 파일 재생성 이전으로는 플래시백 데이터베이스
          불가하다. 컨트롤 파일 재생성 이전에 생성된 플래시백 로그 파일들은 백업 데이터 파일과 컨트롤 파일이 있지 않는 이상
          사용할 수 없다.</p>
        </li><li>
          <p>백업 데이터 파일과 컨트롤 파일로 Media Recovery 후에도 기존 플래시백 로그 파일을 사용하고자
          한다면, 완전 복구를 통해 Resetlogs 부팅은 하지 않아야 하며, Flashback Marker 이후의 플래시백 로그
          파일들의 존재가 보장되어야 한다.</p>

          <p>일반적으로 백업 데이터 파일과 컨트롤 파일을 사용하여 데이터베이스를 복구할 때 Flashback Marker를
          초기화여 플래시백 로깅을 새롭게 시작하는 것이 안전한다. 추가적으로 플래시백 로깅을 활성화한 채로 Media
          Recovery를 수행할 때 Redo 로그를 기반으로 플래시백 로그도 복구하기 때문에 복구 성능이 매우 저하될 수 있다.
          따라서 플래시백 로깅을 비활성화하는 것을 추천하는데, 비활성화 할 경우 플래시백 로그 파일 정보들은 모두
          초기화된다.</p>
        </li><li>
          <p>NOLOGGING 모드는 권장하지 않는다. NOLOGGING 모드로 데이터베이스를 사용하면 플래시백은 가능하지만
          NOLOGGING 모드를 사용한 기간 동안의 플래시백 로그가 없기 때문에 해당 내용들은 플래시백이 불가하여 정합성이 깨진
          미래의 데이터베이스로 남아있을 뿐이다.</p>
        </li><li>
          <p>데이터베이스를 정상 종료해야만 MOUNT 모드에서 플래시백 데이터베이스 기능이 실행 가능하다. 정합성이 보장된
          상태에서 플래시백해야 하기 때문이다.</p>
        </li></ul></div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_fbdb_example"/>11.6.3. 플래시백 데이터베이스 실행 예제<a id="d5e9248" class="indexterm"/></h3></div></div></div>
      

      <p>본 절에서는 다음의 시나리오들을 통해서 플래시백 데이터베이스를 위한 플래시백 로그 파일 생성, 로깅 활성화, 그리고
      실제 플래시백 데이터베이스 수행을 설명한다. 이들은 모두 MOUNT 상태에서만 수행 가능하다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p><a href="chapter_backuprecovery.html#ex_addflashbacklogfile" title="[예 11.26] 플래시백 로그 파일 생성과 로깅 활성화 시나리오">플래시백 로그 파일 생성과 로깅 활성화
          시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_flashbackdatabase" title="[예 11.27] 플래시백 데이터베이스 실행 시나리오">플래시백 데이터베이스 실행
          시나리오</a></p>
        </li><li>
          <p><a href="chapter_backuprecovery.html#ex_flashbackdatabasemissing" title="[예 11.28] 플래시백 데이터베이스 실행 중 MISSING 파일 생성 시나리오">플래시백 데이터베이스 실행 중
          MISSING 파일 생성 시나리오</a></p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9263"/>플래시백 로그 파일 생성과 로깅 활성화</h4>

      <p>일반 로그 파일 구조, 구성과 동일하기에 이를 관리하는 원리도 같다. 단, 현재 플래시백 로그 파일 다중화 기능은
      지원하지 않기 때문에 플래시백 로그 멤버는 그룹당 하나만 가능하다. 플래시백 로그 파일에 대해서는 일반 로그 파일인 <a href="chapter_03.html#sect_lf" title="3.3. 로그 파일">“3.3. 로그 파일”</a>을 참고한다.</p>

      <p>플래시백 로그 파일을 추가한 후에는 해당 스레드와 플래시백 로깅을 활성화해야 운영 중 플래시백 로깅이 동작한다.
      플래시백 로깅을 활성화시키기 위해서는 초기화 파라미터인 FLASHBACK_LOG_BUFFER가 세팅되어 있어야한다.</p>

      <p>FLASHBACK_LOG_BUFFER 값은 일반적으로 LOG_BUFFER 값의 2배가 권장된다. 자세한 값은 실제
      사이트의 운영 방식에 맞게 튜닝이 필요하다.</p>

      <div class="example"><a id="ex_addflashbacklogfile"/><p class="title"><b>[예 11.26] 플래시백 로그 파일 생성과 로깅 활성화 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">ALTER DATABASE <span><strong class="guibutton">ADD FLASHBACK LOGFILE</strong></span> THREAD 0 GROUP 1 '/usr/<span>tibero</span>/log/fblog001.fb' 
SIZE 512M;
ALTER DATABASE <span><strong class="guibutton">ADD FLASHBACK LOGFILE</strong></span> THREAD 0 GROUP 2 '/usr/<span>tibero</span>/log/fblog002.fb' 
SIZE 512M;
ALTER DATABASE <span><strong class="guibutton">ADD FLASHBACK LOGFILE</strong></span> THREAD 0 GROUP 3 '/usr/<span>tibero</span>/log/fblog003.fb' 
SIZE 512M;
ALTER DATABASE ENABLE PUBLIC FLASHBACK THREAD 0;
ALTER DATABASE FLASHBACK LOGGING ON; </pre>
        </div></div><p><br class="example-break"/></p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9281"/>플래시백 데이터베이스 실행 시나리오</h4>

      <p>현재 TSN 값이 155670인 데이터베이스를 가까운 과거인 150000으로 플래시백하려면 데이터베이스를 정상 종료 후
      MOUNT 모드에서 다음을 구문을 수행한 후 완료 여부를 확인한다.</p>

      <div class="example"><a id="ex_flashbackdatabase"/><p class="title"><b>[예 11.27] 플래시백 데이터베이스 실행 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">SQL&gt; ALTER DATABASE FLASHBACK TO TSN 150000;
Database altered.</pre>
        </div></div><p><br class="example-break"/></p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e9289"/>플래시백 데이터베이스 실행 중 MISSING 파일 생성 시나리오</h4>

      <p>현재 TSN 값이 155670인 데이터베이스를 가까운 과거인 150000으로 플래시백 수행 도중 다음과 같은 에러가
      발생할 때 Drop된 파일을 되살려야 한다. 에러와 함께 안내되는 절차대로 수행하면 데이터베이스가 원하던 시점으로 온전히
      플래시백된다.</p>

      <div class="example"><a id="ex_flashbackdatabasemissing"/><p class="title"><b>[예 11.28] 플래시백 데이터베이스 실행 중 MISSING 파일 생성 시나리오</b></p><div class="example-contents">
          

          

          <pre class="programlisting">SQL&gt; ALTER DATABASE FLASHBACK TO TSN 150000;
TBR-24127: Database flashed back to the target TSN %1$u but not completed,
because CF-DD correction is required due to the originally existed at the target 
TSN or newly added datafiles during roll-forward. </pre>

          <pre class="programlisting">1) Find MISSING datafiles from v$datafile.
2) Restore the corresponding backup datafiles.
3) If they were newly added after the TSN %lu, create the physical files with 
the datafile id each.
  : SQL&gt; ALTER DATABASE CREATE DATAFILE &lt;file_id&gt;;
4) Rename(OS cmd) the corresponding files at DB_CREATE_FILE_DEST to their 
original names."
5) Rename(SQL) them with each of the names at step 2 and 4."
  : SQL&gt; ALTER DATABASE RENAME FILE 'current_file_path' to 'renamed_file_path';"
6) Request flashback database query again as followed.
  : SQL&gt; ALTER DATABASE FLASHBACK TO TSN 150000 CONTINUE; </pre>
        </div></div><p><br class="example-break"/></p>

      <p/>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_label_security.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_07.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제10장 <span>Tibero</span> Label Security </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제12장 분산 트랜잭션</td></tr></table></div><div xmlns="" align="center"/></body></html>