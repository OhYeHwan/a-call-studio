<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제6장 Dynamic SQL</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="up" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="prev" href="chapter_multi_thread.html" title="제5장 멀티 스레드 프로그래밍"/><link rel="next" href="chapter_runtime_error.html" title="제7장 런타임 에러 처리"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제6장 Dynamic SQL</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_multi_thread.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_runtime_error.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_dynamic_sql"/>제6장 Dynamic SQL</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_dynamic_sql.html#d5e2639">6.1. 개요</a></span></dt><dt><span class="section"><a href="chapter_dynamic_sql.html#d5e2657">6.2. 특징</a></span></dt><dt><span class="section"><a href="chapter_dynamic_sql.html#d5e2670">6.3. 실행 방법</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_dynamic_sql.html#sect_dynamic_sql_case1">6.3.1. 방법 1</a></span></dt><dt><span class="section"><a href="chapter_dynamic_sql.html#sect_dynamic_sql_case2">6.3.2. 방법 2</a></span></dt><dt><span class="section"><a href="chapter_dynamic_sql.html#sec-exec-type3">6.3.3. 방법 3</a></span></dt><dt><span class="section"><a href="chapter_dynamic_sql.html#sec-exec-type4">6.3.4. 방법 4</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 프로그램이 실행될 때 SQL 문장의 내용을 동적으로 지정하는 Dynamic SQL를 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2639"/>6.1. 개요</h2></div></div></div>
    

    <p><span>tbESQL</span>/C 프로그램은 컴파일을 할 때 미리 정해진 완전한 SQL 문장을 실행할
    수도 있지만 일부 애플리케이션에서는 컴파일을 할 때가 아닌 프로그램을 실행할 때 완전한 SQL 문장이 정해지는 경우도
    있다.</p>

    <p><span><strong class="guibutton">Dynamic SQL</strong></span> 문장은 이러한 경우를 위해 프로그램을 실행할 때 사용자의
    입력 등에 따라 유연하게 SQL 문장을 완성하여 실행하는 인터페이스이다.<a id="d5e2645" class="indexterm"/></p>

    <p>Dynamic SQL은 SELECT 문장인지 아닌지, 또 문장 내에 입력 변수의 포함 여부에 따라 다른 순서로 실행된다.
    이때 입력 변수와 출력 변수의 개수와 데이터 타입은 컴파일을 할 때 알고 있어야 한다. Dynamic SQL 문장은 프로그램을 실행할
    때 완성되므로 WHERE 절 등의 조건식을 동적으로 변경할 수도 있다.</p>

    <div class="literallayout"><p/></div>

    <p>Dynamic SQL을 사용하는 경우는 다음의 두 가지이다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>SQL 문장의 일부가 완성되지 않은 경우</p>

        <p>예를 들어 UPDATE 문장의 WHERE 절의 조건이 프로그램이 실행될 때 정해지는 경우를 들 수
        있다.</p>
      </li><li>
        <p>SQL 문장을 실행할 대상이 정해지지 않은 경우</p>

        <p>예를 들어 GRANT 문장을 이용하여 특권을 부여할 사용자가 프로그램이 실행될 때 정해지는 경우를 들 수
        있다.</p>
      </li></ul></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2657"/>6.2. 특징</h2></div></div></div>
    

    <p>Dynamic SQL 문장은 다음과 같은 특징이 있다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>문자열 데이터이다.</p>

        <p><span>tbESQL</span>/C 프로그램에서 EXEC SQL을 통해 실행되는 일반 SQL
        문장은 프로그램 내에 직접 포함되지만, Dynamic SQL 문장은 문자열 타입 데이터 형태로 포함된다. 즉, 문자열 변수에
        저장되어 있거나 문자열 값으로 표현된다.</p>
      </li><li>
        <p>시작과 끝을 나타내는 부호가 없다.</p>

        <p>Dynamic SQL 문장 내에는 시작을 나타내는 EXEC SQL이나 끝을 나타내는 세미콜론(;)이 포함되지
        않는다.</p>
      </li></ul></div>

    <p>다음은 Dynamic SQL 문장의 몇 가지 예이다.</p>

    <pre class="programlisting">'DELETE FROM EMP WHERE SALARY &lt; 20000'
'UPDATE EMP SET SALARY = SALARY * 1.05 WHERE DEPTNO = :deptno'
'SELECT ENAME, ADDR, SALARY FROM EMP WHERE DEPTNO = :deptno'</pre>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2670"/>6.3. 실행 방법</h2></div></div></div>
    

    <p>Dynamic SQL 문장을 실행하는 방법에는 다음의 4가지가 있다.</p>

    <p/>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p><a href="chapter_dynamic_sql.html#sect_dynamic_sql_case1" title="6.3.1. 방법 1">방법 1</a></p>

        <p>입력 변수를 포함하지 않는 SELECT 이외의 문장을 실행한다.</p>
      </li><li>
        <p><a href="chapter_dynamic_sql.html#sect_dynamic_sql_case2" title="6.3.2. 방법 2">방법 2</a></p>

        <p>입력 변수를 포함하는 SELECT 이외의 문장을 실행한다.</p>
      </li><li>
        <p><a href="chapter_dynamic_sql.html#sec-exec-type3" title="6.3.3. 방법 3">방법 3</a></p>

        <p>SELECT 문장의 실행 방법이며, 입력 변수를 포함할 수도 있고 포함하지 않을 수도 있다.</p>
      </li><li>
        <p><a href="chapter_dynamic_sql.html#sec-exec-type4" title="6.3.4. 방법 4">방법 4</a></p>

        <p>SELECT 문장으로 조회할 컬럼의 개수 및 데이터 타입을 프리컴파일 시점에서 알 수 없을 때
        사용한다.</p>
      </li></ul></div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_dynamic_sql_case1"/>6.3.1. 방법 1</h3></div></div></div>
      

      <p><span><strong class="guibutton">방법 1</strong></span><a id="d5e2695" class="indexterm"/>은 입력 변수를 포함하지 않는 SELECT 이외의 문장을 동적으로 실행하는 방법이다. 이 방법은 하나의
      SQL 문장을 실행할 때 동적으로 생성하여 EXCUTE IMMEDIATE 문장을 통하여 실행한다. 이 방법은 동일한 SQL 문장을
      실행하더라도 실행할 때마다 다시 파싱(Parsing)과 최적화를 수행한다.</p>

      <div class="literallayout"><p/></div>

      <p>SQL 문장을 실행하기 위한 <span><strong class="guibutton">EXECUTE IMMEDIATE의 문법</strong></span>은 다음과
      같다.</p>

      <pre class="programlisting">EXEC SQL EXECUTE IMMEDIATE { :sql_var | 'sql_stmt' }</pre>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">sql_var</td><td>SQL 문장을 포함하는 문자열 타입 변수이다. VARCHAR 타입이거나 CHAR 타입 모두
              가능하다.</td></tr><tr><td align="left">sql_stmt</td><td>문자열 형태의 SQL 문장이다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2717"/>사용 예제</h4>

      <p>다음은 방법 1을 통해 실행 가능한 SQL 문장의 예이다.</p>

      <pre class="programlisting">'DELETE FROM EMP WHERE SALARY &lt; 20000'</pre>

      <pre class="programlisting">'GRANT SELECT ANY TABLE TO John'</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 방법 1을 통해 SQL 문장을 실행하는 예이다.</p>

      <pre class="programlisting">char sql_var1[128];
VARCHAR sql_var2[100];
...
strcpy(sql_var1,
       "UPDATE EMP SET SALARY = SALARY * 1.05 WHERE DEPTNO = 5");
EXEC SQL EXECUTE IMMEDIATE :sql_var1;
...
strcpy(sql_var2.arr,
       "UPDATE EMP SET SALARY = SALARY * 1.05 WHERE DEPTNO = 6");
sql_var2.len = strlen(sql_var2.arr);
EXEC SQL EXECUTE IMMEDIATE :sql_var2;
...
EXEC SQL EXECUTE IMMEDIATE 'GRANT SELECT ANY TABLE TO John';</pre>

      <p>VARCHAR 타입의 변수인 경우에는 len 변수의 값도 정확하게 설정하여야 한다. 위의 예에서는 소스 코드
      'sql_var2.len = strlen(sql_var2.arr);'을 통해 len 변수의 값을 설정하고 있다.</p>

      <p>방법 1을 통해 SQL 문장을 실행할 때는 실행할 때마다 다시 파싱과 최적화 과정을 거치기 때문에 DDL 문장처럼 한
      번만 실행하기 위한 문장에 적합하다. 만약 SQL 문장 내의 일부 값만을 변화시켜 실행하려면, 다음 절에서 설명할 방법 2가 더
      적합하다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_dynamic_sql_case2"/>6.3.2. 방법 2<a id="d5e2729" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">방법 2</strong></span>는 입력 변수를 포함하는 SELECT 이외의 문장을 동적으로 실행하는
      방법이다.</p>

      <p>이 방법을 사용하면, 입력 변수만 다르고 나머지 내용은 동일한 SQL 문장을 실행하는데 유용하다. 그 이유는 문장마다
      매번 파싱을 수행하지 않고, 파싱을 한 번만 수행한 뒤 바로 최적화를 수행하기 때문이다.</p>

      <p>이 방법을 통하여 실행하는 SQL 문장 내의 입력 변수의 개수와 데이터 타입에는 제한이 없으나, 컴파일을 할 때 미리
      알고 있어야 한다. 입력 변수가 없는 SELECT 문장 이외의 다른 문장을 방법 2를 통하여 실행할 수도 있다. 하지만
      PREPARE와 EXECUTE의 두 단계를 거쳐야 하므로, 그러한 문장은 방법 1을 통해 실행하는 것이 유리하다.</p>

      <p>이 방법은 Dynamic SQL 문장을 다음의 두 단계에 걸쳐 실행한다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p><span><strong class="guibutton">PREPARE 단계 </strong></span></p>

          <p>SQL 문장을 준비하기 위한 PREPARE의 문법은 다음과 같다.</p>

          <pre class="programlisting">EXEC SQL PREPARE stmt_name FROM { :sql_var | 'sql_stmt' }</pre>

          <div class="informaltable">
            <table border="1"><colgroup><col width="110" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">stmt_name</td><td>준비된 SQL 문장을 대표하는 이름이며 EXECUTE 문장에서 사용된다.</td></tr><tr><td align="left">sql_var</td><td>SQL 문장을 포함하는 문자열 타입 변수이다. VARCHAR 타입이거나 CHAR 타입 모두
                  가능하다.</td></tr><tr><td align="left">sql_stmt</td><td>문자열 형태의 SQL 문장이다.</td></tr></tbody></table>
          </div>

          <p>PREPARE 문을 통하여 준비된 SQL 문장은 COMMIT 또는 ROLLBACK 문을 실행한 후에도 사용할 수
          있다. 이러한 문장들은 현재 세션이 끝날 때까지 유효하다.</p>
        </li><li>
          <p><span><strong class="guibutton">EXECUTE 단계 </strong></span></p>

          <p>준비된 SQL 문장을 실행하기 위한 EXECUTE의 문법은 다음과 같다.</p>

          <pre class="programlisting">EXEC SQL EXECUTE stmt_name [USING :host_var[:ind_var], ...]</pre>

          <div class="informaltable">
            <table border="1"><colgroup><col width="110" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">stmt_name</td><td>실행할 SQL 문장이며, PREPARE를 사용해 준비된 문장의 이름이다.</td></tr><tr><td align="left">USING</td><td><p>실행하려는 SQL 문장에 입력 변수가 있는 경우 입력 변수의 값을 할당하기 위해
                  사용된다. </p><p>USING 절에 나열되는 변수의 개수와 데이터 타입은 SQL 문장 내의
                  입력 변수의 개수와 데이터 타입과 동일해야 한다. USING 절에 나열된 변수의 데이터 타입이 준비된 SQL
                  문장의 입력 변수의 데이터 타입과 다르더라도 데이터 값의 변환이 가능하다면 해당 변수의 사용이 가능하다.
                  예를 들어 USING에 나열된 변수의 데이터 타입이 NUMBER이며, 이에 대응되는 입력 변수의 데이터
                  타입이 VARCHAR라면, 데이터 값이 변환되어 입력 변수에 할당된다.</p><p>USING
                  절에서 변수를 나열할 때 지시자 변수를 함께 포함할 수도 있다. 지시자 변수는 NULL 값 등을 표현할
                  경우에 사용될 수 있다. USING 절의 변수는 배열 변수를 사용할 수도 있다. 이때 USING 절 내의
                  모든 변수가 배열 변수이어야 하며 같은 크기를 가져야 한다.</p></td></tr><tr><td align="left">host_var</td><td>입력 변수로 사용될 호스트 변수이다.</td></tr><tr><td align="left">ind_var</td><td>지시자 변수이다.</td></tr></tbody></table>
          </div>
        </li></ol></div>

      <p>문장 이름 <span><strong class="guibutton">stmt_name</strong></span>은 PREPARE를 이용해 여러 SQL 문장을
      준비한 경우에 EXECUTE 문장에서 하나의 문장을 지정하기 위하여 사용한다. 즉, 문장 이름은 프로그램 모듈 내에서 유일하게
      선언해야 한다. 문장 이름은 프로그램 변수가 아니며 DECLARE 영역 내에서 선언하지 않고, PREPARE 문장 내에서만
      선언된다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>1. <span>tbESQL</span>/C 프로그램에서의 데이터 타입 변환은 <a href="chapter_datatype.html#sect_tbesql_c_datatype" title="2.3. tbESQL/C 데이터 타입">“2.3. <span>tbESQL</span>/C 데이터 타입”</a>을 참고한다.</p>

        <p>2. 지시자 변수에 대해서는 <a href="chapter_datatype.html#sect_indicator" title="2.3.8. 지시자">“2.3.8. 지시자”</a>를 참고한다.</p>
      </div>

      <p/>

      <div class="literallayout"><p/></div>

      

      <h4><a id="d5e2799"/>사용 예제</h4>

      <p>다음은 방법 2를 통해 실행 가능한 SQL 문장의 예이다.</p>

      <pre class="programlisting">'UPDATE EMP SET SALARY = SALARY * 1.05 WHERE DEPTNO = :deptno'</pre>

      <pre class="programlisting">'INSERT INTO EMP(ENAME, DEPTNO) VALUES (:ename, :deptno)'</pre>

      <p/>

      <div class="literallayout"><p/></div>

      <p>다음은 방법 2를 통해 SQL 문장을 실행하는 예이다.</p>

      <pre class="programlisting">char sql_var[128];
double sal_ratio; int deptno;
...
strcpy(sql_var, "UPDATE EMP SET SALARY = SALARY * :sal_ratio"
    "WHERE DEPTNO = :deptno");
EXEC SQL PREPARE update_emp FROM :sql_var;
...

sal_ratio = 1.05; deptno = 5;
EXEC SQL EXECUTE update_emp USING :sal_ratio, :deptno;

sal_ratio = 1.08; deptno = 6;
EXEC SQL EXECUTE update_emp USING :sal_ratio, :deptno;</pre>

      <p>위의 예에서는 두 개의 입력 변수를 갖는 UPDATE 문장 하나를 두 번 실행하였다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sec-exec-type3"/>6.3.3. 방법 3<a id="d5e2810" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">방법 3</strong></span>은 SELECT 문장을 동적으로 실행하는 방법이다. 입력 변수를 포함할
      수도 있고 포함하지 않을 수도 있다. 동적 SELECT 문장에 포함되는 입/출력 변수의 개수와 데이터 타입에는 제한이 없으나,
      컴파일을 할 때 미리 알고 있어야 한다. 하지만 FROM 절에 포함되는 테이블과 뷰, WHERE 절 내의 조건식, GROUP BY
      절, ORDER BY 절 등은 실행을 할 때 정해져도 무방하다.</p>

      <div class="literallayout"><p/></div>

      <p>방법 3은 SELECT 문의 실행 결과를 얻기 위하여 <span><strong class="guibutton">커서</strong></span>를 사용하기 때문에,
      Dynamic SQL 문장을 실행할 때 다섯 단계를 거친다. 전체적인 실행 순서를 설명하면 다음과 같다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p><span><strong class="guibutton">PREPARE 단계</strong></span></p>

          <p>PREPARE를 실행한다. PREPARE는 주어진 SQL 문장을 해석하고 실행할 준비를 한다. PREPARE의
          문법 및 사용 방법은 <a href="chapter_dynamic_sql.html#sect_dynamic_sql_case2" title="6.3.2. 방법 2">“6.3.2. 방법 2”</a>와 동일하다.</p>
        </li><li>
          <p><span><strong class="guibutton">DECLARE 단계</strong></span></p>

          <p>SQL 문장을 준비한 후에는 DECLARE를 이용하여 커서 또는 스크롤 가능 커서를 선언한다.</p>

          <p>DECLARE의 문법은 다음과 같다.</p>

          <pre class="programlisting">DECLARE cursor_name [SCROLL] CURSOR FOR stmt_name</pre>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">cursor_name</td><td>선언하는 커서의 이름이다. 커서 이름은 변수가 아니며 DECLARE 내에서만 선언된다.
                  DECLARE를 이용해 여러 개의 커서를 선언한 경우에 OPEN, FETCH, CLOSE 등의 문장에서
                  하나의 커서를 지정하기 위하여 사용한다.</td></tr><tr><td align="left">stmt_name</td><td>PREPARE를 통해 준비된 SELECT 문장의 이름이다.</td></tr></tbody></table>
          </div>
        </li><li>
          <p><span><strong class="guibutton">OPEN 단계</strong></span></p>

          <p>커서를 선언한 후에 커서에 연관된 SELECT 문장을 실행하기 위하여
          <span><strong class="guibutton">OPEN</strong></span>을 실행한다. OPEN은 먼저 USING 절에 나열된 변수 값을
          SELECT 문장의 입력 변수에 할당하고, 커서에 메모리 영역을 할당한 뒤 SELECT 문장을 실행한다. OPEN 문은
          커서를 질의 결과 로우의 맨 처음 로우에 위치시킨다.</p>

          <p>OPEN의 문법은 다음과 같다.</p>

          <pre class="programlisting">OPEN cursor_name [USING :host_var[:ind_var], ...]</pre>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">cursor_name</td><td>OPEN을 통해서 열 커서의 이름이다.</td></tr><tr><td align="left">USING</td><td>SELECT 문장의 입력 변수로 사용될 변수를 나열할 때 사용한다.</td></tr><tr><td align="left">host_var</td><td>입력 변수로 사용될 호스트 변수이다.</td></tr><tr><td align="left">ind_var</td><td>지시자 변수이다.</td></tr></tbody></table>
          </div>

          <p>커서 이름은 SQL 문장의 이름과 연관되지만, 문장 이름이 의미하는 실제 SQL 문장과는 직접적으로 연관되어
          있지 않다. 따라서, 어떤 커서를 문장 이름에 대해 선언한 후 그 문장 이름이 의미하는 실제 SQL 문장이 변경되었을
          경우에도 커서에 OPEN을 수행하면 변경된 SQL 문장이 실행된다.</p>

          <p>다음은 이러한 커서의 이름과 문장의 이름 사이의 연관에 대한 예이다.</p>

          <pre class="programlisting">EXEC SQL PREPARE stmt1 FROM :sql_var1;
EXEC SQL DECLARE cursor1 FOR stmt1;
EXEC SQL PREPARE stmt1 FROM :sql_var2;
EXEC SQL OPEN cursor1;</pre>

          <p>위의 예의 마지막 라인에서 cursor1에 대해 OPEN을 수행하면 sql_var1이 아닌 sql_var2에
          저장된 SQL 문장이 실행된다.</p>
        </li><li>
          <p><span><strong class="guibutton">FETCH 단계</strong></span></p>

          <p>질의 결과 로우를 하나씩 추출하기 위하여 FETCH를 이용한다. 추출된 로우의 각 컬럼 값은 INTO 절 내의
          변수에 저장된다. 지시자 변수는 NULL 값 등을 표현하기 위하여 선택적으로 사용된다. 만약 질의 결과 로우가 하나도
          없거나 더 이상 읽을 로우가 없다면 NOT FOUND 에러를 반환한다. 스크롤 가능 커서로 선언한 경우에는 원하는 특정
          위치의 로우를 선택하여 읽을 수 있다.</p>

          <p>FETCH의 문법은 다음과 같다.</p>

          <pre class="programlisting">FETCH [ FIRST | LAST | PRIOR | NEXT | CURRENT | RELATIVE offset
    | ABSOLUTE offset ] cursor_name INTO :host_var[:ind_var], ...</pre>

          <p>커서 이름 바로 앞에 있는 옵션은 액세스하려는 로우의 위치를 의미한다. 스크롤 가능 커서에 대한 설명과 각
          옵션의 의미는 <a href="ch03.html#sect_scrollable_cursor" title="3.5. 스크롤 가능 커서">“3.5. 스크롤 가능 커서”</a>를 참고한다.</p>
        </li><li>
          <p><span><strong class="guibutton">CLOSE 단계</strong></span></p>

          <p>커서를 이용해 원하는 모든 로우를 읽은 후에는 해당 커서에 CLOSE를 실행한다. CLOSE는 커서에 할당된
          메모리를 반환하고 커서를 닫는다. 닫힌 커서에 대해서는 FETCH를 실행할 수 없다.</p>

          <p>CLOSE의 문법은 다음과 같다.</p>

          <pre class="programlisting">CLOSE cursor_name</pre>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">cursor_name</td><td>CLOSE를 통해서 닫을 커서의 이름이다.</td></tr></tbody></table>
          </div>
        </li></ol></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2901"/>사용 예제</h4>

      <p>다음은 방법 3을 통해 실행 가능한 SQL 문장의 예이다.</p>

      <pre class="programlisting">'SELECT ENAME, ADDR, SALARY FROM EMP WHERE DEPTNO = 5'</pre>

      <pre class="programlisting">'SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = :deptno'</pre>

      <p/>

      <div class="literallayout"><p/></div>

      <p>다음은 방법 3을 통해 SQL 문장을 실행하는 예이다.</p>

      <pre class="programlisting">char sql_var[128];
int deptno;
VARCHAR ename[24];
double salary;
VARCHAR addr[36];

...
strcpy(sql_var, "SELECT ENAME, SALARY, ADDR"
       "FROM EMP WHERE DEPTNO = :deptno");
EXEC SQL PREPARE select_stmt FROM :sql_var;
EXEC SQL DECLARE emp_cursor CURSOR FOR select_stmt;
...
deptno = 5;
EXEC SQL OPEN emp_cursor USING :deptno;
EXEC SQL WHENEVER NOT FOUND DO break;

while (1) {
    EXEC SQL FETCH emp_cursor INTO :ename, :salary, :addr;
    ...
}

EXEC SQL CLOSE emp_cursor;</pre>

      <p>위의 예에서는 'emp_cursor'라는 이름으로 커서를 선언하였으며, NOT FOUND 에러가 반환될 때까지
      while 루프 내의 FETCH 문을 계속 실행한다.</p>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sec-exec-type4"/>6.3.4. 방법 4<a id="d5e2913" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">방법 4</strong></span>는 SELECT 문장을 통해 조회할 컬럼의 개수 및 타입을 프리컴파일
      시점에서 알 수 없을 때 사용하는 방법이다. 이 방법에 사용되는 핵심적인 자료 구조는
      <span><strong class="guibutton">SQLDA</strong></span>라는 구조체이다. SQLDA 타입의 서술자(Descriptor) 변수를 이용해서
      바인드 변수와 조회할 컬럼을 기술하여 Dynamic SQL을 수행한다.<a id="d5e2919" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>다음은 SQLDA 구조체의 선언 방법 및 각 멤버 변수를 주석을 통해 설명한다.</p>

      <pre class="programlisting">struct SQLDA
{
    long N;      /* 서술자 내의 항목의 개수*/
    char **V;    /* 실제 데이터가 들어가 버퍼 배열 변수 */
    long *L;     /* 버퍼의 길이를 나타내는 변수 */
    short *T;    /* 버퍼의 타입을 나타내는 변수 */
    short *I;    /* 지시자 변수를 위한 공간 */
    long F;      /* DESCRIBE에 의해서 발견된 변수의 개수 */
    char **S;    /* 변수의 이름을 저장하기 위한 배열 변수 */
    short *M;    /* 변수 이름의 최대길이를 저장하는 변수 */
    short *C;    /* 변수 이름의 현재 값을 저장하는 변수 */
    char *X;     /* 지시자 변수 이름을 위한 배열 */
    short *Y;    /* 지시자 변수이름의 최대 길이 */
    short *Z;    /* 지시자 변수 이름의 현재 길이 */
}</pre>

      <div class="literallayout"><p/></div>

      <p>Dynamic Method 4를 사용할 때의 binding 가능한 host variable type이 정해져
      있다.</p>

      <p>다음은 SQLDA 구조체의 타입 변수인 T에 맵핑시킬 수 있는 External 데이터 타입과 타입 코드를
      설명한다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="200" align="left"/><col width="200" align="left"/><col/></colgroup><thead><tr><th align="left">External Type</th><th align="left">Type Code</th><th>C type</th></tr></thead><tbody><tr><td align="left">VARCHAR2</td><td align="left">1</td><td>char[n]</td></tr><tr><td align="left">NUMBER</td><td align="left">2</td><td>char[n] ( n &lt; 22 )</td></tr><tr><td align="left">INTEGER</td><td align="left">3</td><td>int</td></tr><tr><td align="left">FLOAT</td><td align="left">4</td><td>float</td></tr><tr><td align="left">STRING</td><td align="left">5</td><td>char[n+1]</td></tr><tr><td align="left">VARNUM</td><td align="left">6</td><td>char[n] ( n &lt; 22 )</td></tr><tr><td align="left">DECIMAL</td><td align="left">7</td><td>float</td></tr><tr><td align="left">LONG</td><td align="left">8</td><td>char[n]</td></tr><tr><td align="left">BINARY_FLOAT</td><td align="left">21</td><td>float</td></tr><tr><td align="left">BINARY_DOUBLE</td><td align="left">22</td><td>double</td></tr><tr><td align="left">VARCHAR</td><td align="left">9</td><td>char[n+2]</td></tr><tr><td align="left">ROWID</td><td align="left">11</td><td>char[n]</td></tr><tr><td align="left">DATE</td><td align="left">12</td><td>char[n]</td></tr><tr><td align="left">VARRAW</td><td align="left">15</td><td>char[n]</td></tr><tr><td align="left">RAW</td><td align="left">23</td><td>unsigned char[n]</td></tr><tr><td align="left">LONG RAW</td><td align="left">24</td><td>unsigned char[n]</td></tr><tr><td align="left">UNSIGNED</td><td align="left">68</td><td>unsigned int</td></tr><tr><td align="left">DISPLAY</td><td align="left">91</td><td>char[n]</td></tr><tr><td align="left">LONG VARCHAR</td><td align="left">94</td><td>char[n+4]</td></tr><tr><td align="left">LONG VARRAW</td><td align="left">95</td><td>unsigned char[n+4]</td></tr><tr><td align="left">CHAR</td><td align="left">96</td><td>char[n]</td></tr><tr><td align="left">CHARF</td><td align="left">96</td><td>char[n]</td></tr><tr><td align="left">CHARZ</td><td align="left">97</td><td>char[n+1]</td></tr><tr><td align="left">CLOB</td><td align="left">112</td><td>Cloblocator</td></tr><tr><td align="left">BLOB</td><td align="left">113</td><td>Bloblocator</td></tr></tbody></table>
      </div>

      <p/>

      <p>방법 4의 전체적인 실행 순서를 설명하면 다음과 같다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p>먼저 <span><strong class="guibutton">SQLDA</strong></span> 변수를 선언한다.</p>

          <p>다음은 SQLDA 변수를 선언하는 예이다.</p>

          <pre class="programlisting">#include &lt;sqlda.h&gt;
SQLDA *select_dp;
SQLDA * bind_dp;

char *id = "T002";
char *cd = "B001";

char *stmt = "select teller_name from teller where teller_id=:id and\
              branch_cd=:cd";</pre>
        </li><li>
          <p>각 변수에 대하여 <span><strong class="guibutton">SQLSQLDAAlloc </strong></span>함수를 이용해서 메모리
          공간을 할당한다.</p>

          <p>다음은 SQLSQLDAAlloc 함수를 통해 메모리 공간을 할당하는 예이다.</p>

          <pre class="programlisting">bind_dp = SQLSQLDAAlloc(SQL_SINGLE_RCTX, 3, (size_t)5, 4);
select_dp = SQLSQLDAAlloc(SQL_SINGLE_RCTX, 3, (size_t)5, (size_t)0);</pre>
        </li><li>
          <p>각 서술자에 사용될 컬럼의 개수와 변수의 개수를 지정한다.</p>

          <p>다음은 서술자에 사용될 컬럼의 개수와 변수의 개수를 지정하는 예이다.</p>

          <pre class="programlisting">select_dp-&gt;N = 3;
bind_dp-&gt;N = 3;</pre>
        </li><li>
          <p>호스트 변수에 미리 지정된 SQL 문장을 <span><strong class="guibutton">PREPARE</strong></span>를 사용해
          준비한다.</p>

          <p>다음은 SQL 문장을 준비하는 예이다.</p>

          <pre class="programlisting">EXEC SQL PREPARE S1 FROM :stmt;</pre>
        </li><li>
          <p><span><strong class="guibutton">DECLARE</strong></span>를 사용해 커서를 선언한다.</p>

          <p>다음은 커서를 선언하는 예이다.</p>

          <pre class="programlisting">EXEC SQL DECLARE C1 CURSOR FOR S1;</pre>
        </li><li>
          <p><span><strong class="guibutton">DESCRIBE</strong></span>로 SQL 문장의 바인드 변수를 바인딩한다.</p>

          <p>다음은 바인드 변수를 바인딩을 하는 예이다.</p>

          <pre class="programlisting">EXEC SQL DESCRIBE BIND VARIABLES FOR S1 INTO bind_dp;</pre>
        </li><li>
          <p>DESCRIBE 문장을 통해 실제 계산된 바인드 변수의 개수를 다시 지정한다.</p>

          <p>bind_dp-&gt;F의 값이 2임을 알고 난 후 다음과 같이 설정해 줄 수 있다.</p>

          <pre class="programlisting">bind_dp-&gt;N = bind_dp-&gt;F</pre>
        </li><li>
          <p>바인드 변수를 위한 메모리를 할당한다.</p>

          <p>여기서 bind_dp-&gt;F의 값이 2가 아닌 다른 수였다면 그에 맞춘 값 할당이 필요하다. for 루프
          등을 사용해 해당 값을 알맞게 할당하는 프로그램을 작성할 수도 있다.</p>

          <p>다음은 바인드 변수를 위한 메모리 공간을 할당하는 예이다.</p>

          <pre class="programlisting">bind_dp-&gt;V[0] = id;
bind_dp-&gt;L[0] = strlen(id);
bind_dp-&gt;T[0] = 5;
bind_dp-&gt;V[1] = cd;
bind_dp-&gt;L[1] = strlen(cd);
bind_dp-&gt;T[1] = 5;</pre>
        </li><li>
          <p><span><strong class="guibutton">OPEN</strong></span>을 사용해 준비된 바인드 서술자로 커서를 연다.</p>

          <p>다음은 바인드 서술자를 사용해 커서를 여는 예이다.</p>

          <pre class="programlisting">EXEC SQL OPEN C1 USING DESCRIPTOR bind_dp;</pre>
        </li><li>
          <p>조회할 컬럼에 대한 서술자를 작성한다.</p>

          <p>다음은 서술자를 작성하는 예이다.</p>

          <pre class="programlisting">EXEC SQL DESCRIBE SELECT LIST FOR S1 INTO select_dp;</pre>
        </li><li>
          <p>실제 조회할 컬럼의 개수를 알게 되었으므로 이를 재설정한다.</p>

          <p>다음은 컬럼의 개수를 재지정하는 예이다.</p>

          <pre class="programlisting">select_dp-&gt;N = select_dp-&gt;F;</pre>
        </li><li>
          <p>조회할 각 컬럼의 길이와 데이터 타입을 재설정한다.</p>

          <p>다음은 select_dp-&gt;F 값이 1, 즉 select list의 개수가 1이라고 가정하고 재설정하는
          예이다.</p>

          <pre class="programlisting">select_dp-&gt;V[0] = malloc(select_dp-&gt;L[0] + 1);
memset(select_dp-&gt;V[0], 0, select_dp-&gt;L[0] + 1);</pre>

          <p>select_dp-&gt;F의 개수에 따라 select_dp의 각 변수의 설정이 달라져야 한다.</p>
        </li><li>
          <p>서술자를 이용해서 <span><strong class="guibutton">FETCH</strong></span>를 실행한다.</p>

          <p>다음은 FETCH를 실행하는 예이다.</p>

          <pre class="programlisting">EXEC SQL FETCH C1 USING DESCRIPTOR select_dp;</pre>

          <p>수행결과는 서술자의 V변수에 값이 저장된다.</p>
        </li><li>
          <p>FETCH의 실행을 완료한 후에는 할당된 메모리를 모두 해제한다.</p>

          <p>다음은 할당된 메모리를 해제하는 예이다.</p>

          <pre class="programlisting">free(select_dp-&gt;V[0]);

SQLSQLDAFree(SQL_SINGLE_RCTX, select_dp);
SQLSQLDAFree(SQL_SINGLE_RCTX, bind_dp);</pre>
        </li><li>
          <p>마지막으로 <span><strong class="guibutton">CLOSE</strong></span>를 사용해 커서를 닫는다.</p>

          <p>다음은 커서를 닫는 예이다.</p><pre class="programlisting">EXEC SQL CLOSE C1;</pre>
        </li></ol></div>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e3112"/>사용 예제</h4>

      <p>다음은 방법 4를 통해 배열변수를 이용한 SQL 문장을 실행하는 예이다.</p>

      <pre class="programlisting">char *stmt = "select teller_id, teller_name from teller where branch_cd=:cd \
              order by teller_id";

char *cd = "B001";
int count = 2;

SQLDA *bind_dp;
SQLDA *select_dp;

EXEC SQL WHENEVER SQLERROR 
     DO printf("file: %s, line: %d, error code: %d\n", __FILE__, __LINE__,
                sqlca.sqlcode);

bind_dp = SQLSQLDAAlloc(SQL_SINGLE_RCTX, 3, (size_t)5, 4);
select_dp = SQLSQLDAAlloc(SQL_SINGLE_RCTX, 3, (size_t)5, (size_t)0);

bind_dp-&gt;N = MAX_ITEMS;
select_dp-&gt;N = MAX_ITEMS;

/* prepare */
EXEC SQL PREPARE S1 FROM :stmt;

/* declare cursor */
EXEC SQL DECLARE C2 CURSOR FOR S1;

/* describe bind parameters */
EXEC SQL DESCRIBE BIND VARIABLES FOR S1 INTO bind_dp;

bind_dp-&gt;N = bind_dp-&gt;F;

/* bind parameters */
bind_dp-&gt;V[0] = cd;
bind_dp-&gt;L[0] = strlen(cd) + 1;
bind_dp-&gt;T[0] = 5;

/* open cursor */
EXEC SQL OPEN C2 USING DESCRIPTOR bind_dp;

/* describe select list */
EXEC SQL DESCRIBE SELECT LIST FOR S1 INTO select_dp;

/* allocate bind col buffer */
select_dp-&gt;N = select_dp-&gt;F;
select_dp-&gt;V[0] = malloc(select_dp-&gt;L[0] * 2);
memset(select_dp-&gt;V[0], 0, select_dp-&gt;L[0] * 2);
select_dp-&gt;V[1] = malloc(select_dp-&gt;L[1] * 2);
memset(select_dp-&gt;V[1], 0, select_dp-&gt;L[1] * 2);
select_dp-&gt;T[1] = 5;

/* fetch */
EXEC SQL FOR :count FETCH C2 USING DESCRIPTOR select_dp;

EXEC SQL CLOSE C2;

/* free sqlda */
SQLSQLDAFree(SQL_SINGLE_RCTX, bind_dp);
SQLSQLDAFree(SQL_SINGLE_RCTX, select_dp);

EXEC SQL COMMIT RELEASE;</pre>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_multi_thread.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_runtime_error.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제5장 멀티 스레드 프로그래밍 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제7장 런타임 에러 처리</td></tr></table></div><div xmlns="" align="center"/></body></html>