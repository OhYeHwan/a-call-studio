<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제4장 배열 변수</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="up" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="prev" href="ch03.html" title="제3장 기본 프로그래밍"/><link rel="next" href="chapter_multi_thread.html" title="제5장 멀티 스레드 프로그래밍"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제4장 배열 변수</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_multi_thread.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_array_variable"/>제4장 배열 변수</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_array_variable.html#d5e2087">4.1. 개요</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e2131">4.2. 배열 변수 선언</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e2159">4.3. 입/출력 배열 변수</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_array_variable.html#sect_array_select">4.3.1. SELECT</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#sect_array_insert">4.3.2. INSERT</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#sect_array_update">4.3.3. UPDATE</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#sect_array_delete">4.3.4. DELETE</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#sect_for_statement">4.3.5. FOR 절</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_array_variable.html#d5e2446">4.4. 구조체 배열 변수</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_array_variable.html#d5e2456">4.4.1. 구조체 배열 변수의 선언</a></span></dt><dt><span class="section"><a href="chapter_array_variable.html#d5e2492">4.4.2. 사용 방법</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 배열 변수의 기본 개념과 선언 방법, 그리고 배열 변수를 <span>tbESQL</span>/C
  문장에서 입/출력 변수로 사용하는 방법을 설명한다.<a id="d5e2083" class="indexterm"/><a id="d5e2085" class="indexterm"/></p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2087"/>4.1. 개요</h2></div></div></div>
    

    <p><span>tbESQL</span>/C 프로그램의 배열 변수는 C 프로그래밍 언어의 배열 변수의 개념과
    동일하다. 배열은 동일한 타입의 값을 여러 개 저장할 수 있는 데이터 구조이다.</p>

    <p><span>tbESQL</span>/C 프로그램에서는 SELECT 문장을 실행한 뒤 다수의 결과 로우를
    저장하기 위해서 출력 변수로 배열 변수를 사용하거나, INSERT 문장을 사용할 때도 보통 여러 개의 로우를 삽입하게 되므로 입력
    변수로 배열 변수를 사용한다.</p>

    <div class="literallayout"><p/></div>

    <p>배열 변수가 출력 변수로 사용될 때는 <span><strong class="guibutton">출력 배열 변수</strong></span>라고 부르며, 입력 변수로
    사용될 때는 <span><strong class="guibutton">입력 배열 변수</strong></span>라고 한다. 출력 배열 변수와 입력 배열 변수가 사용되는 문장은
    다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>출력 배열 변수<a id="d5e2100" class="indexterm"/></p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>SELECT</p>
          </li></ul></div>
      </li><li>
        <p>입력 배열 변수<a id="d5e2107" class="indexterm"/></p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>INSERT</p>
          </li><li>
            <p>UPDATE</p>
          </li><li>
            <p>DELETE</p>
          </li></ul></div>
      </li></ul></div>

    <div class="literallayout"><p/></div>

    <p><span>tbESQL</span>/C 프로그램에서 <span>tbESQL</span>/C 문장과 C 프로그램의 변수 사이에 데이터를 주고 받을 때 배열 변수를
    사용하면 다음과 같은 장점이 있다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>간결하고 구조적인 프로그래밍</p>

        <p>배열 변수를 사용하면 각각의 로우를 처리할 때마다 별도의 SQL 문장을 사용하지 않고, 모든 로우를 하나의 SQL
        문장으로 처리할 수 있다. 따라서 프로그램의 소스 코드를 보다 단순화할 수 있으며, 구조적인 프로그래밍이
        가능하다.</p>
      </li><li>
        <p><span>tbESQL</span>/C 프로그램의 성능 향상</p>

        <p>클라이언트와 서버 환경에서는 데이터를 주고받기 위하여 많은 시간이 필요하다. 배열 변수를 사용해 여러 로우를
        한꺼번에 처리하면 전송 시간이 크게 줄어든다.</p>
      </li></ul></div>

    <p/>

    <p/>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2131"/>4.2. 배열 변수 선언</h2></div></div></div>
    

    <p><span>tbESQL</span>/C 문장에서 사용될 배열 변수를 선언할 때에는 다음의 내용에 유의해야
    한다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>반드시 DECLARE 영역 안에 선언해야 한다.</p>
      </li><li>
        <p>VARCHAR 또는 CHAR 타입 등의 문자열 타입 변수는 항상 2차원 배열이어야 한다.</p>
      </li><li>
        <p>int 타입 등의 문자열이 아닌 변수는 항상 1차원 배열이어야 한다.</p>
      </li><li>
        <p>포인터 변수를 배열 변수 형태로 선언하면, <span>tbESQL</span>/C 문장에서 사용할 수 없다.</p>
      </li></ul></div>

    <div class="literallayout"><p/></div>

    <p>다음은 배열 변수를 선언하는 예이다.</p>

    <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
VARCHAR ename[50][24];
int salary[50];
VARCHAR addr[50][32];
...
EXEC SQL END DECLARE SECTION;</pre>

    <div class="literallayout"><p/></div>

    <p>다음은 배열 변수를 잘못 선언한 예이다.</p>

    <pre class="programlisting">VARCHAR ename[50][20][24];     <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
int salary[50][20];            <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
int *salary[50];
...
EXEC SQL SELECT SALARY, ...
    INTO :salary, ...          <em class="lineannotation"><span class="lineannotation">... ③ ...</span></em>
    FROM EMP;</pre>

    <p>① VARCHAR 타입 변수는 2차원으로 선언되어야 하는데 3차원으로 잘못 선언된 예이다.</p>

    <p>② int 타입 등의 문자열이 아닌 변수는 1차원으로 선언되어야 하는데 2차원으로 잘못 선언된 예이다.</p>

    <p>③ 포인터 변수를 배열 변수로 선언해서 <span>tbESQL</span>/C 문장에 사용하려고 했기 때문에 잘못 선언된 예이다.</p>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2159"/>4.3. 입/출력 배열 변수</h2></div></div></div>
    

    <p>본 절에서는 <span>tbESQL</span>/C 문장에서 배열 변수가 입/출력 변수로 사용될 경우 각 <span>tbESQL</span>/C 문장에 따른 배열 변수의 사용 방법에 대해 설명한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_array_select"/>4.3.1. SELECT</h3></div></div></div>
      

      <p><span><strong class="guibutton">SELECT</strong></span> 문장을 실행하여 반환되는 결과 로우의 개수가 하나 이상이라면
      반드시 커서 또는 <span><strong class="guibutton">배열 변수</strong></span>를 사용해야 한다. 결과 로우의 개수를 미리 예측할 수 있다면
      배열 변수의 크기를 충분히 선언하여 사용할 수 있다. 만약 결과 로우의 개수가 예측하기 힘들거나 매우 크다면,
      <span><strong class="guibutton">배열 변수와 커서를 함께</strong></span> 사용할 수도 있다.<a id="d5e2170" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2173"/>배열 변수</h4>

      <p><span><strong class="guibutton">SELECT</strong></span> 문장의 실행 결과로 반환된 로우의 개수가 예측 가능하고 크기가
      크지 않다면 <span><strong class="guibutton">배열 변수</strong></span>를 이용하여 모든 결과 로우를 한 번에 받을 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>예를 들어 SELECT 문장의 결과로 반환되는 로우의 개수가 50개를 넘지 않는 경우에 다음과 같이 소스 코드를 작성할
      수 있다.</p>

      <div class="example"><a id="ex_array_select"/><p class="title"><b>[예 4.1] SELECT 문장에서의 배열 변수의 사용</b></p><div class="example-contents">
        

        

        <pre class="programlisting">char ename[50][24];
int salary[50];
VARCHAR addr[50][32];
...
EXEC SQL SELECT ENAME, SALARY, ADDR
    INTO :ename, :salary, :addr
    FROM EMP
    WHERE SALARY &gt;= 50000;</pre>
      </div></div><br class="example-break"/>

      <p/>

      <p>결과 로우의 각 컬럼 값은 각 배열 변수에 저장되며, 저장될 때 같은 순서의 변수에 저장된다. 예를 들어 세 번째
      로우의 컬럼 값은 각각 배열 변수의 세 번째 위치인 ename[2], salary[2], addr[2]에 저장된다.</p>

      <div class="literallayout"><p/></div>

      <p>SELECT 문장에서 배열 변수를 사용할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>INTO 절에 포함되는 출력 변수는 배열 변수와 일반 변수가 동시에 <span><strong class="guibutton">함께 올 수
          없다.</strong></span> 따라서 INTO 절에 포함된 모든 출력 변수는 배열 변수이거나 또는 일반 변수이어야
          한다.</p>
        </li><li>
          <p>SELECT 문장의 실행 결과로 반환된 로우의 전부가 아닌 <span><strong class="guibutton">일부</strong></span>만을
          얻고 싶을 때에도 배열 변수를 이용할 수 있다. 위의 <a href="chapter_array_variable.html#ex_array_select" title="[예 4.1] SELECT 문장에서의 배열 변수의 사용">[예 4.1]</a>에서
          SELECT 문장의 실행 결과로 반환된 로우가 50개가 넘는 경우에 50개까지의 결과 로우만을 배열 변수에 저장한다. 만약
          결과로 반환된 로우를 30개 까지만 저장하고 싶다면, 위의 <a href="chapter_array_variable.html#ex_array_select" title="[예 4.1] SELECT 문장에서의 배열 변수의 사용">[예 4.1]</a>의
          배열 변수를 다음과 같이 선언하면 된다.</p>

          <pre class="programlisting">char ename[30][24];
int salary[30];
VARCHAR addr[30][32];</pre>
        </li><li>
          <p>SELECT 문장의 실행 결과로 배열 변수에 저장된 로우의 실제 개수는 SQLCA의 변수인
          <span><strong class="guibutton">sqlca</strong></span>를 통해 알 수 있다. 변수 sqlca는 <span>tbESQL</span>/C 프로그램 내에 포함된 변수로 주로 에러 및 경고 처리에
          사용된다. sqlca의 사용에 대해서는 <a href="chapter_runtime_error.html#sect_struct_sqlca" title="7.3.1. SQLCA 구조체 변수">“7.3.1. SQLCA 구조체 변수”</a>를
          참고한다.</p>

          <p>정확하게는 <span><strong class="guibutton">sqlca.sqlerrd[2]</strong></span>에 실제로 변수에 저장된 로우의
          개수가 저장된다. 다음은 SELECT 문의 실행 후에 올 수 있는 소스 코드에 sqlca.sqlerrd[2]를 사용한
          예이다.</p>

          <div class="example"><a id="ex_sqlca_sqlerrd"/><p class="title"><b>[예 4.2] sqlca.sqlerrd[2]의 활용</b></p><div class="example-contents">
            

            

            <pre class="programlisting">for (i = 0; i &lt; sqlca.sqlerrd[2]; i ++)
{
    printf("%s, %d, %.*s\n", ename[i], salary[i], addr[i].len, addr[i].arr);
    ...
}
printf("number of returned rows = %d\n", sqlca.sqlerrd[2]);</pre>
          </div></div><br class="example-break"/>

          <p>맨 마지막 라인을 보면 반환된 로우의 개수를 출력하는 데 sqlca.sqlerrd[2]를
          사용하였다.</p>
        </li><li>
          <p>배열 변수의 크기가 일정하지 않은 경우에는 <span><strong class="guibutton">가장 작은</strong></span> 배열 변수의
          크기를 전체 배열 변수의 크기로 설정한다. 예를 들어 다음의 소스 코드와 같이 배열 변수가 선언된 경우에 배열 변수
          ename과 salary의 크기는 50이지만, addr의 크기가 30이므로 SELECT 문의 실행 후에 반환되는 결과
          로우의 개수는 30개이다.</p>

          <pre class="programlisting">char ename[50][24];
int salary[50];
VARCHAR addr[30][32];
...
EXEC SQL SELECT ENAME, SALARY, ADDR
    INTO :ename, :salary, :addr
    FROM EMP
    WHERE SALARY &gt;= 50000;</pre>
        </li><li>
          <p>SELECT 문장의 <span><strong class="guibutton">WHERE</strong></span> 절에는 배열 변수가 올 수 없다.
          WHERE 절에 배열 변수가 오는 경우 질의의 의미가 모호해지기 때문이다. 따라서 다음과 같은 소스 코드는 프리컴파일
          과정에서 에러를 반환한다.</p>

          <pre class="programlisting">int deptno[50];
...
EXEC SQL SELECT ENAME, SALARY, ADDR
    INTO :ename, :salary, :addr
    FROM EMP
    WHERE DEPTNO = :deptno;</pre>

          <p>배열 변수와 함께 커서를 사용하더라도 SELECT 문장의 WHERE 절에 배열 변수를 사용할 수는
          없다.</p>
        </li></ul></div>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2218"/>배열 변수와 커서<a id="d5e2219" class="indexterm"/></h4>

      <p><span><strong class="guibutton">SELECT</strong></span> 문장의 실행 결과로 반환되는 로우의 개수를 예측하기 어렵거나
      반환되는 로우의 개수가 많다면 배열 변수와 함께 <span><strong class="guibutton">커서</strong></span>를 이용해야 한다. 이때 일반 커서는
      물론 스크롤 가능 커서도 사용할 수 있다.</p>

      <p>커서와 배열 변수를 함께 사용하는 방법은 커서와 일반 변수를 함께 사용하는 경우와 거의 유사하다. 하지만
      <span><strong class="guibutton">FETCH</strong></span>를 실행할 때 루프를 빠져 나오는 방법이 일반 변수를 사용할 때와 다르다. 그
      이유는 NOT FOUND 에러가 발생되는 경우가 차이가 있기 때문이다.</p>

      <p>일반적으로 커서를 이용하여 루프 내에서 결과 로우를 액세스할 때 더 이상 읽어 올 결과 로우가 없으면 NOT FOUND
      에러가 반환된다. 하지만 일반 변수일 때와 배열 변수일 때 <span><strong class="guibutton">NOT FOUND 에러</strong></span>는
      다음과 같은 차이가 있다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th>설명</th></tr></thead><tbody><tr><td align="left">일반 변수</td><td>일반 변수를 이용할 때에는 결과 로우를 하나씩 액세스하므로 NOT FOUND 에러가 발생할 때에는 출력
              변수에 저장된 결과 로우는 없다.</td></tr><tr><td align="left">배열 변수</td><td>배열 변수를 이용할 때에는 배열 변수의 크기보다 작은 수의 결과 로우를 반환하더라도 NOT FOUND
              에러를 반환한다. 즉, NOT FOUND 에러를 반환하더라도 출력 배열 변수에는 결과 로우가 포함되어 있을 수
              있다.</td></tr></tbody></table>
      </div>

      <p/>

      <p>따라서 배열 변수를 사용할 때는 SQLCA의 변수인 sqlca를 사용해 루프를 빠져 나온다. 커서와 함께 배열 변수가
      사용될 때에 sqlca.sqlerrd[2]에는 FETCH 문장을 수행할 때마다 현재까지 처리된 결과 로우의 누적 개수가 저장된다.
      그러므로 이 누적 개수가 더 이상 증가하지 않을 때 루프를 중단하면 된다.</p>

      <p>다음은 루프를 중단하는 소스 코드의 예이다.</p>

      <div class="example"><a id="ex_sqlca_sqlerrd2"/><p class="title"><b>[예 4.3] sqlca.sqlerrd[2]를 활용한 루프의 중단</b></p><div class="example-contents">
        

        

        <pre class="programlisting">int i, count;
int before_count, current_count;

...

EXEC SQL DECLARE cursor CURSOR FOR ...
...

before_count = current_count = 0;

while (1)
{
    EXEC SQL FETCH cursor INTO ...
    current_count = sqlca.sqlerrd[2];

    if (current_count == before_count) break;
    count = current_count - before_count;

    for (i = 0; i &lt; count; i ++)
   {
      /* 각 로우에 대한 처리 */
       ...
   }
    ...
   before_count = current_count;
}</pre>
      </div></div><br class="example-break"/>

      <p>위의 예에서는 두 개의 새로운 변수 before_count와 current_count를 사용하여 두 변수의 값이
      일치하면 while 루프를 중단한다. 출력 배열 변수에 저장된 실제 결과 로우의 개수는 변수 count에 저장된다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2250"/>다수의 커서</h4>

      <p><span><strong class="guibutton">SELECT </strong></span>문장에는 배열 변수와 함께 <span><strong class="guibutton">다수의
      커서</strong></span>를 사용할 수도 있다. 몇 개의 커서를 사용하더라도 하나의 커서를 사용할 때와 동일하게 처리된다. 동시에
      여러 개의 커서를 사용할 때 SQLCA의 변수 sqlca가 각 커서마다 별도로 선언되지는 않는다. 따라서 변수 sqlca에 저장된
      데이터는 직전에 실행된 질의 또는 기타 SQL 문장의 결과에 대한 데이터이다.</p>

      <p>다음은 각 커서에 FETCH를 수행할 때마다 변수 sqlca에 저장되는 데이터의 예이다.</p>

      <pre class="programlisting">EXEC SQL DECLARE cursor1 CURSOR FOR ...
EXEC SQL DECLARE cursor2 CURSOR FOR ...
...
EXEC SQL OPEN cursor1;
EXEC SQL OPEN cursor2;
...
EXEC SQL FETCH cursor1 INTO :ename;
/* sqlca.sqlerrd[2] = 20 */
EXEC SQL FETCH cursor2 INTO :salary;
/* sqlca.sqlerrd[2] = 30, not 50 */
EXEC SQL FETCH cursor1 INTO :ename;
/* sqlca.sqlerrd[2] = 40, not 70 */
EXEC SQL FETCH cursor1 INTO :ename;
/* sqlca.sqlerrd[2] = 60, not 90 */
EXEC SQL FETCH cursor2 INTO :salary;
/* sqlca.sqlerrd[2] = 60, not 120 */</pre>

      <p>위의 예에서 배열 변수 ename과 salary의 크기는 각각 20과 30이며, cursor1과 cursor2에 연관된
      SELECT 문장의 결과 로우의 개수가 충분히 크다고 가정한다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2258"/>스크롤 가능 커서</h4>

      <p><span><strong class="guibutton">SELECT </strong></span>문장에는 배열 변수와 함께 <span><strong class="guibutton">스크롤 가능
      커서</strong></span>를 사용할 수도 있다. 스크롤 가능 커서는 일반 커서의 경우와 거의 동일하게 사용할 수 있으나,
      <span><strong class="guibutton">sqlca.sqlerrd[2]</strong></span>에 저장되는 값의 의미가 달라진다.</p>

      <p>일반 커서와 스크롤 가능 커서의 sqlca.sqlerrd[2] 값의 차이는 다음과 같다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="220" align="left"/><col/></colgroup><thead><tr><th align="left">구분</th><th>설명</th></tr></thead><tbody><tr><td align="left">일반 커서의 sqlca.sqlerrd[2]</td><td>일반 커서의 경우에는 액세스된 결과 로우의 <span><strong class="guibutton">누적 개수</strong></span>를
              저장하고 있다.</td></tr><tr><td align="left">스크롤 가능 커서의 sqlca.sqlerrd[2]</td><td>현재까지 액세스된 가장 마지막 결과 로우의 <span><strong class="guibutton">절대 위치</strong></span>를
              저장하고 있다.</td></tr></tbody></table>
      </div>

      <p/>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>일반 커서의 sqlca.sqlerrd[2]와 관련된 예제는 <a href="chapter_array_variable.html#ex_sqlca_sqlerrd" title="[예 4.2] sqlca.sqlerrd[2]의 활용">[예 4.2]</a>을 참고한다. sqlca에 대한 자세한 내용은 <a href="chapter_runtime_error.html#sect_struct_sqlca" title="7.3.1. SQLCA 구조체 변수">“7.3.1. SQLCA 구조체 변수”</a>를 참고한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>스크롤 가능 커서를 사용할 때 sqlca.sqlerrd[2]에 저장되는 값은 다음과 같이 결정된다.</p>

      <p>FETCH 문장을 수행할 때마다 옵션에 의하여 정해진 결과 로우의 위치로부터 배열 변수의 크기만큼 액세스하게 되므로,
      sqlca.sqlerrd[2]에 저장되는 값은(액세스하고자 하는 결과 로우의 절대 위치 + 배열 변수의 크기 - 1) 값 중에서
      현재까지 가장 큰 값이 된다. 만약 액세스를 하려는 위치에서부터 남아 있는 결과 로우의 개수가 배열 변수의 크기보다 작다면
      sqlca.sqlerrd[2]에 저장되는 값은 전체 결과 로우의 개수가 된다. 결과 로우의 절대 위치 값과
      sqlca.sqlerrd[2] 값은 항상 1 이상이다.</p>

      <div class="literallayout"><p/></div>

      <p>다음의 소스 코드는 배열 변수와 함께 스크롤 가능 커서를 사용하는 예이다.</p>

      <pre class="programlisting">EXEC SQL DECLARE cursor SCROLL CURSOR FOR ...
...
EXEC SQL OPEN cursor;
...
EXEC SQL FETCH cursor INTO :ename;
/* 1번째 로우부터 액세스. sqlca.sqlerrd[2] = 20 */

EXEC SQL FETCH NEXT cursor INTO :ename;
/* 21번째 로우부터 액세스. sqlca.sqlerrd[2] = 40 */

EXEC SQL FETCH ABSOLUTE 11 cursor INTO :ename;
/* 11번째 로우부터 액세스. sqlca.sqlerrd[2] = 40 */

EXEC SQL FETCH RELATIVE 20 cursor INTO :ename;
/* 51번째 로우부터 액세스. sqlca.sqlerrd[2] = 70 */

EXEC SQL FETCH ABSOLUTE 41 cursor INTO :ename;
/* 41번째 로우부터 액세스. sqlca.sqlerrd[2] = 70 */

EXEC SQL FETCH RELATIVE 20 cursor INTO :ename;
/* 81번째 로우부터 액세스. sqlca.sqlerrd[2] = 90 */

EXEC SQL FETCH ABSOLUTE 51 cursor INTO :ename;
/* 51번째 로우부터 액세스. sqlca.sqlerrd[2] = 90 */</pre>

      <p>위의 예에서 배열 변수 ename의 크기는 20이며, 커서에 연관된 SELECT 문장의 결과로 반환된 로우의 전체
      개수는 90이라고 가정한다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      

      <h4><a id="sect_indicator_array"/>지시자 배열 변수</h4>

      <p><span><strong class="guibutton">SELECT</strong></span> 문장에는 출력 배열 변수와 함께 <span><strong class="guibutton">지시자 배열
      변수</strong></span>를 사용할 수 있다.</p>

      <p>지시자 배열 변수는 출력 배열 변수와 같은 크기를 가져야 하며, 배열 변수로 선언한다는 것 외에는 일반적인 지시자
      변수와 동일하게 사용할 수 있다. 반환되는 컬럼 값이 NULL이거나 값의 일부가 잘릴 가능성이 있다면 지시자 배열 변수의 사용을
      고려해야 한다. 지시자 배열 변수도 다른 변수와 마찬가지로 DECLARE 영역 내에 선언한다.</p>

      <p>다음은 지시자 배열 변수를 사용한 예이다.</p>

      <pre class="programlisting">VARCHAR addr[50][32];
short addr_ind[50];
...
EXEC SQL SELECT ADDR, ...
    INTO :addr INDICATOR :addr_ind, ...
    FROM EMP
    WHERE DEPTNO = 5;</pre>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>입력 배열 변수와 함께 지시자 배열 변수를 사용할 수도 있다. 입력 지시자 변수는 INSERT, UPDATE,
        DELETE 문장에서 사용할 수 있다.</p>
      </div>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e2306"/>사용 예제</h4>

      <p>다음은 <a href="ch03.html#ex_using_cursor" title="[예 3.14] 커서의 사용">[예 3.14]</a>에서 제시한 예제를 배열 변수를 이용하도록 수정한
      예이다.</p>

      <pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;string.h&gt;
#define USERPASS    "<span>tibero</span>/<span>tmax</span>"
int main()
{
    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR userpass[20] = { strlen(USERPASS), USERPASS };
    int deptno;
    VARCHAR ename[30][24];                            <em class="lineannotation"><span class="lineannotation">        ... ① ...</span></em>
    int salary[30];
    VARCHAR addr[30][32];
    EXEC SQL END DECLARE SECTION;

    int i, count;
    int before_count, current_count;

    EXEC SQL DECLARE emp_cursor CURSOR FOR
        SELECT ENAME, SALARY, ADDR
        FROM EMP
        WHERE DEPTNO = :deptno;
    EXEC SQL CONNECT :userpass;
    printf("Connected.\n");
    printf("Enter dept number to show: ");
    scanf("%d", &amp;deptno);

    EXEC SQL OPEN emp_cursor;
    before_count = current_count = 0;
    
    while (1)
    {
        EXEC SQL FETCH emp_cursor
                 INTO :ename, :salary, :addr;

        current_count = sqlca.sqlerrd[2];
        if (current_count == before_count) break;          <em class="lineannotation"><span class="lineannotation">  ... ② ...</span></em> 

        count = current_count - before_count;
        for (i = 0; i &lt; count; i ++)
        {
            printf("ename = %s, salary = %d, addr = %s\n",  <em class="lineannotation"><span class="lineannotation"> ... ③ ...</span></em>
                    ename[i].arr, salary[i], addr[i].arr);
        }
        before_count = current_count;
    }
    EXEC SQL CLOSE emp_cursor;
    EXEC SQL COMMIT WORK RELEASE;
}</pre>

      <p>① <a href="ch03.html#ex_using_cursor" title="[예 3.14] 커서의 사용">[예 3.14]</a>과 비교했을 때 변수를 배열 변수로
      선언한다.</p>

      <p>② FETCH를 수행할 때 루프를 중단한다.</p>

      <p>③ 배열 변수에 저장된 컬럼의 값을 printf 문을 통해 출력한다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_array_insert"/>4.3.2. INSERT</h3></div></div></div>
      

      <p><span><strong class="guibutton">INSERT</strong></span> 문장에서 배열 변수를 사용하는 방법은 일반적인 입력 변수를
      사용하는 방법과 동일하다. 입력 배열 변수가 사용되는 각 문장은 문장이 실행되기 직전에 동적으로 배열 변수에 저장된 값을 읽어
      들인다. 따라서 각 문장이 실행되기 전에 반드시 배열 변수에 적절한 값을 넣어 주는 코드가 있어야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>INSERT 문장에서 배열 변수를 사용할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>INSERT 문장에서 사용되는 입력 변수는 배열 변수와 일반 변수가 함께 올 수 없다. 따라서 모든 입력 변수가
          배열 변수이거나 일반 변수로만 구성되어야 한다.</p>
        </li><li>
          <p>SELECT 문장에서와 마찬가지로 포인터 배열 변수를 입력 변수로 사용할 수 없다.</p>
        </li><li>
          <p>SELECT 문장과 유사하게 SQLCA의 변수 sqlca.sqlerrd[2]에는 삽입된 로우의 개수가 저장되어
          있다.</p>

          <p>sqlca.sqlerrd[2]에는 항상 하나의 INSERT 문장에 의해 삽입된 로우의 개수만
          저장된다.</p>
        </li><li>
          <p>FOR 절을 사용해 입력 배열 변수의 크기보다 적은 개수의 로우를 삽입하도록 할 수도 있다.</p>

          <p>예를 들면 크기가 50인 입력 배열 변수의 내용 중에서 30개의 로우 값만을 이용하는 경우이다.</p>
        </li><li>
          <p>입력 배열 변수와 함께 지시자 배열 변수를 사용할 수도 있다. 삽입해야 할 컬럼 값 중 일부만 NULL 값인
          경우에는 반드시 지시자 배열 변수를 사용해야 한다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 배열 변수와 함께 INSERT 문장을 실행하는 예이다.</p>

      <div class="example"><a id="ex_insert_array"/><p class="title"><b>[예 4.4] INSERT 문장의 배열 변수</b></p><div class="example-contents">
        

        

        <pre class="programlisting">VARCHAR ename[50][24];
int salary[50];
...
/*입력 배열 변수의 값을 적절히 설정한다.*/
strcpy((char *) ename[0].arr, "Peter");
ename[0].len = strlen(ename[0].arr);
salary[0] = 5000;
...
EXEC SQL INSERT INTO EMP (ENAME, SALARY)
         VALUES (:ename, :salary);</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>위의 <a href="chapter_array_variable.html#ex_insert_array" title="[예 4.4] INSERT 문장의 배열 변수">[예 4.4]</a>에서의 INSERT 문장은 다음의 for 루프를
      이용한 소스 코드와 같은 결과를 갖는다. 하지만 배열 변수를 이용하는 편이 서버와의 통신 비용을 크게 줄일 수 있으므로 성능
      면에서 훨씬 효율적이다.</p>

      <pre class="programlisting">for (i = 0; i &lt; 50; i ++){
   EXEC SQL INSERT INTO EMP (ENAME, SALARY)
   VALUES (:ename[i], :salary[i]);
}</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 컬럼 SALARY에 대해 지시자 배열 변수를 사용한 예이다.</p>

      <pre class="programlisting">VARCHAR ename[50][24];
int salary[50];
short salary_ind[50];
...
EXEC SQL INSERT INTO EMP (ENAME, SALARY)
         VALUES (:ename, :salary <span><strong class="guibutton">INDICATOR :salary_ind</strong></span>);</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_array_update"/>4.3.3. UPDATE</h3></div></div></div>
      

      <p><span><strong class="guibutton">UPDATE</strong></span> 문장에서 배열 변수를 사용하는 방법도 일반 변수를 사용하는 방법과
      유사하다.</p>

      <div class="literallayout"><p/></div>

      <p>UPDATE 문장에서 배열 변수를 사용할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>UPDATE 문장에서는 SELECT 문장과는 다르게 <span><strong class="guibutton">WHERE 절</strong></span>에도
          배열 변수를 사용할 수 있다.</p>

          <p>WHERE 절에 배열 변수를 사용하면 SET 절에도 배열 변수를 사용해야 한다. 만약 WHERE 절에 일반
          변수를 사용하였다면 SET 절에도 일반 변수를 사용해야 한다.</p>
        </li><li>
          <p>INSERT 문장과 유사하게, SQLCA의 변수 sqlca.sqlerrd[2]에는 갱신된 로우의 개수가
          저장된다.</p>

          <p>sqlca.sqlerrd[2]에는 항상 하나의 UPDATE 문장에 의해 갱신된 로우의 개수만 저장되며, 무결성
          제약조건을 만족하기 위해 연속적으로 갱신되거나 삭제된 로우의 개수는 포함되지 않는다.</p>
        </li><li>
          <p>UPDATE 문장에서 SET 절 내에 사용된 입력 변수에는 배열 변수와 일반 변수가 함께 올 수 없다. 또한
          입력 변수로 포인터 배열 변수를 사용할 수 없다.</p>
        </li><li>
          <p>SELECT FOR UPDATE 문장 내에서 <span><strong class="guibutton">UPDATE ... CURRENT OF
          절</strong></span>과 함께 배열 변수를 사용할 수 없다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 UPDATE 문장의 SET 절과 WHERE 절에 배열 변수를 사용한 예이다.</p>

      <div class="example"><a id="ex_array_update"/><p class="title"><b>[예 4.5] UPDATE 문장의 배열 변수</b></p><div class="example-contents">
        

        

        <pre class="programlisting">int salary[50];
int empno[50];
int i;
...
/*입력 배열 변수의 값을 적절히 설정한다.*/
for (i = 1; i &lt; 50; i++)
    empno = i; 
...
EXEC SQL UPDATE EMP SET SALARY = :salary
         WHERE EMPNO = :empno;</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>위의 <a href="chapter_array_variable.html#ex_array_update" title="[예 4.5] UPDATE 문장의 배열 변수">[예 4.5]</a>은 다음과 같은 for 루프를 이용한 연속된
      UPDATE 문장과 동일한 결과를 갖는다. 하지만 배열 변수를 이용하는 편이 성능 면에서 더욱 효율적이다.</p>

      <pre class="programlisting">for (i = 0; i &lt; 50; i ++)
{
    EXEC SQL UPDATE EMP SET SALARY = :salary[i]
             WHERE EMPNO = :empno[i];
}</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_array_delete"/>4.3.4. DELETE</h3></div></div></div>
      

      <p><span><strong class="guibutton">DELETE</strong></span> 문장에서 배열 변수를 사용하는 방법도 일반 변수를 사용하는 방법과
      유사하다.</p>

      <div class="literallayout"><p/></div>

      <p>DELETE 문장에서 배열 변수를 사용할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>DELETE 문장에서도 UPDATE 문장과 같이 <span><strong class="guibutton">WHERE 절</strong></span>에 배열
          변수를 사용할 수 있다.</p>
        </li><li>
          <p>INSERT, UPDATE 문장에서와 유사하게, sqlca.sqlerrd[2]에는 삭제된 로우의 개수가
          저장된다.</p>

          <p>sqlca.sqlerrd[2]에는 항상 하나의 DELETE 문장에 의하여 삭제된 로우의 개수만 저장되며, 무결성
          제약조건을 만족하기 위하여 연속적으로 갱신되거나 삭제된 로우의 개수는 포함되지 않는다.</p>
        </li><li>
          <p>DELETE 문장의 WHERE 절에 사용될 입력 변수로 배열 변수와 일반 변수가 함께 올 수 없다.</p>
        </li><li>
          <p>입력 변수로 포인터 배열 변수를 사용할 수 없다.</p>
        </li><li>
          <p>DELETE 문장에 배열 변수를 사용할 때는 <span><strong class="guibutton">DELETE ... CURRENT OF
          절</strong></span>을 사용할 수 없다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 DELETE 문장의 WHERE 절에 배열 변수를 사용한 예이다.</p>

      <div class="example"><a id="ex_array_delete"/><p class="title"><b>[예 4.6] DELETE 문장의 배열 변수</b></p><div class="example-contents">
        

        

        <pre class="programlisting">int empno[50];
...
/*입력 배열 변수의 값을 적절히 설정한다.*/
emp[0] = 11;
emp[1] = 15;
...
EXEC SQL DELETE EMP WHERE EMPNO = :empno;</pre>
      </div></div><br class="example-break"/>

      <div class="literallayout"><p/></div>

      <p>위의 <a href="chapter_array_variable.html#ex_array_delete" title="[예 4.6] DELETE 문장의 배열 변수">[예 4.6]</a>는 다음의 for 루프와 동일한 결과를 갖는다.
      하지만 INSERT, UPDATE 문장과 마찬가지로 배열 변수를 이용하는 편이 성능 면에서 효율적이다.</p>

      <pre class="programlisting">for (i = 0; i &lt; 50; i ++)
{
    EXEC SQL DELETE EMP
             WHERE EMPNO = :empno[i];
}</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_for_statement"/>4.3.5. FOR 절<a id="d5e2410" class="indexterm"/></h3></div></div></div>
      

      <p>INSERT, DELETE, UPDATE 문장에서 입력 배열 변수를 사용할 때 배열 변수의 크기보다 적은 개수의 로우를
      처리하려는 경우에 <span><strong class="guibutton">FOR 절</strong></span>을 사용한다. FOR 절은 EXEC SQL 바로 다음에 오며,
      처리하고자 하는 로우의 개수를 명시한다.</p>

      <div class="literallayout"><p/></div>

      <p>FOR 절에 로우의 개수를 명시할 때 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>FOR 절에 로우의 개수를 명시할 때는 <span><strong class="guibutton">숫자</strong></span>를 명시할 수도 있으며,
          <span><strong class="guibutton">변수</strong></span>를 명시할 수도 있다.</p>

          <p>변수를 명시할 경우 해당 변수는 반드시 <span><strong class="guibutton">DECLARE 영역</strong></span>에 선언되어
          있어야 한다.</p>
        </li><li>
          <p>FOR 절에 로우의 개수를 명시할 때 연산식을 사용해서는 안 된다.</p>
        </li><li>
          <p>FOR 절의 로우 개수는 항상 입력 배열 변수의 크기보다 작아야 한다.</p>

          <p><span>tbESQL</span>/C 프로그램에서는 지정된 로우의 개수를 저장할 배열 변수의
          크기를 검토하지 않는다. 만약 지정된 로우의 개수보다 배열 변수의 크기가 작다면, 내부적으로 유효하지 않은 메모리에
          접근하게 되어 메모리 에러가 발생하고, 이때 <span>tbESQL</span>/C 프로그램이 어떠한 동작을 할지 보장할 수
          없다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음의 소스 코드는 FOR 절을 이용하는 예이다.</p>

      <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
         VARCHAR ename[50];
         int salary[50];
         int empno[50];
         int row_count;
EXEC SQL BEGIN DECLARE SECTION;
...
EXEC SQL FOR <span><strong class="guibutton">20</strong></span>                                     <em class="lineannotation"><span class="lineannotation">... ① ... </span></em>
    INSERT INTO EMP (ENAME, SALARY, ADDR)
    VALUES (:ename, :salary, NULL);
...
<span><strong class="guibutton">row_count = 30;</strong></span>
EXEC SQL FOR <span><strong class="guibutton">:row_count</strong></span>                            <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
    UPDATE EMP SET SALARY = :salary
    WHERE EMPNO = :empno;</pre>

      <p>① 로우의 개수를 숫자로 설정하여 FOR 절을 이용할 수 있다.</p>

      <p>② 변수를 이용하여 로우의 개수를 설정하여 FOR 절을 이용할 수 있다. 단, 변수 row_count는 DECLARE
      영역에 선언되어 있어야 한다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 FOR 절에서 로우의 개수를 명시할 때 임의의 연산식을 사용한 경우로 잘못된 예이다.</p>

      <pre class="programlisting">EXEC SQL FOR <span><strong class="guibutton">:row_count + 10</strong></span>
DELETE EMP WHERE EMPNO = :empno;</pre>

      <p/>

      <p/>

      
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e2446"/>4.4. 구조체 배열 변수</h2></div></div></div>
    

    <p><span>tbESQL</span>/C 문장 내에서 여러 컬럼을 동시에 처리할 때 각 컬럼별 입/출력 변수
    각각을 나열할 수도 있지만, 각 컬럼에 대한 변수를 모아 하나의 구조체로 정의하여 구조체 타입의 변수를 이용할 수도
    있다.</p>

    <p>또한 더 나아가 각 컬럼의 여러 로우를 한꺼번에 처리하고자 할 때 구조체로 정의한 타입을 배열로 선언하여
    <span><strong class="guibutton">구조체 배열 변수</strong></span>를 이용할 수 있다.<a id="d5e2452" class="indexterm"/><a id="d5e2454" class="indexterm"/></p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2456"/>4.4.1. 구조체 배열 변수의 선언</h3></div></div></div>
      

      <p>구조체 배열 변수를 선언할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>반드시 구조체 <span><strong class="guibutton">태그(tag)</strong></span>를 삽입해야 한다.</p>
        </li><li>
          <p>구조체 배열 변수는 반드시 <span><strong class="guibutton">DECLARE 영역</strong></span>에 선언되어야
          한다.</p>
        </li><li>
          <p><span>tbESQL</span>/C 문장에서 사용되는 구조체 타입의 변수는 중첩되어 정의될 수
          없다(일반적인 구조체 변수일 때나 구조체 배열 변수일 때나 동일하다).</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 구조체 태그를 삽입한 예이다.</p>

      <div class="example"><a id="ex_structural_array"/><p class="title"><b>[예 4.7] 구조체 태그의 삽입</b></p><div class="example-contents">
        

        

        <pre class="programlisting">struct tag_emp
{
    VARCHAR ename[24];
    int salary;
    VARCHAR addr[36];
} emp[50];</pre>

        <p>위의 예에서는 struct 예약어 다음에 tag_emp라는 태그를 삽입했다. 만약 구조체 태그를 넣지 않으면
        프리컴파일 과정에서 에러가 발생한다.</p>

        <div class="literallayout"><p/></div>
      </div></div><br class="example-break"/>

      <p>다음은 구조체를 잘못 선언한 예이다.</p>

      <pre class="programlisting">struct tag_emsp
{ 
    VARCHAR ename[24];
    struct
    {
        int salary;
        VARCHAR addr[36];
    } sub_info;
} emp[50];</pre>

      <p>위의 예에서는 구조체 emp 내부에 구조체 sub_info를 중첩하여 정의하였다. 구조체 타입의 변수는 중첩되어 정의될
      수 없다.</p>

      <div class="literallayout"><p/></div>

      <p>지시자 구조체 배열 변수를 선언할 수도 있다. 지시자 구조체 배열 변수를 선언할 때도 구조체 배열 변수를 선언할 때의
      유의점을 따라야 한다. 그 밖에는 지시자 구조체 타입의 변수를 선언하는 방법과 유사하다. 추가적으로 지시자 구조체 배열 변수를
      선언할 때는 다음의 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>지시자 구조체 타입의 변수 내의 멤버 변수의 개수는 입/출력 구조체 타입의 변수 내의 멤버 변수의 개수와 같아야
          하며, 각 멤버 변수는 서로 순서에 맞게 대응되도록 정의해야 한다.</p>
        </li><li>
          <p>지시자 변수는 항상 <span><strong class="guibutton">short 타입</strong></span>을 가지며, 지시자 구조체 배열
          변수도 반드시 <span><strong class="guibutton">DECLARE 영역</strong></span> 내에 선언되어야 한다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 위의 <a href="chapter_array_variable.html#ex_structural_array" title="[예 4.7] 구조체 태그의 삽입">[예 4.7]</a>에서 선언한 emp 구조체 배열 변수를
      지시자 배열 변수 형태로 선언한 예이다.</p>

      <pre class="programlisting">struct tag_emp_ind
{
    short ename_ind;
    short salary_ind;
    short addr_ind;
} emp_ind[50];</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2492"/>4.4.2. 사용 방법</h3></div></div></div>
      

      <p>단순 구조체 타입의 변수와 마찬가지로 구조체 배열 변수는 SELECT 문장에서의 출력 변수와 INSERT 문장에서의
      입력 변수로 사용할 수 있다. 두 가지 경우 모두 지시자 구조체 배열 변수를 함께 사용할 수 있다. 입/출력 값 중에 NULL이
      포함되거나 출력 값 중에 일부가 잘릴 가능성이 있다면 반드시 지시자 구조체 배열 변수를 사용해야 한다.</p>

      <p>구조체 배열 변수를 사용하는 방법은 일반적인 배열 변수와 동일하며, 배열 변수의 사용 방법에 대한 내용은 구조체 배열
      변수에도 동일하게 해당된다. 단순히 구조체 배열 변수만을 사용할 수도 있으며 커서와 함께 사용할 수도 있다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 구조체 배열 변수를 입/출력 변수로 사용하는 예이다.</p>

      <pre class="programlisting">EXEC SQL SELECT ENAME, SALARY, ADDR
         INTO :emp
         FROM EMP
         WHERE SALARY &gt;= 50000;
...
EXEC SQL INSERT INTO EMP
         VALUES (<span><strong class="guibutton">:emp</strong></span> INDICATOR <span><strong class="guibutton">:emp_ind</strong></span>);</pre>

      <p>위에서는 INSERT 문장에 입력 배열 변수 emp와 지시자 구조체 배열 변수 emp_ind를 함께
      사용하였다.</p>

      <div class="literallayout"><p/></div>

      <p>구조체 배열 변수 대신에 구조체 배열 변수에 대한 포인터 변수를 사용할 수도 있다. 단, 포인터의 배열 변수는 사용할
      수 없다. 이러한 포인터 변수는 구조체 배열 변수를 함수 파라미터로 넘길 때에 유용하다.</p>

      <p>다음은 포인터 변수를 사용하는 예이다.</p>

      <pre class="programlisting">struct tag_emp
{
    VARCHAR ename[24];
    int salary;
    VARCHAR addr[36];
} emp[50], *emp_ptr;

int for_size;
...

emp_ptr = &amp;emp[0];
for_size = sizeof(emp) / sizeof(emp[0]);

EXEC SQL FOR :for_size
         SELECT ENAME, SALARY, ADDR
         INTO :emp_ptr;
         FROM EMP
         WHERE SALARY &gt;= 50000;</pre>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_multi_thread.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제3장 기본 프로그래밍 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제5장 멀티 스레드 프로그래밍</td></tr></table></div><div xmlns="" align="center"/></body></html>