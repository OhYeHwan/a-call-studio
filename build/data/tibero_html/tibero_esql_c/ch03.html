<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제3장 기본 프로그래밍</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="up" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="prev" href="chapter_datatype.html" title="제2장 데이터 타입"/><link rel="next" href="chapter_array_variable.html" title="제4장 배열 변수"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제3장 기본 프로그래밍</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_datatype.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_array_variable.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1421"/>제3장 기본 프로그래밍</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="ch03.html#d5e1426">3.1. 개요</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d5e1430">3.1.1. <span>tbESQL</span>/C 프로그램의 문법</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1549">3.1.2. 프로그램의 실행 과정</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1634">3.1.3. 런타임 에러 처리</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#d5e1676">3.2. 프로그램 구조</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#sect_variable_declear">3.2.1. 변수 선언</a></span></dt><dt><span class="section"><a href="ch03.html#sect_init">3.2.2. 초기화</a></span></dt><dt><span class="section"><a href="ch03.html#sect_database_work">3.2.3. 데이터베이스 작업</a></span></dt><dt><span class="section"><a href="ch03.html#sect_rollback_and_commit">3.2.4. 종료화</a></span></dt><dt><span class="section"><a href="ch03.html#sect_error">3.2.5. 에러 처리</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#d5e1754">3.3. <span>tbESQL</span>/C 문장 실행</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d5e1762">3.3.1. SELECT</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1829">3.3.2. INSERT</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1848">3.3.3. UPDATE</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1868">3.3.4. DELETE</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#sect_cursor">3.4. 커서</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d5e1885">3.4.1. 사용 방법</a></span></dt><dt><span class="section"><a href="ch03.html#sect_current_of_statement">3.4.2. CURRENT OF 절</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1958">3.4.3. 사용 예제</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#sect_scrollable_cursor">3.5. 스크롤 가능 커서</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d5e1989">3.5.1. 사용 방법</a></span></dt><dt><span class="section"><a href="ch03.html#d5e2072">3.5.2. 사용 예제</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 <span>tbESQL</span>/C 프로그램의 문법과 실행 과정, 런타임 에러(runtime error)
  처리, 그리고 <span>tbESQL</span>/C 문장의 실행, 커서를 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1426"/>3.1. 개요</h2></div></div></div>
    

    <p>본 절에서는 <span>tbESQL</span>/C 프로그램의 문법과 런타임 에러 처리에 대해서 설명한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1430"/>3.1.1. <span>tbESQL</span>/C 프로그램의 문법</h3></div></div></div>
      

      <p><span>tbESQL</span>/C 프로그램의 문법은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>SQL 문장의 시작과 끝</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p><span>tbESQL</span>/C 프로그램에 포함되는 SQL 문장은 항상
              <span><strong class="guibutton">EXEC SQL</strong></span>로 시작되며
              <span><strong class="guibutton">세미콜론(;)</strong></span>으로 끝난다.</p>
            </li><li>
              <p>하나의 SQL 문장은 여러 줄에 걸쳐있을 수 있다.</p>
            </li></ul></div>
        </li><li>
          <p>DECLARE 영역 <a id="d5e1448" class="indexterm"/></p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>DECLARE 영역은 <span><strong class="guibutton">'BEGIN DECLARE SECTION;
              '</strong></span>으로 시작되며, <span><strong class="guibutton">'END DECLARE SECTION;
              '</strong></span>으로 끝난다.</p>
            </li><li>
              <p>DECLARE 영역에는 변수 선언 이외에 다른 코드가 삽입되어서는 안 된다.</p>
            </li><li>
              <p>SQL 문장과 함께 사용되는 입/출력 변수는 항상 DECLARE 영역에 선언해야 한다.</p>

              <p>입/출력 변수가 구조체나 배열의 형태로 선언된 경우에도 DECLARE 영역에 선언해야 한다. 단,
              프리컴파일러 옵션에 따라 그렇지 않은 경우도 있다. 프리컴파일러 옵션에 대해서는 <a href="chapter_precompiler_option.html" title="제9장 tbESQL/C 프리컴파일러 옵션">“제9장 <span>tbESQL</span>/C 프리컴파일러 옵션”</a>을 참고한다.</p>
            </li><li>
              <p>입/출력 변수가 아닌 일반적인 프로그램 변수의 경우에는 DECLARE 영역 밖에 선언되어도
              무방하다.</p>
            </li><li>
              <p>다음은 DECLARE 영역의 예이다.</p>

              <div class="example"><a id="d5e1465"/><p class="title"><b>[예 3.1] DECLARE 영역</b></p><div class="example-contents">
                

                <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
         VARCHAR ename[24];
         int salary;
         VARCHAR addr[32];
EXEC SQL END DECLARE SECTION;</pre>
              </div></div><br class="example-break"/>
            </li></ul></div>
        </li><li>
          <p>문자열</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>C 프로그래밍 코드에 포함된 문자열은 큰따옴표(" ")를 사용한다.</p>
            </li><li>
              <p><span>tbESQL</span>/C 문장에 포함되는 문자열은 작은따옴표(' ')를
              사용한다.</p>
            </li></ul></div>
        </li><li>
          <p>연산자<a id="d5e1478" class="indexterm"/></p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>SQL 문장 내에서는 SQL 문장의 표준으로 정의된 연산자만 사용할 수 있으며, C 프로그래밍 언어의
              연산자는 사용할 수 없다. 예를 들어 비트 연산자(~, &amp;, |, ^ 등)는 SQL 문장 내에서 사용될 수
              없다.</p>

              <p>다음은 SQL 논리 연산자와 C 프로그래밍 언어의 논리 연산자를 비교한 것이다.</p>

              <div class="informaltable">
                  <table border="1"><colgroup><col width="100" align="left"/><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">SQL 연산자</th><th align="left">C 프로그래밍 언어의 연산자</th><th>설명</th></tr></thead><tbody><tr><td align="left">NOT</td><td align="left">!</td><td>TRUE이면 FALSE, FALSE이면 TRUE를 반환한다.</td></tr><tr><td align="left">AND</td><td align="left">&amp;&amp;</td><td>둘 다 TRUE일 때만 TRUE를 반환한다.</td></tr><tr><td align="left">OR</td><td align="left">||</td><td>둘 중 하나만 TRUE이면 TRUE를 반환한다.</td></tr><tr><td align="left">=</td><td align="left">==</td><td>두 항이 같을 경우 TRUE를 반환한다.</td></tr></tbody></table>
                </div>
            </li></ul></div>
        </li><li>
          <p>주석(Comment)<a id="d5e1513" class="indexterm"/></p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>주석은 C 프로그래밍 언어에서 사용하는 방법 이외에 두 개의 마이너스 부호(--)를 이용하는 방법이
              있다.</p>
            </li><li>
              <p>두 개의 마이너스 부호(--)를 사용하는 주석은 부호(--)가 시작되는 곳에서부터 그 라인의 끝까지
              주석으로 처리한다. 또한 EXEC SQL 문장에만 사용될 수 있으며, C 프로그래밍 코드 부분에는 사용되지
              못한다.</p>
            </li><li>
              <p>다음은 주석을 사용하는 예이다.</p>

              <div class="example"><a id="d5e1522"/><p class="title"><b>[예 3.2] <span>tbESQL</span>/C 프로그램에서의 주석</b></p><div class="example-contents">
                

                <pre class="programlisting">EXEC SQL SELECT ENAME, SALARY, ADDR 
         INTO :emp -- 구조체 변수를 사용한다. 
         FROM EMP
         WHERE EMPNO =:empno;</pre>
              </div></div><br class="example-break"/>
            </li></ul></div>
        </li><li>
          <p>참조(Include)<a id="d5e1528" class="indexterm"/></p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>ESQL에서 헤더 파일을 참조하는 방법으로 #include 명령과 EXEC SQL INCLUDE 명령
              2가지 방법이 있다.</p>
            </li><li>
              <p>두 명령은 각각 다른 컴파일 단계에서 쓰인다는 점에서 차이를 가지고 있다.</p>

              <p>프리컴파일할 때에 필요한 인자들을 참조하기 위해선 EXEC SQL INCLUDE를 통해서 참조해야 하며,
              프리컴파일 이후 만들어진 .c 파일을 컴파일할 때 필요한 헤더 파일은 #include를 통해 참조해야 한다. 예를
              들어 VARCHAR가 선언되어 있는 헤더 파일은 #include를 통해서 참조할 수 없다.</p>

              <p>SQLCA의 경우에는 프리컴파일할 때 자동으로 참조하게 되어 있어서 .c 파일에 남게 된다.</p>
            </li><li>
              <p>다음은 #include와 EXEC SQL INCLUDE를 사용하는 예이다.</p>

              <div class="example"><a id="d5e1539"/><p class="title"><b>[예 3.3] <span>tbESQL</span>/C 프로그램에서의 참조</b></p><div class="example-contents">
                

                <pre class="programlisting">#include &lt;string.h&gt;   /* .c 파일의 컴파일을 위해 필요한 헤더 파일 참조 */
EXEC SQL INCLUDE varchar.h; /* VARCHAR type의 변수가 선언되어 있는 varchar.h를 참조 */
EXEC SQL INCLUDE varchar; /* .h를 생략하고도 사용할 수 있다. */</pre>
              </div></div><br class="example-break"/>
            </li></ul></div>
        </li><li>
          <p>주의사항<a id="d5e1545" class="indexterm"/></p>

          <p>ESQL 문장 내에서 사용되는 단어 혹은 그 일부를 매크로로 선언하면 프리컴파일 중 Preprocessing
          과정에서 단어가 치환되어 ESQL 문장이 해석되지 않을 수 있다. 이를 고려하여 작성해야 한다.</p>
        </li></ul></div>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1549"/>3.1.2. 프로그램의 실행 과정</h3></div></div></div>
      

      <p><span>tbESQL</span>/C 프로그램을 작성할 때는 필요한 데이터 타입이나 함수 프로토타입
      등을 이용하기 위해서 반드시 <span><strong class="guibutton">sqlca.h</strong></span> 파일을 포함해야 한다. 즉, 아래의 내용이
      항상 <span>tbESQL</span>/C 프로그램 소스 코드의 맨 위에 명시되어 있어야 한다. 만약
      존재하지 않으면 자동으로 추가된다.</p>

      <pre class="programlisting">#include &lt;sqlca.h&gt;</pre>

      <p>다음 그림은 <span>tbESQL</span>/C 프로그램 소스 코드를 실행 파일로 생성하기 위해 거치는 전
      과정이다. 프리컴파일 과정을 제외하면 C 프로그램의 경우와 별로 다르지 않다.</p>

      <div class="figure"><a id="figure_tbcesql_program_compile_link"/><p class="title"><b>[그림 3.1] <span>tbESQL</span>/C 프로그램의 실행 과정</b></p><div class="figure-contents">
        

        <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="370"><tr><td align="left"><img src="resources/img_esql_02.png" align="top" width="370" alt="tbESQL/C 프로그램의 실행 과정"/></td></tr></table></div>
      </div></div><br class="figure-break"/>

      <p>위의 <a href="ch03.html#figure_tbcesql_program_compile_link" title="[그림 3.1] tbESQL/C 프로그램의 실행 과정">[그림 3.1]</a>의 과정을
      순서대로 설명하면 다음과 같다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p><span><strong class="guibutton"><span>tbESQL</span>/C program</strong></span></p>

          <p><span>tbESQL</span>/C 프로그램을 작성한 후 작성된 소스 코드를 저장하면
          <span><strong class="guibutton">.<span>tb</span>c</strong></span> 확장자를 갖는 파일이 생성된다.</p>
        </li><li>
          <p><span><strong class="guibutton">Precompile</strong></span></p>

          <p>작성된 프로그램을 실행하려면 먼저 프리컴파일 과정을 거쳐야 한다.<span>
          tbESQL</span>/C의 프리컴파일러를
          실행하는 명령어는 <span><strong class="guibutton"> <span>tbpc</span></strong></span>이다.</p>

          <p>다음은 emp.<span>tb</span>c 프로그램 파일에 대해 프리컴파일을 실행하는 예이다.</p>

          <div class="example"><a id="ex_tbpc"/><p class="title"><b>[예 3.4] emp.<span>tb</span>c 프로그램의 프리컴파일</b></p><div class="example-contents">
            

            

            <pre class="programlisting">$<span>tbpc</span>  emp.<span>tb</span>c</pre>
          </div></div><br class="example-break"/>

          <p>프리컴파일러를 실행하는 명령어는 옵션을 포함할 수 있다. 다음은 프리컴파일러 옵션을 사용하여 Include
          파일의 경로를 지정하는 예이다.</p>

          <div class="example"><a id="d5e1591"/><p class="title"><b>[예 3.5] 프리컴파일러 옵션을 사용한 Include 파일의 경로 지정</b></p><div class="example-contents">
            

            

            <pre class="programlisting">$<span>tbpc</span>  INCLUDE=../include emp.<span>tb</span>c</pre>
          </div></div><br class="example-break"/>

          <p>프리컴파일러 옵션에 대한 자세한 내용은 <a href="chapter_precompiler_option.html" title="제9장 tbESQL/C 프리컴파일러 옵션">“제9장 <span>tbESQL</span>/C 프리컴파일러 옵션”</a>을 참고한다.</p>
        </li><li>
          <p><span><strong class="guibutton">General program</strong></span></p>

          <p>프리컴파일의 결과로 C 프로그램 소스 코드가 생성된다. 이때 파일의 이름은 원본 파일의 이름과 동일하고 확장자만
          '.c'로 변경된다. 예를 들어 emp.<span>tb</span>c 파일을 프리컴파일하면 emp.c라는 이름을 가진 파일이
          생성된다.</p>
        </li><li>
          <p><span><strong class="guibutton">Compile, Link</strong></span></p>

          <p>프리컴파일이 완료된 파일은 그 다음으로 컴파일 과정과 링크 과정을 거쳐야 한다. <a href="ch03.html#figure_tbcesql_program_compile_link" title="[그림 3.1] tbESQL/C 프로그램의 실행 과정">[그림 3.1]</a>에서는 컴파일과 링크 과정이 따로
          표현되었지만, 실제로는 대개의 경우에 두 과정이 함께 수행된다.</p>

          <p>다음은 <a href="ch03.html#ex_tbpc" title="[예 3.4] emp.tbc 프로그램의 프리컴파일">[예 3.4]</a>의 실행결과로 생성된 emp.c 파일을 컴파일하고 링크하는
          예이다.</p>

          <div class="example"><a id="d5e1611"/><p class="title"><b>[예 3.6] 컴파일과 링크 과정</b></p><div class="example-contents">
              

              

              <pre class="programlisting">$ cc -o emp emp.c -L<span>TB_</span>HOME/client/lib -l<span>tbertl</span> -l<span>tbcli</span> -lpthread -lm</pre>
            </div></div><p><br class="example-break"/></p>

          <p><span>tbESQL</span>/C에서는 <span>tbCLI</span> 함수도 함께 사용하기 때문에 <span>tbERTL</span> 라이브러리 이외에 <span>tbCLI</span> 라이브러리를 함께 링크한다. <a href="ch03.html#figure_tbcesql_program_compile_link" title="[그림 3.1] tbESQL/C 프로그램의 실행 과정">[그림 3.1]</a>에서 링크(Link) 과정에서
          링커(Linker)의 입력으로 받아들이는 <span><strong class="guibutton"><span>tbERTL</span> 라이브러리</strong></span><a id="d5e1625" class="indexterm"/>는 <span>tbESQL</span>/C의 함수 라이브러리이다. 이 라이브러리에는 esql_do
          함수 등이 정의되어 있으며, <span>tbESQL</span>/C 프로그램을 안전하고 효율적으로 실행하기 위한 여러 가지
          작업을 수행한다.</p>
        </li><li>
          <p><span><strong class="guibutton">Execution code</strong></span></p>

          <p>컴파일 과정과 링크 과정을 거치고 나면 실행 파일이 생성된다.</p>
        </li></ol></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1634"/>3.1.3. 런타임 에러 처리</h3></div></div></div>
      

      <p><span>tbESQL</span>/C 프로그램 내의 SQL 문장을 실행했을 때 에러 또는 경고 등의
      여러 가지 예외 상황이 발생할 수 있다. 예를 들면 SELECT 문장의 실행 결과로 반환되는 로우가 존재하지 않거나 특정 컬럼의
      일부 내용이 잘린 경우를 들 수 있다.</p>

      <p><span>tbESQL</span>/C 프로그램 내에서는 에러 또는 경고 상황이 발생한 경우 그에 대한
      적절한 처리를 프로그램 내에서 수행할 수 있다.</p>

      <p><span>tbESQL</span>/C에서는 이러한 런타임 에러 처리를 위해 다음의 3가지 인터페이스를
      지원한다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="100" align="left"/><col/></colgroup><thead><tr><th align="left">인터페이스</th><th>설명</th></tr></thead><tbody><tr><td align="left"><a href="chapter_runtime_error.html#sect_state" title="7.2. 상태 변수">상태 변수</a><a id="d5e1653" class="indexterm"/></td><td><p>상태 변수(Status Variable)는 임의의 SQL 문장이 실행된 결과가 저장되는
              변수이다.</p><p>프로그램 내에서는 SQL 문장을 실행한 후에 상태 변수의 값을 검토하여, 에러 또는
              경고 상황의 발생을 알 수 있고, 그에 따른 처리를 수행할 수 있다.</p></td></tr><tr><td align="left"><a href="chapter_runtime_error.html#sect-sqlca" title="7.3. SQLCA">SQLCA</a><a id="d5e1661" class="indexterm"/></td><td><p>SQLCA(SQL 통신 영역 : SQL Communication Area)는 임의의 SQL
              문장이 실행된 결과가 저장되는 구조체 변수이다. 이 구조체는 sqlca라는 이름으로 sqlca.h 헤더 파일에
              정의되어 있으며, 상태 변수를 포함하고 있다.</p><p>상태 변수와 마찬가지로 SQL 문장을 실행한
              후에 SQLCA 내의 적절한 멤버 변수의 값을 검토하여 에러 또는 경고 상황의 발생을 알 수 있고, 그에 따른
              처리를 수행할 수 있다.</p></td></tr><tr><td align="left"><a href="chapter_runtime_error.html#sect-whenever" title="7.4. WHENEVER">WHENEVER</a><a id="d5e1669" class="indexterm"/></td><td>WHENEVER 문장은 에러 또는 경고 상황이 발생하면 미리 정해진 특정 동작을 수행한다. 상태 변수나
              SQLCA 구조체를 이용하면 SQL 문장을 실행할 때마다 에러 또는 경고 상황이 발생하였는지 검토해야 한다. 하지만
              WHENEVER 문장을 사용하면 <span>tbESQL</span>/C가 자동으로 예외 상황을 검토하고 그에 따른 처리를
              수행한다.</td></tr></tbody></table>
      </div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>런타임 에러 처리에 대한 자세한 내용은 <a href="chapter_runtime_error.html" title="제7장 런타임 에러 처리">“제7장 런타임 에러 처리”</a>를
        참고한다.</p>
      </div>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1676"/>3.2. 프로그램 구조</h2></div></div></div>
    

    <p><span>tbESQL</span>/C 프로그램의 구조는 다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p><a href="ch03.html#sect_variable_declear" title="3.2.1. 변수 선언">변수 선언</a></p>
      </li><li>
        <p><a href="ch03.html#sect_init" title="3.2.2. 초기화">초기화</a></p>
      </li><li>
        <p><a href="ch03.html#sect_database_work" title="3.2.3. 데이터베이스 작업">데이터베이스 작업</a></p>
      </li><li>
        <p><a href="ch03.html#sect_rollback_and_commit" title="3.2.4. 종료화">종료화</a></p>
      </li><li>
        <p><a href="ch03.html#sect_error" title="3.2.5. 에러 처리">에러 처리</a></p>
      </li></ul></div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_variable_declear"/>3.2.1. 변수 선언</h3></div></div></div>
      

      <p>변수 선언 부분에는 <a href="chapter_introduce.html#sect_component" title="1.2. 구성요소">“1.2. 구성요소”</a>에서 설명한 DECLARE 영역이
      포함된다. <span>tbESQL</span>/C 문장에서 데이터베이스 작업에 사용될 모든 변수를 DECLARE
      영역에 선언해야 한다. 데이터베이스 작업과 관련이 없는 변수는 DECLARE 영역에 포함하지 않아도 된다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 변수 선언의 예이다.</p>

      <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
         VARCHAR ename[24];
         int salary;
         VARCHAR addr[32];
EXEC SQL END DECLARE SECTION;</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_init"/>3.2.2. 초기화</h3></div></div></div>
      

      <p>초기화 부분에서는 다음의 두 가지를 수행한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>런타임 에러가 발생했을 때 어떤 작업을 수행할 것인지 선언한다.</p>

          <p>런타임 에러가 발생했을 때 수행하는 작업에는 에러 처리 함수를 호출하는 경우, 에러를 무시하고 프로그램을 계속
          진행하는 경우, 프로그램을 종료하는 경우, 특정 위치로 이동한 후 실행을 계속하는 경우 등이 있다. 대부분의 경우에 에러
          처리를 위한 함수를 미리 정의하고 그 정의된 함수를 호출한다.</p>

          <p>다음은 런타임 에러가 발생했을 때 <code class="function"><span>tbesql</span>_error </code>함수를 호출하는
          예이다.</p>

          <div class="example"><a id="d5e1715"/><p class="title"><b>[예 3.7] <code class="function"><span>tbesql</span>_error</code>함수 호출</b></p><div class="example-contents">
              

              

              <pre class="programlisting">EXEC SQL WHENEVER SQLERROR do <span>tbesql</span>_error(...);</pre>
            </div></div><p><br class="example-break"/></p>
        </li><li>
          <p><span>Tibero</span>의 데이터베이스에 접속한다.</p>

          <p>데이터베이스에 접속할 때는 반드시 사용자 이름과 패스워드를 함께 명시해야 한다.</p>

          <p>다음은 두 개의 입력 변수(username, password)를 이용해 데이터베이스에 접속하는
          예이다.</p>

          <div class="example"><a id="d5e1727"/><p class="title"><b>[예 3.8] 입력 변수를 이용해 데이터베이스에 접속</b></p><div class="example-contents">
              

              

              <pre class="programlisting">EXEC SQL CONNECT :username IDENTIFIED BY :password;</pre>
            </div></div><p><br class="example-break"/></p>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_database_work"/>3.2.3. 데이터베이스 작업</h3></div></div></div>
      

      <p>데이터베이스 작업 부분에서는 <span>tbESQL</span>/C 문장을 사용해 데이터베이스 질의 및 갱신을 수행한다. 이 부분은
      <span>tbESQL</span>/C 프로그램에서 가장 중요한 부분 중 하나이다.</p>

      <p>데이터베이스와 관련된 작업에는 입력 변수와 출력 변수를 많이 사용하게 된다. 데이터베이스 질의와 관련된 소스 코드에는
      커서를 선언하고, 이 선언된 커서를 이용해 로우를 액세스하는 코드가 포함된다.</p>

      <p>다음은 데이터베이스 작업 부분의 예이다.</p>

      <pre class="programlisting">EXEC SQL DECLARE C1 CURSOR FOR
     select branch_cd from branch order by branch_cd;
EXEC SQL OPEN C1;
EXEC SQL FETCH C1 INTO :result;
EXEC SQL CLOSE C1;</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_rollback_and_commit"/>3.2.4. 종료화</h3></div></div></div>
      

      <p>종료화 부분에서는 모든 데이터베이스 작업을 마치고 커밋을 수행하거나 롤백을 수행한다.</p>

      <div class="caution" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">주의</h3>
        <p>종료화 부분이 <span>tbESQL</span>/C 프로그램에 포함되지 않으면, 자동으로 커밋되지 않으므로
        주의한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 데이터베이스에 부분 롤백을 수행한 뒤 커밋을 하는 예이다.</p>

      <pre class="programlisting">EXEC SQL ROLLBACK WORK TO SAVEPOINT SP1;
EXEC SQL COMMIT WORK;</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_error"/>3.2.5. 에러 처리</h3></div></div></div>
      

      <p>에러 처리 부분에서는 런타임 에러를 처리하기 위한 코드가 포함된다. 에러 처리와 관련된 코드는 다른 코드와 섞여 동일한
      하나의 함수 안에 포함될 수도 있으며, 별도의 함수로 정의할 수도 있다.</p>

      <p>다음은 에러 처리의 예이다.</p>

      <pre class="programlisting">EXEC SQL WHENEVER SQLERROR
DO printf("file: %s, line: %d, err_code: %d\n", __FILE__, __LINE__, sqlca.sqlcode);</pre>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1754"/>3.3. <span>tbESQL</span>/C 문장 실행</h2></div></div></div>
    

    <p>본 절에서는 <span>tbESQL</span>/C 프로그램에서 SELECT, INSERT, UPDATE, DELETE
    문장을 실행하는 방법에 대해 설명한다.</p>

    <p>각 문장에는 입/출력 변수가 사용되는데, 입/출력 변수는 각 문장 내에 포함된 스키마 객체와 구별하기 위하여 반드시 앞에
    <span><strong class="guibutton">콜론(:)</strong></span>이 와야 한다. 입/출력 변수는 이미 각 용도에 맞게 선언된 C 프로그래밍 언어의
    변수이며, 이 변수를 <span><strong class="guibutton">호스트 변수</strong></span>라고 한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1762"/>3.3.1. SELECT<a id="d5e1764" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">SELECT</strong></span> 문장은 데이터베이스에 질의를 수행하고 결과 로우를 반환하는
      문장이다. 결과 로우의 개수는 보통 하나 이상이지만 하나도 없을 수도 있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1769"/>INTO 절과 출력 변수<a id="d5e1770" class="indexterm"/><a id="d5e1772" class="indexterm"/></h4>

      <p><span>tbESQL</span>/C 프로그램 내에서 사용되는 SELECT 문장은 일반 SELECT
      문장과 같은 문법을 가진다. 다만 SELECT 리스트 다음에 결과 로우의 각 컬럼 값을 <span><strong class="guibutton">출력
      변수</strong></span>에 저장하기 위해 <span><strong class="guibutton"> INTO 절</strong></span>이 삽입된다.</p>

      <p>다음은 SELECT 문장의 INTO 절에 출력 변수가 사용된 예이다.</p>

      <pre class="programlisting">EXEC SQL SELECT LENGTH(VARCHAR_COL)
         INTO :col_len FROM TEST;</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 SELECT 문장의 INTO 절에 포함되는 출력 변수에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>컬럼 값과 출력 변수의 대응</p>

          <p>INTO 절에 포함되는 출력 변수는 SELECT 리스트 내의 컬럼과 같은 개수이어야 하며, 지시자 변수와 함께
          사용될 수 있다. 질의 결과로 반환된 로우의 각 컬럼 값은 컬럼 값과 동일한 순서로 대응되는 각각의 출력 변수에 저장된다.
          출력 변수에 저장될 때 <span>tbESQL</span>/C 프로그램에서는 필요한 경우 데이터 타입의 변환을
          수행한다.</p>
        </li><li>
          <p>구조체 변수</p>

          <p>INTO 절에 포함되는 출력 변수에는 구조체 변수를 사용할 수도 있다. 이때 구조체 변수에 포함된 멤버 변수의
          개수는 SELECT 리스트 내의 컬럼과 개수가 같아야 한다.<span>
          tbESQL</span>/C 프로그램에서는
          결과 로우의 각 컬럼 값을 구조체 변수 내의 각 멤버 변수에 할당한다.</p>
        </li><li>
          <p>로우의 개수에 따른 출력 변수</p>

          <p>SELECT 문장의 결과 로우의 개수가 반드시 하나라는 보장이 있다면 INTO 절에 단순 출력 변수를 이용하여
          처리가 가능하다. 하지만 하나 이상인 경우에는 커서를 사용하거나 INTO 절에 출력 배열 변수를 사용해야
          한다.</p>
        </li></ul></div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>커서에 대한 자세한 내용은 <a href="ch03.html#sect_cursor" title="3.4. 커서">“3.4. 커서”</a>와 <a href="ch03.html#sect_scrollable_cursor" title="3.5. 스크롤 가능 커서">“3.5. 스크롤 가능 커서”</a>, 배열 변수에 대한 자세한 내용은 <a href="chapter_array_variable.html" title="제4장 배열 변수">“제4장 배열 변수”</a>를 참고한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 결과 로우가 하나인 경우 이를 처리하는 예이다.</p>

      <pre class="programlisting">VARCHAR ename[24];
int salary;
int empno;
... 
empno = 20;
EXEC SQL SELECT ENAME, SALARY * 1.05
     INTO :ename, :salary
     FROM EMP
     WHERE EMPNO = :empno;
printf("ename = %s\n", ename.arr);</pre>

      <p>위의 예에서 컬럼 EMPNO가 테이블 EMP의 기본 키 컬럼이므로 질의 결과 로우의 개수가 하나라는 것을 알 수
      있다.</p>

      <p/>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1805"/>WHERE 절과 입력 변수</h4>

      <p>SELECT 문장 내에서 변수의 위치는 INTO 절에 출력 변수가 포함되는 것 외에 <span><strong class="guibutton"> WHERE
      절</strong></span>에 <span><strong class="guibutton">입력 변수</strong></span>가 포함된다.<a id="d5e1809" class="indexterm"/><a id="d5e1811" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>다음은 SELECT 문장의 WHERE 절에 입력 변수가 사용된 예이다.</p>

      <pre class="programlisting">EXEC SQL SELECT COUNT(*) INTO :cnt FROM TEST
         WHERE VARCHAR_COL = :varchar_col;</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 SELECT 문장의 WHERE 절에 포함되는 입력 변수에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>입력 변수의 값 설정</p>

          <p>WHERE 절에 포함되는 입력 변수의 값은 SELECT 문장이 실행되기 전에 설정되어 있어야 한다. 그 이유는
          SELECT 문장은 실행 직전에 입력 변수의 값을 가져와서 SELECT 문장을 완성한 뒤에 실행되기 때문이다. SELECT
          문장의 실행에 필요한 입력 변수의 값은 그 문장이 실행되기 직전에 읽혀지므로, 입력 변수의 값은 프로그램 실행 중에
          동적으로 설정할 수 있다.</p>
        </li><li>
          <p>입력 변수 사용의 제약</p>

          <p>SELECT 문장의 입력 변수는 상수를 대신하여 사용할 수 있지만 스키마 객체 또는 컬럼 등의 이름을 대신하여
          사용될 수는 없다. SELECT 문장에 부질의(Subquery)가 사용되는 경우에는 부질의 내에 출력 변수를 포함시킬 수는
          없지만 입력 변수를 포함시킬 수는 있다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 컬럼의 이름을 대신하여 입력 변수가 사용된 예이다.</p>

      <pre class="programlisting">VARCHAR ename[24];
int salary;
VARCHAR col_name[32];
...
strcpy(col_name.arr, "EMPNO");
col_name.len = strlen(col_name.arr);
EXEC SQL SELECT ENAME, SALARY
     INTO :ename, :salary
     FROM EMP
     WHERE :col_name = 20;</pre>

      <p>위의 예의 맨 마지막 라인에서 WHERE 절 다음에 컬럼의 이름이 나와야 하는데, 대신 변수가 사용되었기 때문에
      잘못되었다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1829"/>3.3.2. INSERT<a id="d5e1831" class="indexterm"/></h3></div></div></div>
      

      <p>INSERT, DELETE, UPDATE 문장은 공통적으로 질의의 결과 로우가 존재하지 않으므로 출력 변수 없이 입력
      변수만을 사용한다.<span><strong class="guibutton"> INSERT</strong></span> 문장에서 입력 변수는
      <span><strong class="guibutton">컬럼</strong></span>에 삽입할 데이터 값의 위치나 <span><strong class="guibutton">부질의</strong></span> 내부에
      사용될 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>INSERT 문장에서 삽입하고자 하는 컬럼 값의 일부에 대해서만 입력 변수를 사용할 수도 있다.</p>

      <p>다음은 일부 컬럼에 대해서만 입력 변수를 사용하는 예이다.</p>

      <pre class="programlisting">VARCHAR ename[24];
int empno;
...
strcpy(ename.arr, "Michael");
empno = 25;
EXEC SQL INSERT INTO EMP (ENAME, SALARY, EMPNO)
         VALUES(:ename, 35000, :empno);</pre>

      <div class="literallayout"><p/></div>

      <p>삽입하고자 하는 모든 컬럼 값에 대하여 입력 변수를 사용하는 경우 구조체 변수를 사용할 수 있다. 이때 구조체 변수에
      포함된 각 변수 값은 삽입하고자 하는 각 컬럼 값에 대응된다.</p>

      <p>다음은 구조체 변수를 사용해 데이터를 삽입하는 예이다.</p>

      <pre class="programlisting">struct {
       VARCHAR ename[24];
       int salary;
       int empno;
} emp;
...
strcpy(emp.ename.arr, "Michael");
emp.ename.len = strlen(emp.ename.arr);
emp.salary = 35000; 
emp.empno= 25; 
EXEC SQL INSERT INTO EMP (ENAME, SALARY, EMPNO)
     VALUES (:emp); </pre>

      <div class="literallayout"><p/></div>

      <p>또한 부질의에 입력 변수를 사용할 수도 있다. 다음은 부질의를 포함하는 INSERT 문장의 예이다.</p>

      <pre class="programlisting">int sal_bound;
...
sal_bound= 30000;
EXEC SQL INSERT INTO EMP_SUB (ENAME, EMPNO)
         SELECT ENAME, EMPNO FROM EMP
         WHERE SALARY &gt;= :sal_bound;</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1848"/>3.3.3. UPDATE<a id="d5e1850" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">UPDATE</strong></span> 문장도 INSERT 문장과 마찬가지로 입력 변수만을
      사용한다.</p>

      <p>UPDATE 문장에서는 <span><strong class="guibutton">SET 절</strong></span>의 컬럼 값의 위치나
      <span><strong class="guibutton">WHERE 절</strong></span>에서 입력 변수가 사용될 수 있다. UPDATE 문장에 포함된
      <span><strong class="guibutton">부질의</strong></span>에서도 입력 변수를 사용할 수 있다. UPDATE 문장에서는 INSERT 문장에서와
      달리 구조체 입력 변수를 사용할 수 없다.<a id="d5e1858" class="indexterm"/><a id="d5e1860" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>다음은 일부 컬럼 값과 WHERE 절 내에 입력 변수를 사용하는 예이다.</p>

      <pre class="programlisting">VARCHAR ename[24];
int empno;
... 
EXEC SQL UPDATE EMP
     SET ENAME = :ename.arr, SALARY = SALARY * 1.05
     WHERE EMPNO = :empno;</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 부질의에 입력 변수를 사용하는 예이다.</p>

      <pre class="programlisting">int empno;
int sal_bound;
...
empno = 20;
sal_bound = 30000; 
EXEC SQL UPDATE EMP
     SET SALARY =(SELECT SALARY FROM EMP WHERE EMPNO = :empno)
     WHERE SALARY &lt;=:sal_bound;</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1868"/>3.3.4. DELETE<a id="d5e1870" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">DELETE</strong></span> 문장도 INSERT, UPDATE 문장과 마찬가지로 입력 변수만을
      사용한다. DELETE 문장에서는 <span><strong class="guibutton">WHERE 절</strong></span>에서 입력 변수가 사용된다. DELETE
      문장에서도 UPDATE 문장과 마찬가지로 구조체 입력 변수를 사용할 수 없다.<a id="d5e1875" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>다음은 입력 변수를 사용하는 DELETE 문장의 예이다.</p>

      <pre class="programlisting">int sal_bound;
...
sal_bound = 25000;
EXEC SQL DELETE FROM EMP
         WHERE SALARY &lt;= :sal_bound;</pre>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_cursor"/>3.4. 커서<a id="d5e1882" class="indexterm"/></h2></div></div></div>
    

    <p>본 절에서는 커서의 기본적인 사용 방법에 대하여 설명하고, 갱신 및 삭제를 위한 CURRENT OF 절을 설명한다. 그리고
    마지막으로 사용 예제를 제시한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1885"/>3.4.1. 사용 방법</h3></div></div></div>
      

      <p>SELECT 문을 통한 질의를 수행할 때 WHERE 절에 기본 키 제약조건을 부여하지 않으면, 대개의 경우 결과 로우의
      개수는 하나 이상이다. <span><strong class="guibutton">커서</strong></span>는 이렇게 반환된 다수의 결과 로우에 각각 차례로 액세스하기
      위한 데이터 구조이다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 커서를 사용하는 순서이다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p>커서를 사용하기 위해서는 DECLARE CURSOR를 사용해 맨 먼저 SQL 문장과 연관하여 커서를 선언해야
          한다. 커서를 선언할 때에는 항상 커서의 이름을 주어야 하며, 커서의 선언부는 그 커서를 사용하는 다른 모든 문장의 앞에
          와야 한다.</p>

          <p>다음은 emp_cursor라는 이름으로 커서를 선언하는 예이다.</p>

          <div class="example"><a id="ex_declare_cursor"/><p class="title"><b>[예 3.9] 커서의 선언</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL DECLARE emp_cursor CURSOR FOR
         SELECT ENAME, SALARY, ADDR 
         FROM EMP 
         WHERE DEPTNO = :deptno;</pre>
          </div></div><br class="example-break"/>
        </li><li>
          <p>커서를 사용하기 위해서는 OPEN을 사용해 해당 커서를 열어야 한다.<a id="d5e1900" class="indexterm"/></p>

          <p>OPEN을 실행하면 연관된 SELECT 문장이 실행되어 질의의 결과 로우가 반환된다. 또한 커서는 결과 로우
          중에서 맨 처음에 위치한 로우의 직전을 가리킨다. 첫 FETCH가 실행되면 첫 번째 로우를 가리키게 된다.
          <span><strong class="guibutton">OPEN을 실행해서 커서를 선언할 때에 SELECT 문장에 포함된 입력 변수의 값은 OPEN이 실행될
          때 할당된다는 것에 유의한다. </strong></span></p>

          <p>다음은 <a href="ch03.html#ex_declare_cursor" title="[예 3.9] 커서의 선언">[예 3.9]</a>에서 선언한 emp_cursor라는
          이름의 커서에 OPEN을 실행하는 예이다.</p>

          <div class="example"><a id="d5e1906"/><p class="title"><b>[예 3.10] OPEN의 실행</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL OPEN emp_cursor; </pre>
          </div></div><br class="example-break"/>
        </li><li>
          <p>FETCH를 실행해 로우에 액세스를 한다.<a id="d5e1911" class="indexterm"/></p>

          <p>OPEN의 실행으로는 아직 로우에 액세스를 할 수 있는 것은 아니다. 로우에 액세스를 하기 위해서는 FETCH를
          실행해야 한다. FETCH의 INTO 절에는 구조체 변수나 지시자 변수를 함께 사용할 수 있다.</p>

          <p>다음은 FETCH를 실행하는 예이다.</p>

          <div class="example"><a id="d5e1915"/><p class="title"><b>[예 3.11] FETCH의 실행</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL FETCH emp_cursor
         INTO :ename, :salary, :addr;</pre>

            <p/>
          </div></div><br class="example-break"/>

          <p>FETCH를 실행하면 먼저 커서가 다음 결과 로우를 가리키게 되고, 커서가 가리키는 결과 로우를 출력 변수에
          저장한다. FETCH를 실행할 때마다 커서는 다음 결과 로우를 가리키고, 결국 맨 마지막 결과 로우의 범위를 넘어
          FETCH를 실행하면, NOT FOUND 에러가 발생한다.</p>

          <p>대개의 경우 FETCH를 <span><strong class="guibutton">무한 루프</strong></span> 안에 포함시키며,
          <span><strong class="guibutton">NOT FOUND 에러</strong></span>가 발행하면 루프를 빠져 나오도록 코드를 작성한다. 이때
          NOT FOUND 에러가 발생했을 때 루프를 빠져 나오도록 하기 위해서는
          <span><strong class="guibutton">WHENEVER</strong></span> 문장을 사용한다.</p>

          <p>다음은 WHENEVER 문장을 사용하는 예이다.</p>

          <div class="example"><a id="d5e1925"/><p class="title"><b>[예 3.12] WHENEVER 문장의 사용</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL WHENEVER NOT FOUND DO break; 
while (1) {
          EXEC SQL FETCH emp_cursor
          INTO :ename, :salary, :addr;
    ...
}</pre>
          </div></div><br class="example-break"/>

          <p>WHENEVER 문장에 DO break 명령 이외에 GOTO 명령을 사용할 수도 있다.</p>

          <p>OPEN을 사용해 커서를 열기 전이나 CLOSE를 사용해 커서를 닫은 후 그리고 NOT FOUND 에러가 발생한
          이후에 FETCH를 실행하면 에러가 발생한다.</p>

          <p>FETCH를 이용해 다음 로우 뿐만 아니라 이전 로우를 액세스할 수도 있다. 이러한 작업을 위해서는 스크롤 가능
          커서를 선언해야 한다. 스크롤 가능 커서에 대해서는 <a href="ch03.html#sect_scrollable_cursor" title="3.5. 스크롤 가능 커서">“3.5. 스크롤 가능 커서”</a>를 참고한다.</p>
        </li><li>
          <p>커서 사용의 마지막 단계는 CLOSE를 사용해 커서를 닫는 것이다. 커서를 닫은 이후에는 그 커서에 대해 어떠한
          작업도 실행할 수 없다.</p>

          <p>다음은 emp_cursor라는 이름의 커서에 CLOSE를 실행하는 예이다.</p>

          <div class="example"><a id="d5e1935"/><p class="title"><b>[예 3.13] CLOSE 사용 예</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL CLOSE emp_cursor; </pre>
          </div></div><br class="example-break"/>
        </li></ol></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_current_of_statement"/>3.4.2. CURRENT OF 절</h3></div></div></div>
      

      <p>커서를 이용해 SELECT 문장의 실행 결과 로우를 차례로 액세스하면서 커서가 현재 가리키고 있는 결과 로우를
      삭제하거나 갱신하려고 할 때 DELETE 문장과 UPDATE 문장에 <span><strong class="guibutton">CURRENT OF
      절</strong></span>을 사용한다.<a id="d5e1942" class="indexterm"/></p>

      <p>SELECT 문장에서 CURRENT OF 절을 사용하기 위해서는 FOR UPDATE 절을 포함해야 한다.
      <span><strong class="guibutton">FOR UPDATE 절</strong></span>은 질의 결과로 반환된 로우에 잠금(LOCK)을 설정한다. 잠금이
      설정된 로우는 현재 트랜잭션이 커밋 또는 롤백되기 전까지는 다른 트랜잭션이 로우를 갱신하거나 삭제할 수 없다.<a id="d5e1946" class="indexterm"/><a id="d5e1948" class="indexterm"/> <a id="d5e1950" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>다음은 UPDATE 문장에서 CURRENT OF 절을 이용하여 컬럼 SALARY만을 갱신하는 예이다.</p>

      <pre class="programlisting">EXEC SQL DECLARE emp_cursor CURSOR FOR
         SELECT ENAME, SALARY, ADDR 
         FROM EMP 
         WHERE DEPTNO =:deptno
         FOR UPDATE OF SALARY;
... 
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND DO break; 

while (1) {
          EXEC SQL FETCH emp_cursor
                   INTO :ename, :salary, :addr;
          ... 
          EXEC SQL UPDATE EMP
                   SET SALARY = SALARY * 1.05
                   WHERE CURRENT OF emp_cursor;
... 
}</pre>

      <p>커서가 현재 가리키고 있는 로우는 FETCH 문장을 실행하여 방금 전에 컬럼 값을 읽은 로우이다.</p>

      <p>커서에 대해 OPEN 문장을 실행한 후에 한번도 FETCH 문장을 실행하지 않았거나 모든 결과 로우를 읽고 나서 NOT
      FOUND 에러가 반환되었다면 커서가 현재 가리키고 있는 로우는 없다. 현재 가리키고 있는 로우가 없는 커서를 이용하여
      DELETE 또는 UPDATE 문장을 실행하였다면 에러를 반환한다. 또한 OPEN 문장을 수행하지 않았거나 CLOSE 문장을 이미
      수행한 커서를 이용하여 삭제 또는 갱신을 시도할 때에도 에러를 반환한다.</p>

      <p>CLOSE_ON_COMMIT 옵션이 'YES'로 지정된 경우를 제외하고는 일반적으로 커서는 현재 트랜잭션이 커밋 또는
      롤백한 후에도 사용할 수 있다. 즉, 커서를 이용하여 질의 결과 로우를 액세스할 수 있다. 하지만 FOR UPDATE 절을 포함한
      SELECT 문장에 대한 커서는 사용할 수 없다. 왜냐하면 트랜잭션이 커밋되거나 롤백되는 동시에 결과 로우에 설정되었던 잠금을
      해제해 버리기 때문이다.</p>

      
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1958"/>3.4.3. 사용 예제</h3></div></div></div>
      

      <p>다음은 커서를 사용하는 예제 프로그램이다.</p>

      <div class="example"><a id="ex_using_cursor"/><p class="title"><b>[예 3.14] 커서의 사용</b></p><div class="example-contents">
        

        

        <pre class="programlisting">#include &lt;stdio.h&gt; 
#include &lt;sqlca.h&gt; 
#include &lt;string.h&gt;
#define USERPASS "<span>tibero</span>/<span>tibero</span>" 
int main() 
{ 
    EXEC SQL <span><strong class="guibutton">BEGIN DECLARE SECTION;</strong></span><em class="lineannotation"><span class="lineannotation">                                ... ① ...</span></em>
             VARCHAR userpass[20] = {strlen(USERPASS), USERPASS}; 
             VARCHAR ename[24]; 
             int salary; 
             VARCHAR addr[32]; 
             int deptno; 
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE <span><strong class="guibutton">emp_cursor</strong></span> CURSOR FOR                         <em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
             SELECT ENAME, SALARY, ADDR 
             FROM EMP 
             WHERE DEPTNO =<span><strong class="guibutton">:deptno; </strong></span><em class="lineannotation"><span class="lineannotation">                               ... ③ ...</span></em>

    EXEC SQL DECLARE <span><strong class="guibutton">emp_update_cursor</strong></span> CURSOR FOR <em class="lineannotation"><span class="lineannotation">                 ... ④ ...</span></em>
             SELECT SALARY
             FROM EMP 
             WHERE DEPTNO =<span><strong class="guibutton">:deptno</strong></span><em class="lineannotation"><span class="lineannotation">                                 ... ⑤ ...</span></em>
             FOR UPDATE OF SALARY; 

    EXEC SQL CONNECT :userpass;

    printf("Connected.\n"); 
    printf("Enter dept number to show: ");
    scanf("%d", &amp;deptno); 
    
    EXEC SQL OPEN emp_cursor; 
    EXEC SQL WHENEVER NOT FOUND DO break; 

    while (1) 
    { 
        EXEC SQL FETCH emp_cursor
                 INTO :ename, :salary, :addr; 
        
        printf("ename = %s, salary = %d, addr= %s\n", 
                ename.arr, salary, addr.arr); 
    }

    EXEC SQL CLOSE emp_cursor;

    printf("Enter dept number to raise salary: "); 
    scanf("%d",&amp;deptno); 
    
    EXEC SQL OPEN emp_update_cursor; 
    EXEC SQL WHENEVER NOT FOUND DO break; 

    while (1)
    { 
        EXEC SQL FETCH emp_update_cursor
                 INTO :salary; 

        EXEC SQL UPDATE EMP 
                 SET SALARY = :salary * 1.05 
                 WHERE CURRENT OF emp_update_cursor; 
    } 

    EXEC SQL CLOSE emp_update_cursor;
    EXEC SQL COMMIT WORK RELEASE;                                  <em class="lineannotation"><span class="lineannotation">... ⑥ ...</span></em>
    
    return 1; 
}</pre>
      </div></div><br class="example-break"/>

      <p>① <span>tbESQL</span>/C 문장 내에 포함되는 모든 입/출력 변수는 DECLARE 영역
      안에서 선언한다. 프로그램의 맨 앞쪽에서 커서를 선언하고 있지만, 변수의 선언과는 달리 커서의 선언은 어떠한 위치에 오더라도
      상관없으며, 그 커서가 사용되기 전에만 선언되면 된다.</p>

      <p>②, ④ 두 개의 커서를 선언한다. 각각 단순 질의와 갱신을 위한 커서인데, 단순 질의를 위한 커서는
      emp_cursor이고, 갱신을 위한 커서는 emp_update_cursor이다.</p>

      <p>③, ⑤ 변수 deptno가 두 개의 커서에 공통적으로 사용된다. 커서와 연관된 SELECT 문장은 OPEN 문장으로
      커서를 열 때 실행되며, 그 직전에 입력 변수의 값을 읽어 들인다. 따라서 같은 변수를 사용하더라도 각각의 SELECT 문장이
      실행될 때 서로 다른 deptno 값이 적용될 수도 있다.</p>

      <p>⑥ 프로그램의 맨 마지막에서는 현재 트랜잭션을 커밋한다. 단순 질의를 위한 커서 emp_cursor는 트랜잭션 커밋
      후에도 계속 사용할 수 있으나, 갱신을 위한 커서 emp_update_cursor는 사용할 수 없다.</p>

      
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_scrollable_cursor"/>3.5. 스크롤 가능 커서<a id="d5e1984" class="indexterm"/><a id="d5e1986" class="indexterm"/></h2></div></div></div>
    

    <p>본 절에서는 스크롤 가능 커서(Scrollable Cursors)의 사용 방법과 예제를 설명한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1989"/>3.5.1. 사용 방법</h3></div></div></div>
      

      <p>커서는 질의의 결과 로우를 액세스할 때 항상 다음에 위치한 로우만 액세스할 수 있는 것에 비해,
      <span><strong class="guibutton">스크롤 가능 커서</strong></span>는 임의의 로우에 액세스를 할 수 있다. 예를 들어 스크롤 가능 커서는
      현재 커서가 가리키고 있는 로우의 바로 이전 로우를 액세스하거나 전체 결과 로우 중에서 n번째 로우를 액세스할 수
      있다.<a id="d5e1993" class="indexterm"/></p>

      <p>스크롤 가능 커서는 사용 방법의 편리성과 유연성을 제공하지만 커서와 비교했을 때 메모리 등의 리소스를 많이 사용할 수
      있으므로 프로그램의 실행 성능을 떨어뜨릴 수 있다. 따라서 꼭 필요한 경우가 아니라면 커서를 사용하는 것이
      효율적이다.</p>

      <p>다음은 커서와 스크롤 가능 커서의 차이점이다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>커서</th><th>스크롤 가능 커서</th></tr></thead><tbody><tr><td>다음 위치에 있는 로우만 차례대로 액세스를 한다.</td><td>임의의 위치에 있는 로우를 액세스할 수 있다.</td></tr><tr><td>'DECLARE {<span class="emphasis"><em>커서 이름</em></span>} CURSOR'의 형태로
              선언한다.</td><td>'DECLARE {<span class="emphasis"><em>커서 이름</em></span>} SCROLL CURSOR'의 형태로
              선언한다.</td></tr><tr><td>FETCH를 실행할 때 옵션을 지정할 수 없다.</td><td>FETCH를 실행할 때 반드시 옵션을 지정해야 한다.</td></tr></tbody></table>
      </div>

      <p>스크롤 가능 커서에서도 커서와 동일하게 OPEN과 CLOSE를 사용한다. 스크롤 가능 커서가 현재 가리키고 있는 로우에
      대하여 삭제 및 갱신을 수행하고자 할 때에도 커서와 마찬가지로 DELETE 문장과 UPDATE 문장 내에서 CURRENT OF
      절을 이용한다. 문장의 작성 및 사용 방법은 커서와 동일하다.</p>

      <p>커서 이름을 지정하는데는 다음 사항을 고려해야한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
           커서 이름에 "SQLCUR", "SQL_CUR"를 포함하지 않아야한다. 
        </li><li>
           커서 이름의 길이가 128이 넘어가지 않도록 한다. 
        </li><li>
           커서 이름의 길이이 128이 넘어가면 CLI단에서 이름을 128로 자른다. 
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>커서와 스크롤 가능 커서의 차이점을 좀더 상세하게 설명하면 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p><span><strong class="guibutton">스크롤 가능 커서의 선언</strong></span></p>

          <p>스크롤 가능 커서의 선언은 <span><strong class="guibutton">SCROLL</strong></span> 키워드가 포함된다는 것을
          제외하면 커서의 선언과 동일하며 다음과 같은 형태로 선언한다.</p>

          <pre class="programlisting">DECLARE {<span class="emphasis"><em>커서 이름</em></span>} SCROLL CURSOR</pre>

          <p>다음의 소스 코드는 스크롤 가능 커서를 선언하는 예이다.</p>

          <pre class="programlisting">EXEC SQL <span><strong class="guibutton">DECLARE</strong></span> emp_scroll_cursor <span><strong class="guibutton">SCROLL CURSOR</strong></span> FOR 
         SELECT ENAME, SALARY, ADDR
         FROM EMP 
         WHERE DEPTNO = :deptno;</pre>
        </li><li>
          <p><span><strong class="guibutton">스크롤 가능 커서에서의 FETCH의 사용</strong></span></p>

          <p>스크롤 가능 커서에서 FETCH를 사용할 때는 항상 액세스할 대상 로우를 지정해야 한다.</p>

          <p>다음은 FETCH에서 액세스를 할 대상 로우를 지정할 때 사용되는 옵션이다.</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">옵션</th><th>설명</th></tr></thead><tbody><tr><td align="left">NEXT</td><td>현재 커서가 가리키는 로우의 다음 로우에 액세스를 한다. PRIOR 옵션과 반대이다. (생략
                  가능)</td></tr><tr><td align="left">PRIOR</td><td>현재 커서가 가리키는 로우의 이전 로우에 액세스를 한다. NEXT 옵션과
                  반대이다.</td></tr><tr><td align="left">FIRST</td><td>맨 처음에 위치한 로우에 액세스를 한다. LAST 옵션과 반대이다.</td></tr><tr><td align="left">LAST</td><td>맨 마지막에 위치한 로우에 액세스를 한다. FIRST 옵션과 반대이다.</td></tr><tr><td align="left">CURRENT</td><td>현재 로우에 액세스를 한다.</td></tr><tr><td align="left">RELATIVE offset</td><td>현재 커서가 가리키고 있는 로우의 다음 offset 번째에 위치한 로우에 액세스를 한다.
                  offset 값이 음수라면 커서가 현재 위치에서 앞으로 이동한다. 예를 들어 현재 커서가 8번째 로우를
                  가리키고 있는데, 'FETCH RELATIVE -3'을 실행한다면 커서는 5번째 로우를 가리키게
                  된다.</td></tr><tr><td align="left">ABSOLUTE offset</td><td>전체 로우 중에서 offset 번째 로우에 액세스를 한다.</td></tr></tbody></table>
          </div>

          <p>다음은 FETCH에 옵션을 사용하는 예이다.</p>

          <pre class="programlisting">EXEC SQL FETCH PRIOR emp_scroll_cursor 
    INTO :ename, :salary, :addr; 

EXEC SQL FETCH LAST emp_scroll_cursor 
    INTO :ename, :salary, :addr; 

EXEC SQL FETCH ABSOLUTE 3 emp_scroll_cursor 
    INTO :ename, :salary, :addr;</pre>

          <p>위의 예에서는 각각 순서대로 첫 번째 문장은 이전 로우를 액세스하고, 두 번째 문장은 마지막 로우를 액세스하고,
          세 번째 문장은 전체 로우 중에서 세 번째 로우를 액세스하고 있다. 만약 액세스하고자 하는 로우가 존재하지 않으면 NOT
          FOUND 에러가 반환된다.</p>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2072"/>3.5.2. 사용 예제</h3></div></div></div>
      

      <p>다음은 스크롤 가능 커서를 사용하는 예제 프로그램이다.</p>

      <pre class="programlisting">#include &lt;stdio.h&gt; 
#include &lt;sqlca.h&gt; 
#include &lt;string.h&gt;
#define USERPASS "<span>tibero</span>/<span>tibero</span>" 
int main()
{ 
    EXEC SQL BEGIN DECLARE SECTION; 
    VARCHAR userpass[20]= { strlen(USERPASS), USERPASS }; 
    VARCHAR ename[24]; int salary;
    VARCHAR addr[32]; 
    int deptno; 
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE emp_scroll_cursor SCROLL CURSOR FOR 
        SELECT ENAME, SALARY, ADDR FROM EMP 
        WHERE DEPTNO = :deptno; 

    EXEC SQL CONNECT :userpass;
    printf("Connected.\n"); 
    printf("Enter dept number to show: ");
    scanf("%d", &amp;deptno); 

    EXEC SQL OPEN emp_scroll_cursor; 

    EXEC SQL FETCH FIRST emp_scroll_cursor 
        INTO :ename, :salary, :addr; /* 1strow */ 

    EXEC SQL FETCH LAST emp_scroll_cursor 
        INTO :ename, :salary,:addr; /* last row */ 

    EXEC SQL FETCH ABSOLUTE 5 emp_scroll_cursor
        INTO :ename, :salary, :addr; /* 5th row */ 

    EXEC SQL FETCH RELATIVE 3 emp_scroll_cursor 
        INTO :ename, :salary, :addr; /* 8th row */ 

    EXEC SQL FETCH PRIOR emp_scroll_cursor 
        INTO :ename, :salary, :addr; /*7th row */ 

    EXEC SQL FETCH CURRENT emp_scroll_cursor 
        INTO :ename,:salary, :addr; /* 7th row */ 

    EXEC SQL FETCH RELATIVE -3 emp_scroll_cursor 
        INTO :ename, :salary, :addr; /* 4th row */ 

    EXEC SQL FETCH emp_scroll_cursor 
        INTO :ename, :salary, :addr; /* 5th row*/ 

    EXEC SQL CLOSE emp_scroll_cursor; 
    EXEC SQL COMMIT WORK RELEASE;
    
    return 1; 
}</pre>

      <p>위의 예에서는 주석을 삽입하여 FETCH를 실행할 때마다 스크롤 가능 커서의 현재 위치를 설명하였다. 또한 질의 결과
      로우가 8개 이상임을 가정한다. SQL 문장 내에 포함되는 모든 입/출력 변수는 DECLARE 영역 안에서 선언하였다. 커서를
      선언할 때와 마찬가지로 스크롤 가능 커서를 선언하는 문장도, 스크롤 가능 커서가 사용되기 전이라면 어떤 위치에 있어도
      상관없다.</p>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_datatype.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_array_variable.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제2장 데이터 타입 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제4장 배열 변수</td></tr></table></div><div xmlns="" align="center"/></body></html>