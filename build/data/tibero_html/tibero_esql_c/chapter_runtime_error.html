<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제7장 런타임 에러 처리</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="up" href="index.html" title="Tibero tbESQL/C 안내서"/><link rel="prev" href="chapter_dynamic_sql.html" title="제6장 Dynamic SQL"/><link rel="next" href="chapter_reference.html" title="제8장 tbESQL/C 문장"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제7장 런타임 에러 처리</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter_dynamic_sql.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_reference.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_runtime_error"/>제7장 런타임 에러 처리</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_runtime_error.html#d5e3121">7.1. 개요</a></span></dt><dt><span class="section"><a href="chapter_runtime_error.html#sect_state">7.2. 상태 변수</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_runtime_error.html#d5e3150">7.2.1. 특징</a></span></dt><dt><span class="section"><a href="chapter_runtime_error.html#d5e3191">7.2.2. 상태 변수 선언</a></span></dt><dt><span class="section"><a href="chapter_runtime_error.html#d5e3216">7.2.3. 상태 변수 종류</a></span></dt><dt><span class="section"><a href="chapter_runtime_error.html#sect_ state_variable_example">7.2.4. 사용 예제</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_runtime_error.html#sect-sqlca">7.3. SQLCA</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_runtime_error.html#sect_struct_sqlca">7.3.1. SQLCA 구조체 변수</a></span></dt><dt><span class="section"><a href="chapter_runtime_error.html#d5e3400">7.3.2. 사용 예제</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_runtime_error.html#sect-whenever">7.4. WHENEVER</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_runtime_error.html#d5e3417">7.4.1. 구성요소</a></span></dt><dt><span class="section"><a href="chapter_runtime_error.html#d5e3529">7.4.2. 사용 예제</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 <span>tbESQL</span>/C 프로그램을 실행할 때 발생할 수 있는 예외 상황을 처리하기 위한 방법인
  런타임 에러 처리에 대해 설명한다.<a id="d5e3119" class="indexterm"/></p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e3121"/>7.1. 개요</h2></div></div></div>
    

    <p><span>tbESQL</span>/C 프로그램에서 SQL 문장을 실행하는 중에 에러가 발생했을 때, 그에
    대한 적절한 조치를 취하기 위해 다음의 3가지 인터페이스를 제공한다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p><a href="chapter_runtime_error.html#sect_state" title="7.2. 상태 변수">상태 변수</a></p>
      </li><li>
        <p><a href="chapter_runtime_error.html#sect-sqlca" title="7.3. SQLCA">SQLCA</a></p>
      </li><li>
        <p><a href="chapter_runtime_error.html#sect-whenever" title="7.4. WHENEVER">WHENEVER</a></p>
      </li></ul></div>

    <p><span>tbESQL</span>/C 프로그램 내에서 하나의 SQL 문장을 실행하면 항상
    <span><strong class="guibutton">상태 변수</strong></span> 또는 <span><strong class="guibutton">SQLCA</strong></span>에 실행 결과 또는 에러
    정보를 저장한다. 애플리케이션 프로그램 개발자는 SQL 문장을 실행한 직후에 상태 변수 또는 SQLCA를 검토하여 에러가 발생했을 때
    해결을 위해 코드를 삽입해 주어야 한다.</p>

    <p>상태 변수와 SQLCA의 변수는 SQL 문장이 실행될 때마다 자동으로 변경되고, 프로그램 내에서 그 내용을 검토해야 한다.
    이러한 작업을 자동적으로 수행하기 위하여 <span><strong class="guibutton">WHENEVER 문장</strong></span>을 사용한다. WHENEVER
    문장은 에러 또는 경고가 발생했을 때 그에 따른 처리를 위한 특정한 작업을 수행하도록 선언한다.</p>

    <p>일반적인 <span>tbESQL</span>/C 프로그램에서는 WHENEVER 문장을 이용하여 에러 또는 경고가
    발생했을 때 특정한 에러 처리 함수를 호출하도록 선언한다. 에러 처리 함수는 상태 변수 또는 SQLCA의 변수의 내용을 검토하여
    적절히 조치한다. 에러 상황에 따라 프로그램을 계속 진행하거나 정지시킬 수 있다.</p>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_state"/>7.2. 상태 변수<a id="d5e3146" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">상태 변수</strong></span>는 에러 또는 경고 코드를 가지며, 에러 또는 경고에 대한 상세한 정보가
    저장된다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3150"/>7.2.1. 특징</h3></div></div></div>
      

      <p>상태 변수에는 SQLSTATE와 SQLCODE가 있는데, 주요 특징은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>두 상태 변수는 <span><strong class="guibutton">서로 다른 값</strong></span>을 갖는다.</p>

          <p>SQL 문장을 실행할 때마다 두 상태 변수의 값은 <span>tbESQL</span>/C 프로그램에 의해 자동적으로 갱신되는데, 같은 예외
          상황이라고 해도 두 상태 변수는 서로 다른 값을 갖는다. SQLSTATE에는 <span><strong class="guibutton">에러 및 경고
          코드</strong></span>가 저장되지만 SQLCODE에는 <span><strong class="guibutton">에러 코드</strong></span>만이
          저장된다.</p>
        </li><li>
          <p>SQLSTATE의 길이는 <span><strong class="guibutton">5bytes</strong></span>이다.</p>

          <p>SQLSTATE는 6bytes로 선언하지만 맨 마지막에 포함되는 NULL 문자를 제외하면, 실제
          SQLSTATE의 길이는 5bytes이다.</p>
        </li><li>
          <p>SQLSTATE는 다음의 <span><strong class="guibutton">두 가지 코드</strong></span>로 구성된다.</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">코드</th><th>설명</th></tr></thead><tbody><tr><td align="left">클래스 코드<a id="d5e3178" class="indexterm"/></td><td>에러 또는 경고에 대한 큰 분류이며, 크기는 2bytes이다.</td></tr><tr><td align="left">서브 클래스 코드<a id="d5e3183" class="indexterm"/></td><td>클래스 코드의 큰 분류 내부의 구체적인 내용을 포함하고 있으며, 크기는
                  3bytes이다.</td></tr></tbody></table>
          </div>

          <p>클래스 코드와 서브 클래스 코드를 예를 들어 설명하면, SQLSTATE의 값이 '22012'라면, 클래스 코드
          '22'는 데이터 예외 상황(Data exception)을 의미하며 서브 클래스 코드 '012'는 0으로 나눔(Divide
          by zero)을 의미한다.</p>
        </li><li>
          <p>SQLSTATE에는 <span><strong class="guibutton">'0' ~ '9', 'A' ~ 'Z'</strong></span>로 이루어진
          문자열이 저장된다.</p>

          <p>SQL-92에서 정의된 클래스 코드와 서브 클래스 코드는 모두 '0' ~ '4'와 'A' ~ 'H'로 시작된다.
          이외의 문자로 시작되는 클래스 코드와 서브 클래스 코드는 추가적인 에러 및 경고 코드를 정의하기 위한
          영역이다.</p>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3191"/>7.2.2. 상태 변수 선언<a id="d5e3193" class="indexterm"/></h3></div></div></div>
      

      <p>프로그램 내에서 상태 변수를 사용하기 위해서는 먼저 상태 변수를 선언해야 한다.</p>

      <p>두 가지 상태 변수를 선언하는 방법은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>SQLSTATE<a id="d5e3200" class="indexterm"/></p>

          <p>SQLSTATE는 반드시 <span><strong class="guibutton">크기 6의 char 배열 타입</strong></span>을 가져야 하며,
          <span><strong class="guibutton">DECLARE 영역</strong></span> 안에 <span><strong class="guibutton">대문자</strong></span>로
          선언해야 한다. 다음은 SQLSTATE를 선언하는 예이다.</p>

          <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
char SQLSTATE[6];
...
EXEC SQL END DECLARE SECTION;</pre>
        </li><li>
          <p>SQLCODE<a id="d5e3209" class="indexterm"/></p>

          <p>SQLCODE는 반드시 <span><strong class="guibutton">long 타입</strong></span>을 가져야 하며,
          <span><strong class="guibutton">DECLARE 영역</strong></span> 안에 <span><strong class="guibutton">대문자</strong></span>로
          선언해야 한다. 다음은 SQLCODE를 선언하는 예이다.</p>

          <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
long SQLCODE = 0;
...
EXEC SQL END DECLARE SECTION;</pre>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3216"/>7.2.3. 상태 변수 종류</h3></div></div></div>
      

      <p>상태 변수에는 다음의 두 가지가 있는데, SQL 문장을 실행하는 도중에 발생한 에러 또는 경고를 서로 다른 값으로
      표현한다.</p>

      <p/>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>SQLSTATE<a id="d5e3223" class="indexterm"/></p>

          <p>SQLSTATE가 갖는 에러 또는 경고 코드는 SQL-92 표준에서 정의되어 있고, 추가적인 코드를 정의할 수
          있도록 확장성을 지원하고 있다.</p>

          <p>다음은 SQLSTATE의 클래스 코드를 정리한 것이다. 여기에서는 SQL-92 표준에서 정의된 클래스 코드만을
          나열하였다.</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">클래스 코드</th><th>설명</th></tr></thead><tbody><tr><td align="left">00</td><td>성공적인 완료</td></tr><tr><td align="left">01</td><td>경고</td></tr></tbody></table>
          </div>

          <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
              <p>SQLSTATE가 가질 수 있는 에러 및 경고 코드는 "<span>Tibero</span><span>
              tbCLI</span> 안내서"를
              참고한다.</p>
            </div>
        </li><li>
          <p>SQLCODE<a id="d5e3248" class="indexterm"/></p>

          <p>SQLCODE는 SQL-92에서는 사용하지 않는다. SQLCODE에 저장되는 에러 코드는 정수 값을 가지며,
          0인 경우와 양수인 경우, 음수인 경우로 나눌 수 있다. 각 SQLCODE의 값의 의미는 다음과 같다.</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">SQLCODE의 값</th><th>설명</th></tr></thead><tbody><tr><td align="left">0</td><td>SQLCODE 값이 0인 경우는 에러 없이 SQL 문장을 성공적으로 수행한 경우를
                  나타낸다.</td></tr><tr><td align="left">양수</td><td>SQLCODE 값이 0보다 큰 경우는 SQL 문장의 수행을 마쳤으나 예외 상황이 발생했음을
                  의미한다. 예를 들어 SELECT 문장이 반환한 결과 로우가 하나도 없거나 UPDATE 문장을 실행한 결과
                  갱신된 로우가 하나도 없는 경우를 들 수 있다.</td></tr><tr><td align="left">음수</td><td>SQLCODE 값이 0보다 작은 경우는 에러 상황을 나타낸다. 이 때에는 에러 때문에 SQL
                  문장의 수행을 끝마치지 못했음을 의미한다.</td></tr></tbody></table>
          </div>

          <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
            <p>음수 값을 갖는 SQLCODE 값은 <span>Tibero</span>에서 발생하는 일반적인 에러의 번호이다. 이에 대해서는
            "<span>Tibero</span> 에러 참조 안내서"를 참고한다.</p>

            <p>안내서에 기술된 에러 메시지 번호는 모두 양수이며, SQLCODE 값의 절댓값을 기준으로 찾는다.
            SQLCODE는 <a href="chapter_runtime_error.html#sect-sqlca" title="7.3. SQLCA">“7.3. SQLCA”</a>에서 설명할 SQLCA에 포함되며, WHENEVER
            문장에서 검토하는 값도 SQLCODE 값이다.</p>
          </div>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_ state_variable_example"/>7.2.4. 사용 예제</h3></div></div></div>
      

      <p>다음은 상태 변수를 사용하는 예제 프로그램이다.</p>

      <pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;string.h&gt;
#define USERPASS"<span>tibero</span>/<span>tmax</span>"
int main()
{
    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR userpass[20] = { strlen(USERPASS), USERPASS };
    long SQLCODE = 0;
    VARCHAR ename[24];
    int salary;
    VARCHAR addr[32];
    int empno;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT :userpass;
    printf("Connected.\n");

    printf("Enter the number of employee to show: ");
    scanf("%d", &amp;empno);

    EXEC SQL SELECT ENAME, SALARY, ADDR
        INTO :ename, :salary, :addr
        FROM EMP
        WHERE EMPNO = :empno;
        
    if (<span><strong class="guibutton">SQLCODE == 0</strong></span>) {                                   <em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
        printf("name = %s, salary = %d, addr = %s\n",        
        ename.arr, salary, addr.arr);
    }
    
    if (<span><strong class="guibutton">SQLCODE == 1403</strong></span>) {                               <em class="lineannotation"><span class="lineannotation"> ... ② ...</span></em>
        printf("no employee found.\n");                    
    }
    
    if (<span><strong class="guibutton">SQLCODE &lt; 0</strong></span>) {                                    <em class="lineannotation"><span class="lineannotation">... ③ ...</span></em>
        printf("ERROR: %d\n", sqlca.sqlcode);                
    }
    
    EXEC SQL COMMIT WORK RELEASE;
}</pre>

      <p>상태 변수를 검토하는 코드는 SQL 문장을 실행한 바로 다음에 와야 하며 모든 경우에 대비해야 한다.</p>

      <p>위의 예에서는 SQLCODE의 값에 따라 다음과 같이 처리하는 방법이 다르다.</p>

      <p>① SQLCODE의 값이 0이면 정상적으로 <span>tbESQL</span> 문장을 실행한 경우이다.</p>

      <p>② SQLCODE의 값이 1403이면 결과 로우가 없는 경우이다.</p>

      <p>③ SQLCODE의 값이 0보다 작으면 에러가 발생한 경우이다.</p>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect-sqlca"/>7.3. SQLCA<a id="d5e3294" class="indexterm"/></h2></div></div></div>
    

    <p>SQLCA는 SQL 통신 영역(SQL Communication Area)을 줄여서 부르는 말로, 임의의 SQL 문장이
    실행된 결과가 저장되는 구조체 변수이다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_struct_sqlca"/>7.3.1. SQLCA 구조체 변수<a id="d5e3299" class="indexterm"/></h3></div></div></div>
      

      <p>SQLCA는 헤더 파일 sqlca.h 내부에 <span><strong class="guibutton">sqlca 구조체 변수</strong></span>로 정의되어
      있다. 구조체 변수 sqlca에 포함된 데이터는 바로 전에 실행된 SQL 문장의 정보이다. 따라서 다른 SQL 문장을 실행하면
      이전에 SQL 문장을 실행한 결과는 더는 sqlca에 저장되지 않는다.</p>

      <p>이 변수에 포함되는 정보는 다음과 같다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="150" align="left"/><col/></colgroup><thead><tr><th align="left">포함 정보</th><th>설명</th></tr></thead><tbody><tr><td align="left">에러 코드</td><td><p>에러 코드는 앞 절에서 설명한 SQLCODE와 같은 값을 갖는다.</p><p>이
              값은 WHENEVER 문장에서 참조하는 값이다.</p></td></tr><tr><td align="left">에러 메시지</td><td>에러 메시지는 최대 70bytes의 길이를 갖는다.</td></tr><tr><td align="left"><p>처리된 로우의 개수 및</p><p> 파싱 에러의 위치</p></td><td><p>처리된 로우의 개수는 바로 전에 실행된 SQL 문장에 따라 의미가
              달라진다.</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>SELECT : 질의 결과 반환된 결과 로우의 누적 개수이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>INSERT : 삽입된 로우의 개수이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>UPDATE : 갱신된 로우의 개수이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>DELETE : 삭제된 로우의 개수이다.</p>
                  </li></ul></div><p>파싱 에러의 위치는 SQL 문장을 파싱하는 과정에서 에러가 발생한 경우에
              SQL 문장 내의 에러 위치를 가리킨다.</p></td></tr><tr><td align="left">경고 플래그</td><td><p>경고 플래그는 경고 상황이 발생한 경우에 설정된다.</p><p>경고 상황으로는
              출력 변수에 저장된 컬럼 값이 잘려진 값인 경우, SELECT 또는 FETCH 문장 내의 INTO 절에 포함된 출력
              변수의 개수가 결과 로우의 개수에 비하여 적은 경우 등이 있다.</p></td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 sqlca 구조체 변수가 정의된 내용이다.</p>

      <pre class="programlisting">struct sqlca
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;

    struct 
    {
        unsigned short sqlerrml;
        char sqlerrmc[70];
    } sqlerrm;

    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlext[8];
};</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 sqlca 구조체 변수의 내부에 정의된 각 멤버 변수에 대한 설명이다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">멤버 변수</th><th>설명</th></tr></thead><tbody><tr><td align="left">sqlcaid</td><td>SQLCA라는 것을 나타내기 위한 변수이며, 항상 "SQLCA" 문자열을 갖는다.</td></tr><tr><td align="left">sqlabc</td><td>sqlca 구조체 변수의 Byte 길이가 저장된다.</td></tr><tr><td align="left">sqlcode</td><td>결과가 숫자로 저장된다. 실행이 성공한 경우 0이며, 이외의 경우 적절한 에러 값 등을 갖는다. 자세한
              내용은 <a href="chapter_runtime_error.html#sect_state" title="7.2. 상태 변수">“7.2. 상태 변수”</a>를 참고한다.</td></tr><tr><td align="left">sqlerrm</td><td><p>에러 메시지의 Byte 길이가 저장되는 변수이다.</p><p>실제 메시지는
              sqlerrm.sqlerrmc에 저장되어 있으며, 이 문자열은 마지막 NULL 문자를 포함하지 않으므로 에러
              메시지의 Byte 길이를 가지는 sqlerrm.sqlerrml 변수를 반드시 참조해야
              한다.</p></td></tr><tr><td align="left">sqlerrp</td><td>SQL-99 표준에 있지만, 현재 <span>Tibero</span>에서는 사용하지 않는다.</td></tr><tr><td align="left">sqlerrd</td><td>sqlerrd[2]와 sqlerrd[4]만 사용된다. sqlerrd[2]는 처리된 로우의 개수,
              sqlerrd[4]는 파싱 에러의 위치를 나타낸다.</td></tr><tr><td align="left">sqlwarn</td><td><p>경고 플래그이다. Byte 하나당 하나의 경고 상황이 발생했음을 나타낸다. 문자 'W'를
              저장함으로써 플래그를 설정한다.</p><p>다음은 멤버 변수 sqlwarn에 저장되는 각 경고 플래그의
              의미이다. </p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>sqlwarn[0] : sqlwarn[1], sqlwarn[2], sqlwarn[3] 중
                    하나가 설정되면 동시에 이 플래그도 'W'로 설정된다.</p>
                  </li><li style="list-style-type: circle">
                    <p>sqlwarn[1] : 문자열 출력 변수에 잘린 값이 저장된 경우이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>sqlwarn[2] : SUM, AVG 등의 집단 함수를 계산할 때 NULL 값이 사용되지
                    않는 경우이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>sqlwarn[3] : SELECT 또는 FETCH 문장의 INTO 절에 있는 출력 변수의
                    개수가 컬럼의 개수와 일치하지 않는 경우이다.</p>
                  </li><li style="list-style-type: circle">
                    <p>sqlwarn[4] ~ sqlwarn[7] : SQL-99 표준에 있지만, 현재 <span>Tibero</span>에서는 사용하지 않는다.</p>
                  </li></ul></div></td></tr><tr><td align="left">sqlext</td><td>SQL-99 표준에 있지만, 현재 <span>Tibero</span>에서는 사용하지 않는다.</td></tr></tbody></table>
      </div>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3400"/>7.3.2. 사용 예제</h3></div></div></div>
      

      <p>SQLCA의 변수 sqlca는 전역 변수이며 헤더 파일 sqlca.h 내에 정의되어 있다. 따라서 이 변수를 사용하기
      위해서는 다음의 코드를 <span>tbESQL</span>/C 프로그램 처음에 삽입해 주어야 하며, 따로 변수를 선언할 필요는
      없다.</p>

      <pre class="programlisting">#include &lt;sqlca.h&gt;</pre>

      <div class="literallayout"><p/></div>

      <p>본 예제는 <a href="chapter_runtime_error.html#sect_ state_variable_example" title="7.2.4. 사용 예제">“7.2.4. 사용 예제”</a>에서 제시한 프로그램을
      SQLCA 변수와 출력 배열 변수를 이용하도록 수정한 것이다. 상태 변수 SQLCODE는 구조체 변수 sqlca 내에 포함되어
      있으며, SELECT 실행 결과 로우의 개수와 에러 메시지도 sqlca에서 얻을 수 있다.</p>

      <pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;string.h&gt;
#define USERPASS"<span>tibero</span>/<span>tmax</span>"
int main()
{
    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR userpass[20] = { strlen(USERPASS), USERPASS };
    int sqlcode = 0;
    VARCHAR ename[50][24];
    int salary[50];
    VARCHAR addr[50][32];
    int deptno;
    EXEC SQL END DECLARE SECTION;

    int i, count;

    EXEC SQL CONNECT :userpass;
    printf("Connected.\n");

    printf("Enter the number of department to show: ");
    scanf("%d", &amp;deptno);

    EXEC SQL SELECT ENAME, SALARY, ADDR
        INTO :ename, :salary, :addr
        FROM EMP
        WHERE DEPTNO = :deptno;
    sqlcode = sqlca.sqlcode;

    if (sqlcode == 0) { 
        count = sqlca.sqlerrd[2];
        for (i = 0; i &lt; count; i ++) {
            printf("name = %s, salary = %d, addr = %s\n",
            ename[i].arr, salary[i], addr[i].arr);
        }
    }

    if (sqlcode == +100) { 
        printf("no employee found.\n");
    }

    if (sqlcode &lt; 0) { 
        printf("ERROR: %.*s\n",
        sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
    }

    EXEC SQL COMMIT WORK RELEASE;
    
    return 1;
}</pre>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect-whenever"/>7.4. WHENEVER<a id="d5e3413" class="indexterm"/></h2></div></div></div>
    

    <p>WHENEVER 문장은 다른 <span>tbESQL</span>/C 문장처럼 어떠한 동작을 실행하기 위한 문장이 아니라, 특정 조건이
    발생하면 특정 동작을 수행하라는 선언을 위한 문장이다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3417"/>7.4.1. 구성요소</h3></div></div></div>
      

      <p>WHENEVER 문장은 다음과 같이 조건 부분과 동작 부분으로 구성된다.</p>

      <pre class="programlisting">EXEC SQL WHENEVER {조건} {동작};</pre>

      <div class="literallayout"><p/></div>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>{조건}</p>

          <p>WHENEVER 문장의 조건 부분에 대한 설명은 다음과 같다. <a id="d5e3426" class="indexterm"/><a id="d5e3429" class="indexterm"/><a id="d5e3432" class="indexterm"/><a id="d5e3435" class="indexterm"/><a id="d5e3437" class="indexterm"/><a id="d5e3439" class="indexterm"/></p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">SQLERROR</td><td>SQLCODE가 음수인 경우에 해당된다.</td></tr><tr><td align="left">SQLWARNING</td><td><p>SQLCODE가 0보다 큰 경우 또는 SQLCA 내의 경고 플래그가 설정된 경우이다.
                  SQLCODE가 NOT FOUND 코드 값(+100)에 해당되는 경우는 제외된다.</p><p>경고
                  플래그가 설정된 경우는 sqlca.sqlwarn[0]에 'W' 값이 저장된
                  경우이다.</p></td></tr><tr><td align="left">NOT FOUND</td><td><p>SQLCODE가 NOT FOUND 코드 값인 경우에
                  해당된다.</p><p>질의의 결과 로우가 없거나 커서를 이용해 더 이상 액세스할 결과 로우가
                  없거나 INSERT, UPDATE, DELETE 문장에 의해 처리된 로우가 없을 때 NOT FOUND 경고가
                  발생한다.</p></td></tr></tbody></table>
          </div>

          <p/>
        </li><li>
          <p>{동작}</p>

          <p>WHENEVER 문장의 동작 부분에 대한 설명은 다음과 같다. <a id="d5e3466" class="indexterm"/><a id="d5e3469" class="indexterm"/><a id="d5e3472" class="indexterm"/><a id="d5e3475" class="indexterm"/><a id="d5e3478" class="indexterm"/><a id="d5e3481" class="indexterm"/><a id="d5e3484" class="indexterm"/><a id="d5e3486" class="indexterm"/><a id="d5e3488" class="indexterm"/><a id="d5e3490" class="indexterm"/><a id="d5e3492" class="indexterm"/><a id="d5e3494" class="indexterm"/></p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">항목</th><th>설명</th></tr></thead><tbody><tr><td align="left">CONTINUE</td><td><p>프로그램의 다음 문장부터 계속하여 진행한다.</p><p><span>tbESQL</span>/C 프로그램에서 에러 또는 경고가 발생했을 때
                  디폴트로 CONTINUE를 실행한다. 이는 에러 또는 경고에 대한 처리가 없는 것과
                  마찬가지다.</p></td></tr><tr><td align="left">DO</td><td>특정 함수를 호출한다. 호출된 함수는 대개 에러 처리 함수이며, 함수가 실행되고 나면 에러 또는
                  경고가 발생한 다음 문장부터 실행이 계속된다. 만약 치명적인 에러가 발생했다면 함수 내에서 트랜잭션을
                  롤백시키고 프로그램을 종료할 수도 있다.</td></tr><tr><td align="left">DO BREAK</td><td>루프 내에서 에러 또는 경고가 발생했을 때 BREAK를 실행한다. 만약 루프 내에서 사용되지
                  않았다면 컴파일 에러를 발생시킨다.</td></tr><tr><td align="left">DO CONTINUE</td><td>루프 내에서 에러 또는 경고가 발생했을 때 CONTINUE를 실행한다. 만약 루프 내에서
                  사용되지 않았다면 컴파일 에러를 발생시킨다.</td></tr><tr><td align="left">GOTO</td><td>GOTO를 실행하여 프로그램 내의 특정 위치로 분기한다. 분기할 위치는 레이블로
                  정의한다.</td></tr><tr><td align="left">STOP</td><td>프로그램을 종료하며 현재 트랜잭션을 롤백한다. 에러 메시지의 반환 없이 바로
                  종료된다.</td></tr></tbody></table>
          </div>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 WHENEVER 문장을 사용하는 예이다.</p>

      <pre class="programlisting">EXEC SQL WHENEVER NOT FOUND DO BREAK;</pre>

      <p>위의 예에서 NOT FOUND가 조건, DO BREAK가 동작에 해당된다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3529"/>7.4.2. 사용 예제</h3></div></div></div>
      

      <p>WHENEVER 문장이 선언되면 그 효과는 바로 다음 문장에서부터 시작된다. <span>tbESQL</span>/C 프로그램은 SQL 문장을 실행할 때마다 WHENEVER 문장에
      포함된 조건이 발생하였는지 자동적으로 검토한다. 만약 조건이 발생하면 선언된 동작을 수행한다.</p>

      <p>WHENEVER 문장의 효과는 같은 조건에 대한 다음 WHENEVER 문장이 나타날 때까지 이어진다. WHENEVER
      문장이 나타나더라도 선언된 조건이 다르면 이전의 WHENEVER 문장의 효과는 지속된다. 즉, WHENEVER 문장의 효과는 블록
      구조와는 상관이 없다.</p>

      <div class="literallayout"><p/></div>

      <p>WHENEVER 문장을 사용할 때는 다음과 같은 사항에 유의해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p><span><strong class="guibutton">NOT FOUND</strong></span>가 SELECT, FETCH 문장에 의한 것인지
          INSERT, UPDATE, DELETE 문장에 의한 것인지 구분해야 한다.</p>

          <p>INSERT, UPDATE, DELETE 문장은 SELECT 또는 FETCH 문장과 마찬가지로 처리된 로우가
          하나도 없으면 NOT FOUND를 발생한다. 이때 프로그램 내에서는 NOT FOUND가 SELECT, FETCH 문장에
          의한 것인지 INSERT, UPDATE, DELETE 문장에 의한 것인지 구분해 주어야 한다.</p>

          <p>다음은 INSERT 문장을 잘못 사용하여 의도하던 바와 다르게 실행될 수 있는 경우의 예이다.</p>

          <div class="example"><a id="ex_whenever_insert"/><p class="title"><b>[예 7.1] 잘못된 INSERT 문장</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor INTO ...
    ...
    EXEC SQL INSERT INTO ...
}</pre>

            <p>위의 코드를 작성한 의도는 모든 결과 로우를 액세스하여 더 이상의 결과 로우가 없을 때 FETCH 문장에서
            NOT FOUND를 발생하면 루프를 빠져 나가는 것이다. 하지만 INSERT 문장에서 삽입되는 로우가 없다면 마찬가지로
            NOT FOUND를 발생하고 루프를 빠져나가게 된다. 따라서 모든 결과 로우를 액세스하지 못하게 된다.</p>
          </div></div><br class="example-break"/>

          <p>다음은 <a href="chapter_runtime_error.html#ex_whenever_insert" title="[예 7.1] 잘못된 INSERT 문장">[예 7.1]</a>에서 발생한 문제를 해결한
          예이다.</p>

          <pre class="programlisting">long SQLCODE = 0;
...
while (1)
{
    EXEC SQL FETCH cursor INTO ...
    <span><strong class="guibutton">if (SQLCODE == +100) break;</strong></span>
    ...
    EXEC SQL INSERT INTO ...
    <span><strong class="guibutton">if (SQLCODE == +100)</strong></span> ...
}</pre>

          <p>위의 예에서는 WHENEVER 문장을 사용하지 않고 직접 SQLCODE를 검토하는 코드를
          삽입하였다.</p>
        </li><li>
          <p><span><strong class="guibutton">DO</strong></span> 또는 <span><strong class="guibutton">GOTO</strong></span> 동작을
          선언했을 때 잘못하면 무한 루프에 빠질 수 있다.</p>

          <p>WHENEVER 문장에서 DO 또는 GOTO 동작을 선언했을 때 에러 또는 경고를 처리하기 위한 루틴에서 또다시
          에러 또는 경고가 발생하면 무한 루프에 빠질 수 있다.</p>

          <p>다음은 GOTO 동작을 선언한 경우에 무한 루프가 발생할 수 있는 예이다.</p>

          <div class="example"><a id="ex_whenever_goto"/><p class="title"><b>[예 7.2] GOTO가 선언된 경우의 무한 루프</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL WHENEVER SQLERROR GOTO error_handle;
EXEC SQL SELECT ...
...
error_handle:
EXEC SQL DELETE ...</pre>

            <p>위의 예에서 SELECT 문장을 실행하는 중에 에러가 발생하면 error_handle 레이블로 분기하고,
            DELETE 문장을 실행한다. 이때 DELETE 문장에서 에러가 발생한다면 DELETE 문장은 무한 반복 상태가
            된다.</p>
          </div></div><br class="example-break"/>

          <p>다음은 <a href="chapter_runtime_error.html#ex_whenever_goto" title="[예 7.2] GOTO가 선언된 경우의 무한 루프">[예 7.2]</a>의 무한 루프 문제를 해결한
          예이다.</p>

          <pre class="programlisting">EXEC SQL WHENEVER SQLERROR GOTO error_handle;
EXEC SQL SELECT ...
...
error_handle:
EXEC SQL WHENEVER SQLERROR CONTINUE;
EXEC SQL DELETE ...</pre>

          <p>위의 예에서는 에러 처리 부분의 맨 앞에 WHENEVER 문장을 첨가하여 에러가 발생하더라도 계속 실행하도록
          하여 무한 루프가 발생할 가능성을 없앴다.</p>

          <p>다음과 같이 코드를 작성해도 <a href="chapter_runtime_error.html#ex_whenever_goto" title="[예 7.2] GOTO가 선언된 경우의 무한 루프">[예 7.2]</a>에서 발생하는 문제를
          해결할 수 있다.</p>

          <pre class="programlisting">/* 메인 루틴 */
EXEC SQL WHENEVER SQLERROR DO error_handle(SQLCODE);
...
/* 에러 처리 함수 */
int error_handle(long SQLCODE)
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    ...
    EXEC SQL WHENEVER SQLERROR DO error_handle(SQLCODE);
}</pre>

          <p>위의 예에서는 WHENEVER 문장에 DO 동작을 선언해 함수를 호출하였다. 함수의 맨 처음에 WHENEVER
          문장을 삽입하고 맨 마지막에 에러 처리 함수를 호출하는 WHENEVER 문장을 다시 삽입하였다.</p>
        </li><li>
          <p><span><strong class="guibutton">GOTO</strong></span> 동작을 선언하는 경우 분기할 레이블의 위치를 SQL 문장에서
          액세스할 수 있는 범위에 두어야 한다.</p>

          <p>즉, SQL 문장에서 참조할 수 있는 레이블로 선언해야 한다. WHENEVER 문장이 선언된 <span>tbESQL</span>/C 프로그램을 프리컴파일하면 모든 SQL 문장 뒤에
          SQLCODE를 검토하고 선언된 동작을 수행하는 코드를 삽입한다. 만약 GOTO 동작에서 분기할 레이블이 현재 삽입된
          코드에서 참조할 수 없는 위치에 있다면 컴파일 에러가 발생한다.</p>

          <p>다음은 GOTO 레이블에 의하여 컴파일 에러가 발생하는 예이다.</p>

          <pre class="programlisting">/* 메인 루틴 */
EXEC SQL WHENEVER SQLERROR GOTO error_handle:
...
error_handle:
...
/* 임의의 함수 */
int f()
{
    EXEC SQL SELECT ...
    ...
}</pre>

          <p>위의 예에서 메인 루틴 내에서는 error_handle 레이블을 참조할 수 있지만, 함수
          <code class="function">f</code>에서는 참조할 수 없다. 이러한 문제를 해결하기 위하여 함수
          <code class="function">f</code> 내에 새로운 WHENEVER 문장을 삽입하는 방법도 있다.</p>
        </li></ul></div>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter_dynamic_sql.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_reference.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제6장 Dynamic SQL </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제8장 <span>tbESQL</span>/C 문장</td></tr></table></div><div xmlns="" align="center"/></body></html>