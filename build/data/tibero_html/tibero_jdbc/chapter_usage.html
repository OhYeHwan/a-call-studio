<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제3장 tbJDBC의 사용</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero JDBC 개발자 안내서"/><link rel="up" href="index.html" title="Tibero JDBC 개발자 안내서"/><link rel="prev" href="ch02.html" title="제2장 JDBC 표준 지원"/><link rel="next" href="ch04.html" title="제4장 DataSource 객체와 데이터베이스 URL"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제3장 <span xmlns="http://www.w3.org/1999/xhtml">tbJDBC</span>의 사용</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="ch04.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="chapter_usage"/>제3장 <span>tbJDBC</span>의 사용</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="chapter_usage.html#d5e841">3.1. 개발 과정</a></span></dt><dt><span class="section"><a href="chapter_usage.html#sect_connection_properties">3.2. Connection Properties</a></span></dt><dt><span class="section"><a href="chapter_usage.html#d5e1118">3.3. 데이터 타입</a></span></dt><dt><span class="section"><a href="chapter_usage.html#d5e1305">3.4. <span>tbJDBC</span> Stream</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_usage.html#d5e1378">3.4.1. 컬럼에 대한 Stream 생성</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_usage.html#d5e1389">3.5. 내장 함수 호출</a></span></dt><dd><dl><dt><span class="section"><a href="chapter_usage.html#d5e1394">3.5.1. PSM의 사용</a></span></dt><dt><span class="section"><a href="chapter_usage.html#d5e1411">3.5.2. Java Stored Procedure의 사용</a></span></dt></dl></dd><dt><span class="section"><a href="chapter_usage.html#d5e1420">3.6. 예외 처리</a></span></dt></dl></div>
  

  <p>본 장에서는 <span>tbJDBC</span>를 사용하여 애플리케이션 프로그램을 개발하는 과정을 순서대로 설명하고, 추가로
  데이터 타입, Stream 등을 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e841"/>3.1. 개발 과정</h2></div></div></div>
    

    <p>다음은 <span>tbJDBC</span>를 사용하여 애플리케이션 프로그램을 개발하는 과정이다.<a id="d5e845" class="indexterm"/></p>

    <p/>

    <div class="orderedlist"><ol type="1"><li>
        <p><span><strong class="guibutton">패키지 import</strong></span><a id="d5e852" class="indexterm"/></p>

        <p>기본이 되는 Java 패키지와 <span>tbJDBC</span> 패키지를 import한다.</p>

        <pre class="programlisting">/* 기본 Java 패키지 */
import java.sql.*;

/* <span>tbJDBC</span> 패키지 */
import com.<span>tmax.tibero</span>.jdbc.*;
import com.<span>tmax.tibero</span>.jdbc.ext.*;</pre>
      </li><li>
        <p><span><strong class="guibutton">데이터베이스 연결</strong></span><a id="d5e864" class="indexterm"/></p>

        <p>데이터베이스에 연결하기 위해서 Connection 객체를 생성한다. Connection 객체를 생성하기 위해서
        <span>tbJDBC</span>를 로딩한 후 DriverManager를 이용한다.</p>

        <pre class="programlisting">Class.forName("com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>Driver");
Connection conn = DriverManager.getConnection
                 ("jdbc:<span>tibero</span>:thin:@localhost:8629:dbsvr",
                  "<span>tibero</span>", "<span>tmax</span>");</pre>

        <p>또는 다음과 같이 java.util.Properties를 이용하여 Conneciton할 때 설정 정보를 설정할 수
        있다.</p>

        <pre class="programlisting">Class.forName("com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>Driver");
Properties prop = new Properties();
prop.setProperty("user", "<span>tibero</span>");
prop.setProperty("password", "<span>tmax</span>");
Connection conn = 
    DriverManager.getConnection("jdbc:<span>tibero</span>:thin:@localhost:8629:dbsvr", prop);</pre>

        <p>또는 다음과 같이 DataSource 객체를 이용하여 Connection 객체를 생성한다.</p>

        <pre class="programlisting"><span>Tb</span>DataSource ds = new <span>Tb</span>DataSource();
ds.setURL("jdbc:<span>tibero</span>:thin:@localhost:8629:dbsvr");
ds.setUser("<span>tibero</span>");
ds.setPassword("<span>tmax</span>");
Connection conn = ds.getConnection();</pre>
      </li><li>
        <p><span><strong class="guibutton">Statement 객체 생성</strong></span><a id="d5e892" class="indexterm"/></p>

        <p>데이터베이스에 연결되면, Connection 객체를 이용하여 Statement 객체를 생성한다.</p>

        <pre class="programlisting">Statement         stmt  = conn.createStatement();
PreparedStatement pstmt = conn.prepareStatement("SELECT empno, name FROM emp");
CallableStatement cstmt = conn.prepareCall("BEGIN ... END;");</pre>
      </li><li>
        <p><span><strong class="guibutton">질의문 수행과 ResultSet 객체 받기</strong></span><a id="d5e900" class="indexterm"/></p>

        <p>질의문을 수행하고 ResultSet 객체를 받는다.</p>

        <pre class="programlisting">ResultSet rs = stmt.executeQuery("SELECT * FROM ALL_OBJECTS;");</pre>
      </li><li>
        <p><span><strong class="guibutton">ResultSet 객체 처리</strong></span><a id="d5e908" class="indexterm"/></p>

        <p>ResultSet 객체는 next() 메소드를 이용하여 모든 로우에 접근할 수 있다. 이때 getXXX() 메소드를
        호출하면 원하는 타입별로 로우 데이터를 가져올 수 있다. 만약 next() 메소드가 false라면, 더는 결과 집합이 존재하지
        않음을 의미한다.</p>

        <pre class="programlisting">while (rs.next())
{
    System.out.println(rs.getString(1));
    System.out.println(rs.getInt(2));
}</pre>
      </li><li>
        <p><span><strong class="guibutton">커밋 또는 롤백 수행</strong></span><a id="d5e916" class="indexterm"/></p>

        <p>기본적으로 DML 문(INSERT, UPDATE, DELETE)을 수행한 다음에는 자동으로 커밋된다. 이러한 기능을
        auto-commit이라고 한다. 사용자는 Connection 클래스에서 제공하는 다음의 메소드를 이용하여 이 기능을 임의로
        해제할 수 있다.</p>

        <pre class="programlisting">void setAutoCommit(boolean flag)</pre>

        <p>이 메소드를 이용하여 auto-commit 기능을 비활성화하면, 사용자는 반드시 DML 문을 사용한 다음 커밋이나
        롤백을 수행해야 데이터베이스에 적용된다.</p>

        <pre class="programlisting">conn.commit();
conn.rollback();</pre>
      </li><li>
        <p><span><strong class="guibutton">ResultSet 객체와 Statement 객체 소멸</strong></span><a id="d5e926" class="indexterm"/></p>

        <p>ResultSet 객체와 Statement 객체는 반드시 소멸시켜야 한다. 왜냐하면, <span>tbJDBC</span> 내부에는 별도의 finalizer 메소드가 없기 때문이다. 이
        때문에 예상치 못한 시점에 심각한 메모리 누수 현상이 발생할 수 있고, 데이터베이스 내부 커서의 최대 허용 범위를 초과하여
        에러가 발생할 수도 있다.</p>

        <pre class="programlisting">rs.close();
stmt.close();</pre>

        <p/>
      </li><li>
        <p><span><strong class="guibutton">데이터베이스 연결 해제</strong></span><a id="d5e936" class="indexterm"/></p>

        <p>마지막으로 모든 작업이 끝나면 반드시 데이터베이스 연결을 해제해야 한다. 그렇지 않으면 현재 세션이 연결된 상태로
        남아 있기 때문에 다음 연결할 때에는 최대 허용 세션을 초과할 수 있다. 따라서 데이터베이스 연결에 실패할 수도
        있다.</p>

        <pre class="programlisting">conn.close();</pre>
      </li></ol></div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_connection_properties"/>3.2. Connection Properties<a id="d5e943" class="indexterm"/></h2></div></div></div>
    

    <p>다음은 DB를 연결할 때에 Properties로 설정할 수 있는 속성들이다.</p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="120" align="left"/><col width="60" align="left"/><col/></colgroup><thead><tr><th align="left">속성명</th><th align="left">타입</th><th>설명</th></tr></thead><tbody><tr><td align="left">databaseName<a id="d5e958" class="indexterm"/></td><td align="left">String</td><td>서버에 존재하는 특정 데이터베이스의 이름이다.</td></tr><tr><td align="left">dataSourceName<a id="d5e965" class="indexterm"/></td><td align="left">String</td><td>데이터소스의 이름이다.</td></tr><tr><td align="left">description<a id="d5e972" class="indexterm"/></td><td align="left">String</td><td>데이터소스에 대한 설명이다.</td></tr><tr><td align="left">networkProtocol<a id="d5e979" class="indexterm"/></td><td align="left">String</td><td>서버와 통신하는 네트워크 프로토콜의 이름이다. (기본값: TCP)</td></tr><tr><td align="left">password<a id="d5e986" class="indexterm"/></td><td align="left">String</td><td>서버 접속을 위한 패스워드이다.</td></tr><tr><td align="left">user<a id="d5e993" class="indexterm"/></td><td align="left">String</td><td>서버 접속을 위한 사용자 이름이다.</td></tr><tr><td align="left">portNumber<a id="d5e1000" class="indexterm"/></td><td align="left">int</td><td>서버 리스너의 포트 번호이다.</td></tr><tr><td align="left">serverName<a id="d5e1007" class="indexterm"/></td><td align="left">String</td><td>데이터베이스의 이름이다.</td></tr><tr><td align="left">login_timeout<a id="d5e1014" class="indexterm"/></td><td align="left">int</td><td><p>소켓의 read timeout을 지정한다. </p><p>최소 소켓을 생성할 때부터
            DB 연결 생성이 완료될 때까지 적용된다. DB 연결 생성이 완료된 뒤에는 read_timeout 속성이 적용된다.
            만약 응답이 없이 지정된 시간이 지나면 timeout을 발생시키지만 설정값이 0일 경우에는 timeout을 발생시키지
            않는다. (단위: millisecond, 기본값: 0)</p></td></tr><tr><td align="left">read_timeout<a id="d5e1023" class="indexterm"/></td><td align="left">int</td><td><p>DB 연결 생성이 완료된 이후의 소켓의 read timeout을 지정한다.
            </p><p>만약 응답이 없이 지정된 시간이 지나면 timeout을 발생시키지만 설정값이 0일 경우에는
            timeout을 발생시키지 않는다. </p><p>(단위: millisecond, 기본값:
            0)</p></td></tr><tr><td align="left">characterset<a id="d5e1033" class="indexterm"/></td><td align="left">String</td><td><p>JDBC에서 인코딩, 디코딩 Character Set을 지정한다.</p><p>
            (기본값: 서버의 문자 셋을 사용)</p></td></tr><tr><td align="left">program_name<a id="d5e1042" class="indexterm"/></td><td align="left">String</td><td>프로그램 이름이다. (기본값: JDBC Thin Client)</td></tr><tr><td align="left">includeSynonyms<a id="d5e1049" class="indexterm"/></td><td align="left">String</td><td>DatabaseMetaData.getColumn()에서 synonyms 객체를 포함할지 여부를 지정한다.
            (기본값: false)</td></tr><tr><td align="left">mapDateToTimestamp<a id="d5e1056" class="indexterm"/></td><td align="left">String</td><td>DATE 컬럼에 대해서 결과 타입으로 Timestamp(true)로 돌려줄지 Date(false)로 여부를
            지정한다. (기본값: true)</td></tr><tr><td align="left">defaultNChar<a id="d5e1063" class="indexterm"/></td><td align="left">String</td><td>PreparedStatement.setString() API로 설정한 문자열을 national
            charset 설정을 이용하여 서버로 전송하도록 강제한다. (기본값: false)</td></tr><tr><td align="left">self_keepalive<a id="d5e1070" class="indexterm"/></td><td align="left">String</td><td><p>SELF KEEP ALIVE 기능을 활성화할지 여부를 지정한다. </p><p>활성화한
            경우에는 self_keepidle, self_keepintvl, self_keepcnt 속성 설정에 따라 연결 대상에
            대한 네트워크 접근에 문제가 없는지 확인한다. 전체 확인 과정에 실패하면, 해당 네트워크 연결을 강제로 종료시킨다.
            </p><p>(기본값: false)</p></td></tr><tr><td align="left">self_keepidle<a id="d5e1080" class="indexterm"/></td><td align="left">int</td><td><p>접속 완료, DB 요청/응답 처리 등의 정상적인 네트워크 사용 이후, 다음 번의 정상 처리된
            시간이 갱신되지 않을 때, 정상 상황으로 간주할 최대 시간을 지정한다. 지정된 시간이 지나면 네트워크 접근에 대한 확인
            절차가 시작된다. <span><strong class="guibutton">self_keepalive 설정이 true인 경우에만
            유효하다.</strong></span></p><p>(단위: 초, 기본값: 60)</p></td></tr><tr><td align="left">self_keepintvl<a id="d5e1090" class="indexterm"/></td><td align="left">int</td><td><p>매 번 확인할 때의 간격 및 한 번 확인할 때 최대 대기 시간을 지정한다.
            <span><strong class="guibutton">self_keepalive 설정이 true인 경우에만
            유효하다.</strong></span></p><p>(단위: 초, 기본값: 10)</p></td></tr><tr><td align="left">self_keepcnt<a id="d5e1100" class="indexterm"/></td><td align="left">int</td><td>확인 절차를 총 몇 회까지 수행할 것인지를 지정한다. 지정된 횟수만큼 연속으로 실패하여야만 전체 확인과정이
            실패한 것으로 처리된다. <span><strong class="guibutton">self_keepalive 설정이 true인 경우에만 유효하다.
            </strong></span>(기본값: 3)</td></tr><tr><td align="left">failover_retry_count<a id="d5e1108" class="indexterm"/></td><td align="left">int</td><td><p>Failover 기능이 활성화되었을 때 연결 복원을 시도하는 최대 횟수를 지정한다. (기본값:
            3)</p><p>Failover 기능에 대한 자세한 설명은 <a href="chapter_failover.html" title="제9장 Failover와 Load balancing">“제9장 Failover와 Load balancing”</a>의 내용을 참고한다.</p></td></tr></tbody></table>
    </div>

    <p/>

    <p/>

    
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1118"/>3.3. 데이터 타입</h2></div></div></div>
    

    <p><span>tbJDBC</span>는 JDBC 타입을 지원할 뿐만 아니라 Interval 타입을 추가로
    제공한다.</p>

    <p>다음은 JDBC 타입과 <span>tbJDBC</span> 타입과의 대응 관계를 나타내는 표이다.<a id="d5e1124" class="indexterm"/></p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="200" align="left"/><col width="180" align="left"/><col/></colgroup><thead><tr><th align="left">JDBC 타입(표준)</th><th align="left">Java 타입(표준)</th><th><span>tbJDBC</span> 타입</th></tr></thead><tbody><tr><td align="left">java.sql.Types.CHAR</td><td align="left">java.lang.String</td><td>java.lang.String</td></tr><tr><td align="left">java.sql.Types.VARCHAR</td><td align="left">java.lang.String</td><td>java.lang.String</td></tr><tr><td align="left">java.sql.Types.LONGVARCHAR</td><td align="left">java.lang.String</td><td>java.lang.String</td></tr><tr><td align="left">java.sql.Types.NUMERIC</td><td align="left">java.math.BigDecimal</td><td>java.math.BigDecimal</td></tr><tr><td align="left">java.sql.Types.DECIMAL</td><td align="left">java.math.BigDecimal</td><td>java.math.BigDecimal</td></tr><tr><td align="left">java.sql.Types.BIT</td><td align="left">boolean</td><td>boolean</td></tr><tr><td align="left">java.sql.Types.TINYINT</td><td align="left">byte</td><td>byte</td></tr><tr><td align="left">java.sql.Types.SMALLINT</td><td align="left">short</td><td>short</td></tr><tr><td align="left">java.sql.Types.INTEGER</td><td align="left">int</td><td>int</td></tr><tr><td align="left">java.sql.Types.BIGINT</td><td align="left">long</td><td>long</td></tr><tr><td align="left">java.sql.Types.REAL</td><td align="left">float</td><td>float</td></tr><tr><td align="left">java.sql.Types.FLOAT</td><td align="left">double</td><td>double</td></tr><tr><td align="left">java.sql.Types.DOUBLE</td><td align="left">double</td><td>double</td></tr><tr><td align="left">java.sql.Types.BINARY</td><td align="left">byte[]</td><td>byte[]</td></tr><tr><td align="left">java.sql.Types.VARBINARY</td><td align="left">byte[]</td><td>byte[]</td></tr><tr><td align="left">java.sql.Types.LONGVARBINARY</td><td align="left">byte[]</td><td>byte[]</td></tr><tr><td align="left">java.sql.Types.DATE</td><td align="left">java.sql.Date</td><td>java.sql.Date</td></tr><tr><td align="left">java.sql.Types.TIME</td><td align="left">java.sql.Time</td><td>java.sql.Time</td></tr><tr><td align="left">java.sql.Types.TIMESTAMP</td><td align="left">java.sql.Timestamp</td><td>java.sql.Timestamp</td></tr><tr><td align="left">java.sql.Types.BLOB</td><td align="left">java.sql.Blob</td><td>com.<span>tmax.tibero</span>.jdbc.<span>TbBlob</span></td></tr><tr><td align="left">java.sql.Types.CLOB</td><td align="left">java.sql.Clob</td><td>com.<span>tmax.tibero</span>.jdbc.<span>TbClob</span></td></tr><tr><td align="left">java.sql.Types.NCLOB</td><td align="left">java.sql.NClob</td><td>com.<span>tmax.tibero</span>.jdbc.<span>TbNClob</span></td></tr><tr><td align="left">java.sql.Types.NCHAR</td><td align="left">java.sql.NCHAR</td><td>java.lang.String</td></tr><tr><td align="left">java.sql.Types.NVARCHAR</td><td align="left">java.sql.NVARCHAR</td><td>java.lang.String</td></tr><tr><td align="left">java.sql.Types.SQLXML</td><td align="left">java.sql.SQLXML</td><td>com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>SQLXML</td></tr><tr><td align="left">com.<span>tmax.tibero</span>.jdbc.data.DataType.VARRAY</td><td align="left">java.sql.Array</td><td>com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>Array</td></tr><tr><td align="left">com.<span>tmax.tibero</span>.jdbc.data.DataType.Struct</td><td align="left">java.sql.Struct</td><td>com.<span>tmax.tibero</span>.jdbc.TbUpStruct</td></tr><tr><td align="left">com.<span>tmax.tibero</span>.jdbc.data.DataType.CURSOR</td><td align="left">-</td><td>com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>ResultSet</td></tr><tr><td align="left">com.<span>tmax.tibero</span>.jdbc.data.DataType.ITV_DTS</td><td align="left">-</td><td>com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>IntervalDts</td></tr><tr><td align="left">com.<span>tmax.tibero</span>.jdbc.data.DataType.ITV_YTM</td><td align="left">-</td><td>com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>IntervalYtm</td></tr><tr><td align="left">com.<span>tmax.tibero</span>.jdbc.data.DataType.RowId</td><td align="left">-</td><td>com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>RowId</td></tr><tr><td align="left">com.<span>tmax.tibero</span>.jdbc.data.DataType.TIMESTAMP_TZ</td><td align="left">java.sql.Timestamp</td><td>com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>TimestampTZ</td></tr><tr><td align="left">com.<span>tmax.tibero</span>.jdbc.data.DataType.TIMESTAMP_LTZ</td><td align="left">java.sql.Timestamp</td><td>java.sql.Timestamp</td></tr></tbody></table>
    </div>

    <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p><span>Tibero</span>에서 TIME 데이터 타입을 지원하지만 DATE 데이터 타입을 사용하기를
        권장한다.</p>

        <p>TIME 컬럼에 대해서 PreparedStatement.setTime() 메소드로 지정할 수 없다.
        PreapredStatement.setTime()은 DATE 데이터 타입의 컬럼에 대해서 지원하고 있다. TIME 컬럼에 대한
        값을 지정하기 위해서는 문자열을 TIME 값으로 변환하는 TO_TIME 함수를 통해서 입력할 수 있다.</p>
      </div>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1305"/>3.4. <span>tbJDBC</span> Stream</h2></div></div></div>
    

    <p><span>tbJDBC</span>에서는 특정 데이터 타입에 대해 다음과 같은 Stream 기능을
    제공한다.<a id="d5e1310" class="indexterm"/></p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>컬럼에 대한 Stream 생성</p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>CHAR, VARCHAR, RAW, NCHAR, NVARCHAR</p>
          </li><li>
            <p>LONG, LONG RAW</p>
          </li><li>
            <p>LOB</p>
          </li></ul></div>
      </li><li>
        <p>Stream 소멸</p>
      </li></ul></div>

    <div class="literallayout"><p/></div>

    <p><span>tbJDBC</span>에서는 다음과 같이 4종류의 Stream 메소드를
    제공한다.<a id="d5e1328" class="indexterm"/></p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="150" align="left"/><col width="130" align="left"/><col/></colgroup><thead><tr><th align="left">메소드</th><th align="left">반환 값</th><th>설명</th></tr></thead><tbody><tr><td align="left">getAsciiStream<a id="d5e1342" class="indexterm"/><a id="d5e1345" class="indexterm"/></td><td align="left">Java.io.InputStream</td><td>ASCII 형태로 변환된 데이터 Stream이다.</td></tr><tr><td align="left">getBinaryStream<a id="d5e1351" class="indexterm"/><a id="d5e1354" class="indexterm"/></td><td align="left">Java.io.InputStream</td><td>byte 형태로 변환된 데이터 Stream이다.</td></tr><tr><td align="left">getUnicodeStream<a id="d5e1360" class="indexterm"/><a id="d5e1363" class="indexterm"/></td><td align="left">Java.io.InputStream</td><td>Unicode 형태로 변환된 데이터 Stream이다. 이 메소드는 JDBC 4.0에서
            폐기(deprecated)되었으므로 호환성을 고려하여 가급적 사용하지 않는 것이 좋다.</td></tr><tr><td align="left">getCharacterStream<a id="d5e1369" class="indexterm"/><a id="d5e1372" class="indexterm"/></td><td align="left">Java.io.Reader</td><td>문자열 형태로 변환된 데이터 Reader이다.</td></tr></tbody></table>
    </div>

    <p>각각의 메소드를 이용하면 해당 데이터 타입에서 허용하는 최대 크기까지 점진적으로 데이터를 읽을 수 있다. 메소드에서
    반환되는 객체는 InputStream과 Reader이고, read() 메소드를 사용하면 데이터를 읽을 수 있다.</p>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1378"/>3.4.1. 컬럼에 대한 Stream 생성</h3></div></div></div>
      

      <p>CHAR, VARCHAR, RAW 컬럼에 Stream 메소드를 사용하는 경우 전체 데이터를 한꺼번에 받아와서
      Stream 객체로 생성한다. 반면, LONG이나 LONG RAW, LOB 컬럼에 대해서는 최초 일부의 데이터만 읽어온 후
      Stream 객체를 생성한다. 단, 사용자가 추가로 요청하면 차례대로 데이터를 더 읽어온 후 Stream 객체를 생성하게
      된다.</p>

      <p>다음은 getBinaryStream()을 이용하여 데이터를 읽어오는 예이다.</p>

      <pre class="programlisting">ResultSet rs = stmt.executeQuery("SELECT name, image FROM backgrounds");

while (rs.next()) {
    InputStream imageIS = rs.getBinaryStream(2);
    try {
        FileOutputStream fos = new FileOutputStream(rs.getString(1));
        int chunk = 0;
        while ((chunk = imageIS.read()) != -1)
            fos.write(chunk);
    }
    catch (Exception e) {
        e.printStackTrace();
    }
    finally {
        if (fos != null)
            fos.close();
    }
}</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 getBinaryStram() 대신 getBytes()를 이용하여 데이터를 읽어오는 예이다.
      <span><strong class="guibutton">getBytes()</strong></span>는 해당 컬럼에 저장된 모든 데이터를 한꺼번에 받아오기 때문에 그
      크기만큼 메모리를 차지한다는 점을 주의해야 한다.<a id="d5e1386" class="indexterm"/></p>

      <pre class="programlisting">ResultSet rs = stmt.executeQuery("SELECT name, image FROM backgrounds");

while (rs.next()) {
    bytes[] images = rs.getBytes(2);
    try {
        FileOutputStream fos = new FileOutputStream(rs.getString(1));
        fos.write(images);
    }
    catch (Exception e) {
        e.printStackTrace();
    }
    finally {
        if (fos != null)
            fos.close();
    }
}</pre>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1389"/>3.5. 내장 함수 호출<a id="d5e1391" class="indexterm"/></h2></div></div></div>
    

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1394"/>3.5.1. PSM의 사용<a id="d5e1396" class="indexterm"/></h3></div></div></div>
      

      <p><span>tbJDBC</span>에서는 PSM을 사용할 수 있다.</p>

      <p>다음과 같이 SQL-92의 ESCAPE 문법과 PSM 문법을 제공한다.</p>

      <pre class="programlisting">// SQL92 ESCAPE 문법
CallableStatement cstmt = conn.prepareCall("{call proc(?)}");
CallableStatement cstmt = conn.prepareCall("{? = call func(?)}");

// PSM 문법
CallableStatement cstmt = conn.prepareCall("begin proc(?); end;");
CallableStatement cstmt = conn.prepareCall("begin ? := func(?); end;");</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 PSM 문법을 사용하여 내장 함수를 호출하는 예이다.</p>

      <pre class="programlisting"><span><strong class="guibutton">create or replace function concat(x varchar2, y varchar2)</strong></span>
return varchar2 is
begin
    return x || y;
end;</pre>

      <pre class="programlisting"><span><strong class="guibutton">CallableStatement cstmt = conn.prepareCall("begin ? := concat(?, ?); end;");</strong></span>

cstmt.regiterOutParameter(1, Types.VARCHAR);
cstmt.setString(2, "<span>Tmax</span>");
cstmt.setString(3, "<span>Tibero</span>");
cstmt.executeUpdate();

String result = cstmt.getString(1);</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1411"/>3.5.2. Java Stored Procedure의 사용<a id="d5e1413" class="indexterm"/></h3></div></div></div>
      

      <p>이전 절에서 설명한 방법과 같이 Java Stored Procedure를 사용할 수 있다.</p>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>Java Stored Procedure에 대한 자세한 내용은 "<span>Tibero</span> External Procedure 안내서"를 참고한다.</p>
      </div>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1420"/>3.6. 예외 처리<a id="d5e1422" class="indexterm"/></h2></div></div></div>
    

    <p><span>tbJDBC</span>에서는 예외 상황을 처리하기 위해 java.sql.SQLException
    클래스 객체를 정의할 수 있다. 예외 상황은 <span>tbJDBC</span> 내부에서 발생할 수도 있고, 데이터베이스 내부에서 발생할 수도 있다.
    예외 상황의 내용은 에러 코드와 에러가 발생한 위치 등의 정보가 포함되어 있다.</p>

    <p>예외 상황에 대한 정보를 얻기 위해 다음과 같은 메소드가 제공된다.</p>

    <div class="informaltable">
      <table border="1"><colgroup><col width="160" align="left"/><col/></colgroup><thead><tr><th align="left">메소드</th><th>설명</th></tr></thead><tbody><tr><td align="left">getMessage()<a id="d5e1439" class="indexterm"/></td><td>에러가 발생한 원인이다.</td></tr><tr><td align="left">getSQLState()<a id="d5e1445" class="indexterm"/></td><td>SQL 상태 정보이다.</td></tr><tr><td align="left">getErrorCode()<a id="d5e1451" class="indexterm"/></td><td>에러 코드이다.</td></tr><tr><td align="left">printStackTrace()<a id="d5e1457" class="indexterm"/></td><td>에러가 발생한 스택의 트레이스 정보(Stack trace)이다.</td></tr></tbody></table>
    </div>

    <div class="literallayout"><p/></div>

    <p>다음은 위의 메소드를 사용하여 예외 상황을 처리하는 예이다.</p>

    <pre class="programlisting">try {
    stmt.execute("drop table not_exist_table");
}
catch (SQLException e) {
    System.out.println("ERROR[" + e.getErrorCode() + "]" + e.getMessage());
    e.printStackTrace();
}</pre>

    <p>실행하면 다음과 같은 정보가 화면에 출력된다.</p>

    <pre class="programlisting">ERROR[-7071] Schema object'NOT_EXIST_TABLE' was not found or is invalid.
java.sql.SQLException: Schema object 'NOT_EXIST_TABLE' was not found or is invalid.
   at com.<span>tmax.tibero</span>.jdbc.msg.common.<span>Tb</span>MsgError.readErrorStackInfo(<span>Tb</span>MsgError.java
:108)
   at com.<span>tmax.tibero</span>.jdbc.msg.<span>Tb</span>MsgEreply.deserialize(<span>Tb</span>MsgEreply.java:61)
   at com.<span>tmax.tibero</span>.jdbc.comm.<span>Tb</span>Stream.readMsgBody(<span>Tb</span>Stream.java:327)
   at com.<span>tmax.tibero</span>.jdbc.comm.<span>Tb</span>CommType4.executeDirect(<span>Tb</span>CommType4.java:460)
   at com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>Statement.executeInternal(<span>Tb</span>Statement.java:1051)
   at com.<span>tmax.tibero</span>.jdbc.<span>Tb</span>Statement.execute(<span>Tb</span>Statement.java:560)
   at TestSimple.main(TestSimple.java:102)</pre>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch04.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제2장 JDBC 표준 지원 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제4장 DataSource 객체와 데이터베이스 URL</td></tr></table></div><div xmlns="" align="center"/></body></html>