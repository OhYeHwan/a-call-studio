<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제10장 오브젝트 타입</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbPSM 안내서"/><link rel="up" href="index.html" title="Tibero tbPSM 안내서"/><link rel="prev" href="ch09.html" title="제9장 파이프라인드 테이블 함수"/><link rel="next" href="ch11.html" title="제11장 사용자 정의 AGGREGATION 함수"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제10장 오브젝트 타입</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch09.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="ch11.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="d5e4574"/>제10장 오브젝트 타입</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="ch10.html#d5e4578">10.1. 개요</a></span></dt><dt><span class="section"><a href="ch10.html#sect_psm_object_constructor">10.2. 생성자</a></span></dt><dd><dl><dt><span class="section"><a href="ch10.html#sect_psm_object_default_constructor">10.2.1. 디폴트 생성자</a></span></dt><dt><span class="section"><a href="ch10.html#sect_psm_object_user_defined_constructor">10.2.2. 사용자 정의 생성자</a></span></dt></dl></dd><dt><span class="section"><a href="ch10.html#sect_psm_object_attribute">10.3. Attribute</a></span></dt><dt><span class="section"><a href="ch10.html#sect_psm_object_method">10.4. 메소드</a></span></dt><dd><dl><dt><span class="section"><a href="ch10.html#sect_psm_object_method_constructor">10.4.1. 생성자 메소드</a></span></dt><dt><span class="section"><a href="ch10.html#sect_psm_object_method_static">10.4.2. 정적 메소드</a></span></dt><dt><span class="section"><a href="ch10.html#sect_psm_object_method_order">10.4.3. ORDER 메소드</a></span></dt><dt><span class="section"><a href="ch10.html#sect_psm_object_method_map">10.4.4. MAP 메소드</a></span></dt><dt><span class="section"><a href="ch10.html#sect_psm_object_method_member">10.4.5. 멤버 메소드</a></span></dt></dl></dd><dt><span class="section"><a href="ch10.html#sect_psm_object_static_view">10.5. 오브젝트 관련 정적 뷰</a></span></dt></dl></div>
  

  <p>본 장에서는 추상 데이터 타입인 오브젝트 타입에 대해서 설명한다.</p>

  <p/>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e4578"/>10.1. 개요</h2></div></div></div>
    

    <p><span><strong class="guibutton">오브젝트 타입(Object Type)</strong></span>은 데이터 타입의 데이터 구성 요소와 서브
    프로그램을 캡슐화(Encapsulation)한 추상 데이터 타입(Abstract Data Type)이다.<a id="d5e4582" class="indexterm"/></p>

    <p>데이터 구성요소는 Attribute라고 부르며, 서브 프로그램은 메소드(Method)라고 부른다. 사용자는 추상 데이터
    타입을 이용하여 애플리케이션에 관련된 데이터와 서브 프로그램을 한 곳으로 모을 수 있어 애플리케이션 작성이 쉬워지고 가독성이
    높아진다.</p>

    <p><span>tbPSM</span>의 오브젝트 타입이 클래스나 패키지와의 다른점은 다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>클래스와 다른 점은 상속성과 다형성이 제외된 순수한 추상 데이터 타입이라는 것이다. (상속성과 다형성은 추후 추가
        예정)</p>
      </li><li>
        <p>패키지와 다른 점은 타입 실체화이다.</p>

        <div class="itemizedlist"><ul type="circle" compact="compact"><li>
            <p>오브젝트 타입의 변수는 컬렉션 타입 변수처럼 각각 다른 메모리 공간을 사용한다.</p>
          </li><li>
            <p>패키지 자체가 세션마다 유일한 데이터 셋를 가지는 반면 오브젝트 타입 자체로는 데이터 셋를 가지지 않으며
            오브젝트 타입 실체화를 통해 각각의 인스턴스마다 데이터 셋를 가진다.</p>
          </li><li>
            <p>오브젝트 타입의 실체화 방법은 컬렉션 타입과 동일하게 생성자를 호출하는 것이며, 생성자가 삭제되는 것은
            변수의 생명 주기와 같다.</p>
          </li><li>
            <p>변수의 Block Scope가 끝났을 경우 오브젝트 인스턴스에 대한 메모리가 해제된다. 단, 패키지 멤버
            변수인 경우에는 패키지 인스턴스가 무효화 되는 경우에 삭제된다.</p>
          </li></ul></div>
      </li></ul></div>

    <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
      <p><span>tbPSM</span>의 오브젝트 타입은 <span>tbPSM</span> 내에서 사용되는 기능만 구현되었으므로 SQL이나 테이블을 생성하는
      곳에서는 사용이 불가능하다. (기능 추가 예정)</p>
    </div>

    <div class="literallayout"><p/></div>

    <p>다음은 오브젝트 타입을 이용한 Number Stack의 구현 예로 Stack의 데이터 배열과 Top 포인터, 그리고
    푸쉬(Push), 팝(Pop), 탑(Top) 동작을 한 곳으로 모은 것을 확인할 수 있다.</p>

    <pre class="programlisting">DROP TYPE number_array FORCE;

-- Stack 내부에서 사용하는 데이터를 위한 최대 크기의 한계가 없는 배열 데이터 타입 
CREATE OR REPLACE TYPE number_array AS TABLE OF NUMBER;
/
show err 

DROP TYPE type_nstack force;

-- number stack의 추상 데이터 타입 
CREATE OR REPLACE TYPE type_nstack AS OBJECT(
    maxlen pls_integer,  -- Stack의 최대 크기
    topptr pls_integer,  -- Stack의 TOP
    array  number_array, -- Stack 내부 데이터

    MEMBER PROCEDURE pop (self in out nocopy type_nstack),
    MEMBER FUNCTION top (self in out nocopy type_nstack) return NUMBER,
    MEMBER PROCEDURE push (self in out nocopy type_nstack, input NUMBER),
    CONSTRUCTOR FUNCTION type_nstack(maxlen pls_integer) RETURN SELF AS RESULT
);
/
show err

CREATE OR REPLACE TYPE BODY type_nstack
AS
    MEMBER PROCEDURE pop (self in out nocopy type_nstack)
    AS
    BEGIN
        IF topptr &lt;= 0 THEN
            raise_application_error(-20000, 'stack is empty', true);
        ELSE
            array(topptr) := NULL;
            topptr := topptr - 1;
        END IF;
    END;

    MEMBER FUNCTION top (self in out nocopy type_nstack) return NUMBER
    AS
    BEGIN
        IF topptr &lt;= 0 THEN
            return NULL;
        ELSE
            return array(topptr);
        END IF;
        return NULL;
    END;

    MEMBER PROCEDURE push (self in out nocopy type_nstack, input NUMBER)
    AS
    BEGIN
        IF topptr = maxlen THEN
            raise_application_error(-20001, 'stack is full', true);
        ELSE
            array(self.topptr + 1) := input;
            topptr := topptr + 1;
        END IF;
    END;

    CONSTRUCTOR FUNCTION type_nstack(maxlen pls_integer) RETURN SELF AS RESULT
    AS
    BEGIN
        array := number_array();
        array.extend(maxlen);
        topptr := 0;
        RETURN;
    END;
END; 
/
show err

set serveroutput on
-- 간단한, Stack Push/Pop 동작 테스트 애플리케이션 
declare
    s1 type_nstack;
begin
  
    s1 := type_nstack(4); -- 최대 크기 4짜리 Stack의 생성     
    s1.push(10);    -- 10을 Push     
    s1.push(20);    -- 20을 Push 
    s1.push(30);    -- 30을 Push 
    s1.push(40);    -- 40을 Push 

    dbms_output.put_line (s1.top);     -- Stack의 Top을 조회  
    s1.pop;    -- stack pop

    dbms_output.put_line (s1.top);    -- Stack의 Top을 조회  
    dbms_output.put_line (s1.top);    -- Stack의 Top을 조회  

    s1.pop;    -- stack pop
    dbms_output.put_line (s1.top);    -- Stack의 Top을 조회  

    s1.pop;    -- stack pop
    s1.pop;    -- stack pop
    s1.pop;    -- stack pop : Stack이 비어 있으므로 에러 
end;
/</pre>

    <p/>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_psm_object_constructor"/>10.2. 생성자<a id="d5e4612" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">생성자</strong></span>는 디폴트 생성자와 사용자 정의 생성자가 있다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_psm_object_default_constructor"/>10.2.1. 디폴트 생성자<a id="d5e4618" class="indexterm"/></h3></div></div></div>
      

      <p>사용자 정의 생성자가 없는 경우 디폴트 생성자가 호출되며, 디폴트 생성자의 함수 시그네쳐는 Attribute의 순서와
      동일하다. 호출자가 argument로 다른 타입을 가지고 생성자를 호출하는 경우 <span>tbPSM</span> implicit type conversion rule을 따른다. 만약
      오브젝트 변수가 NULL일 경우 생성자 함수 호출 중에 Exception이 발생한다(오브젝트 인스턴스가 NULL일 경우
      Attribute는 항상 NULL이다).</p>

      <div class="literallayout"><p/></div>

      <p>다음은 디폴트 생성자를 호출하는 예이다.</p>

      <pre class="programlisting">create or replace type default_constructor as object (
   a1 number, 
   a2 varchar2(1024)
);    
/ 

declare 
    var default_constructor; 
begin 
    var := default_constructor(10, 'default'); 
   
    dbms_output.put_line (var.a1);
    dbms_output.put_line (var.a2);
end;
/    </pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_psm_object_user_defined_constructor"/>10.2.2. 사용자 정의 생성자<a id="d5e4627" class="indexterm"/></h3></div></div></div>
      

      <p>사용자 정의 생성자가 디폴트 생성자와 시그네쳐가 다르면 함수 오버로딩 규칙에 따라 타입 변환이 가장 적고 정보 손실이
      가장 적은 쪽을 우선적으로 선택한다. 만약 선택하지 못하는 경우 컴파일 에러가 발생한다. 사용자 정의 생성자를 생성할 때 오브젝트
      변수는 기본으로 NULL 값을 가진다. 사용자 정의 생성자에 대한 자세한 설명은 <a href="ch10.html#sect_psm_object_method" title="10.4. 메소드">“10.4. 메소드”</a>의 <a href="ch10.html#sect_psm_object_method_constructor" title="10.4.1. 생성자 메소드">“10.4.1. 생성자 메소드”</a>를 참고한다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 사용자 정의 생성자를 호출하는 예이다.</p>

      <pre class="programlisting">create or replace type constructor_body_test as object (
    a1 number,
    constructor function constructor_body_test (param1 number) 
    return self as result, 
    constructor function constructor_body_test (param1 number, param2 number) 
    return self as result 
);
/

create or replace type body  constructor_body_test
as
    constructor function constructor_body_test (param1 number)
    return self as result
    as
    begin
        a1 := param1 + 1000;
        return;
    end;

    constructor function constructor_body_test (param1 number, param2 number)
    return self as result
    as
    begin
        a1 := param1 + param2 + 1000;
        return;
    end;
end;
/

declare 
    var2 constructor_body_test ;
begin
    var2 := constructor_body_test (5, 60);
    dbms_output.put_line( var2.a1 );
end;
/</pre>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_psm_object_attribute"/>10.3. Attribute<a id="d5e4638" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">Attribute</strong></span>는 오브젝트 타입의 구성요소인 데이터들이다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>원시 데이터 타입(Primitive Data Type)</p>
      </li><li>
        <p>오브젝트 타입(Object Type)</p>
      </li><li>
        <p>컬렉션 타입(Collection Type) 중 인덱스 바이 테이블 타입(Index by table Type)을
        제외한 배열 타입(Varray Type)</p>
      </li><li>
        <p>테이블 타입(Table Type)</p>
      </li></ul></div>

    <p/>

    <p>레코드 타입(Record Type)은 Attribute 타입으로 사용될 수 없다. 레코드 타입과 인덱스 바이 테이블 타입은
    <span>tbPSM</span> 로컬 타입(<span>tbPSM</span> BLOCK 안에서 선언 가능)이기 때문이다. 즉, 원시 데이터 타입과
    create type DDL 문으로 선언하는 타입은 Attribute 타입으로 사용 가능하다. Attribute의 이름은 중복을
    허용하지 않으며, 메소드 이름과 중복되면 안 된다.</p>

    <p>다음은 컬렉션 타입과 오브젝트 타입을 혼합 사용한 예이다.</p>

    <pre class="programlisting">-- 국가 타입 
create type o_nation  as object (
    name       varchar2(16),
    continent  varchar2(16),
    climate    varchar2(16)
);
/
-- 주소 타입 
create type o_address as object (
    nation  o_nation,
    city    varchar2(16),
    street  varchar2(16),
    zipcode varchar2(16)
);
/

-- 사람 타입 
create type o_person as object (
    name                varchar2(16),
    height              number,
    weight              number,
    living_place        o_address,
    working_place       o_address,
    gender              char(1),
    ex_military_service char(1)
);
/

-- 이직 프러시저 
create procedure  change_working_place (p in out o_person, a in o_address)
as
begin
    p.working_place := a;
end;
/
-- 직장을 출력하는 프러시저 
create procedure  print_working_place (p in o_person)
as
begin
   dbms_output.put_line('&gt;' || p.working_place.nation.name);
   dbms_output.put_line('&gt;' || p.working_place.nation.continent);
   dbms_output.put_line('&gt;' || p.working_place.nation.climate);
   dbms_output.put_line('&gt;' || p.working_place.city);
   dbms_output.put_line('&gt;' || p.working_place.street);
   dbms_output.put_line('&gt;' || p.working_place.zipcode);
end;
/

-- 그 나라의 수도를 기본 주소로 주소를 생성하는 함수 
create function default_address (nation varchar2) return o_address
as
begin
    if nation = 'Korea' then
      return o_address(o_nation(nation, null, null), 'Seoul', null, null);
    elsif nation = 'USA' then
      return o_address(o_nation(nation, null, null), 'Washington', null, null);
    elsif nation = 'France' then
      return o_address(o_nation(nation, null, null), 'Paris', null, null);
    else
      return o_address(o_nation(nation, null, null), null, null, null);
    end if;
end;
/
-- 미국 피닉스에서 태어난 "인피니데이터"의 직장위치를 
-- 크로아티아의 수도에서 한국의 수도로 변경하는 애플리케이션
set serveroutput on

declare
    my_person o_person;
begin
    my_person := o_person('Infinidata', '180', '72',
     o_address(o_nation('USA', null, null), 'Pheonix', null, null),
     o_address(o_nation('Croatia', null, null), 'Zagreb', null, null),'M', 'Y');
    print_working_place (my_person); 
    change_working_place (my_person, default_address('Korea'));
    print_working_place (my_person);
end;
/  </pre>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_psm_object_method"/>10.4. 메소드<a id="d5e4659" class="indexterm"/></h2></div></div></div>
    

    <p><span><strong class="guibutton">메소드</strong></span>는 오브젝트 타입에 필요한 서브 프로그램이다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p><a href="ch10.html#sect_psm_object_method_constructor" title="10.4.1. 생성자 메소드">생성자
        메소드</a></p>
      </li><li>
        <p><a href="ch10.html#sect_psm_object_method_static" title="10.4.2. 정적 메소드">정적
        메소드</a></p>
      </li><li>
        <p><a href="ch10.html#sect_psm_object_method_order" title="10.4.3. ORDER 메소드">ORDER
        메소드</a></p>
      </li><li>
        <p><a href="ch10.html#sect_psm_object_method_map" title="10.4.4. MAP 메소드">MAP 메소드</a></p>
      </li><li>
        <p><a href="ch10.html#sect_psm_object_method_member" title="10.4.5. 멤버 메소드">멤버
        메소드</a></p>
      </li></ul></div>

    <p>정적 메소드, 멤버 메소드는 함수나 프러시저가 가능하고, ORDER 메소드와 MAP 메소드는 함수만 가능하다. 오프젝트
    타입은 ORDER 메소드나 MAP 메소드 둘 중에 하나만 가질 수 있다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_psm_object_method_constructor"/>10.4.1. 생성자 메소드<a id="d5e4682" class="indexterm"/><a id="d5e4684" class="indexterm"/></h3></div></div></div>
      

      <p>사용자 정의 생성자를 생성할 때 리턴 문에 리턴 값을 써주지 않더라도 암묵적으로 새 인스턴스를 반환한다. 사용자 정의
      생성자의 첫 번째 파라미터로 SELF라는 이름의 자기 자신의 타입을 가지는 파라미터를 명시 가능하지만 지정하지 않는 것과
      동일하다. 첫 번째 파라미터를 SELF로 지정하지 않더라도 암묵적으로 SELF가 있는 것과 같기 때문이다(암묵적인 SELF는
      IN/OUT NOCOPY 파라미터이다).</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_psm_object_method_static"/>10.4.2. 정적 메소드<a id="d5e4690" class="indexterm"/><a id="d5e4692" class="indexterm"/></h3></div></div></div>
      

      <p>정적 메소드는 오브젝트 INSTANTIATION을 하지 않고도 호출이 가능한 메소드로 다음과 같은 형태로
      호출한다.</p>

      <pre class="programlisting">"오브젝트 타입 이름"."정적 메소드 이름" (아규먼트들)</pre>

      <p>정적 메소드는 타입 이름을 가지고 호출하기 때문에 생성자의 호출과 상관없이 불리는 경우 인스턴스에 대한 접근이
      불가능하다. 즉, 정적 메소드는 인스턴스 데이터 접근과 전혀 상관없는 경우에만 사용되어야 한다.</p>

      <p>다음은 정적 메소드의 사용 예이다.</p>

      <pre class="programlisting">-- 스머프 타입 
drop type smuff force;

create type smuff as object(
    name   varchar(1024),   -- 스머프 이름
    height number,          -- 스머프 키
    static function eat(blueberry in number, sizeofmeal in number)
    return number
);
/

create type body smuff
as
    -- 스머프가 밥을 먹는다고 키가 크지 않는다. 
    -- 이름이 비뀌지도 않는다.  
    static function eat(blueberry in number, sizeofmeal in number)
    return number
    as
    begin
        return blueberry - sizeofmeal;
    end;
end;
/
show err

set serveroutput on
declare
    fafa_smuff smuff;
    blueberry_amount number := 10000;
begin
     -- 8cm 키의 파파 스머프 생성
    fafa_smuff := smuff('Fafa', 8);

    -- 키와 상관없이 모두 하루에 100개의 블루베리를 먹는다. 
    -- 스머프 식사와 스머프 데이터와 관련이 없고, 
    -- 블루베리의 양만 줄어들고 있으므로, 
    -- static method 사용이 적절하다. 
    blueberry_amount := smuff.eat(blueberry_amount, 100);

    dbms_output.put_line ('# of blueberry:' || blueberry_amount);
end;
/</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_psm_object_method_order"/>10.4.3. ORDER 메소드<a id="d5e4702" class="indexterm"/><a id="d5e4704" class="indexterm"/></h3></div></div></div>
      

      <p>ORDER 메소드는 두 개의 오브젝트 인스턴스를 비교하기 위해 사용되는 메소드이다. 매개변수로 SELF를 제외하고
      유일한 자기 자신의 타입을 가지는 파라미터 하나가 있어야 한다. 또한 리턴 값은 숫자 타입(Number, Bin_Integer,
      Binary_double, Binary_float와 그에 따른 Sub Type)만을 가져야 한다.</p>

      <p>만약 이항 비교 연산자가 표현식에 존재하는 경우 <span><strong class="guibutton">a "비교연산자" b</strong></span>는 다음과
      같이 변환되어 오브젝트 인스턴스의 비교가 가능하도록 한다. 이러한 기능은 <span>tbPSM</span> 표현식에서만 가능하고 SQL에서는 사용 불가능하다.</p>

      <pre class="programlisting">a.order_method(b) "비교연산자" 0</pre>

      <p/>

      <p/>

      <p>MAP 메소드와 ORDER 메소드의 파라미터와 반환값 비교는 다음과 같다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col width="80" align="left"/><col width="300" align="left"/><col/></colgroup><thead><tr><th align="left">메소드</th><th align="left">파라미터</th><th>반환값</th></tr></thead><tbody><tr><td align="left">MAP</td><td align="left">SELF를 제외하고 파라미터 사용이 불가능하다.</td><td>Primitive Data Type</td></tr><tr><td align="left">ORDER</td><td align="left">SELF를 제외하고 자기 자신 타입을 가지는 1개의 IN 파라미터 사용이 가능하다.</td><td><p>숫자 타입</p><div class="itemizedlist"><ul type="circle" compact="compact"><li style="list-style-type: circle">
                    <p>Number</p>
                  </li><li style="list-style-type: circle">
                    <p>Bin_Integer</p>
                  </li><li style="list-style-type: circle">
                    <p>Binary_double</p>
                  </li><li style="list-style-type: circle">
                    <p>Binary_float</p>
                  </li><li style="list-style-type: circle">
                    <p>그에 따른 Sub Type</p>
                  </li></ul></div></td></tr></tbody></table>
      </div>

      <p>사용자는 두 개의 파라미터를 비교하여 다음과 같이 메소드를 작성해야 한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>SELF가 더 큰 경우: 음수를 리턴한다.</p>
        </li><li>
          <p>두개가 같은 경우: 0을 리턴한다.</p>
        </li><li>
          <p>SELF가 작은 경우: 양수를 리턴한다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 Stack 타입의 ORDER 메소드 작성을 이용하여 두 개의 Stack을 비교하는 예이다(Stack의
      element 개수가 많은것이 더 값이 크다고 가정).</p>

      <pre class="programlisting">DROP TYPE number_array force;

CREATE OR REPLACE TYPE number_array AS TABLE OF NUMBER;
/
show err 

DROP TYPE type_nstack force;

CREATE OR REPLACE TYPE type_nstack AS OBJECT(
    maxlen pls_integer,  -- Stack의 최대 크기
    topptr pls_integer,  -- Stack의 TOP
    array  number_array, -- Stack 내부 데이터 

    MEMBER PROCEDURE pop (self in out nocopy type_nstack),
    MEMBER FUNCTION top (self in out nocopy type_nstack) return NUMBER,
    MEMBER PROCEDURE push (self in out nocopy type_nstack, input NUMBER),

    CONSTRUCTOR FUNCTION type_nstack(maxlen pls_integer) RETURN SELF AS RESULT,
    ORDER MEMBER FUNCTION compare(v in type_nstack) RETURN NUMBER
);
/
show err

CREATE OR REPLACE TYPE BODY type_nstack
AS
    MEMBER PROCEDURE pop (self in out nocopy type_nstack)
    AS
    BEGIN
        IF topptr &lt;= 0 THEN
            raise_application_error(-20000, 'stack is empty', true);
        ELSE
            array(topptr) := NULL;
            topptr := topptr - 1;
        END IF;
    END;

    MEMBER FUNCTION top (self in out nocopy type_nstack) return NUMBER
    AS
    BEGIN
        IF topptr &lt;= 0 THEN
            return NULL;
        ELSE
            return array(topptr);
        END IF;
        return NULL;
    END;

    MEMBER PROCEDURE push (self in out nocopy type_nstack, input NUMBER)
    AS
    BEGIN
        IF topptr = maxlen THEN
            raise_application_error(-20001, 'stack is full', true);
        ELSE
            array(self.topptr + 1) := input;
            topptr := topptr + 1;
        END IF;
    END;

    CONSTRUCTOR FUNCTION type_nstack(maxlen pls_integer) RETURN SELF AS RESULT
    AS
    BEGIN
        array := number_array();
        array.extend(maxlen);
        topptr := 0;

        RETURN;
    END;

    ORDER MEMBER FUNCTION compare(v in type_nstack) RETURN NUMBER
    AS
    BEGIN
        IF      self.array.count = v.array.count THEN
            RETURN 0;
        ELSIF   self.array.count &lt; v.array.count THEN
            RETURN -1;
        ELSE
            RETURN 1;
        END IF;
    END;
END;
/

set serveroutput on

// 두 개의 Stack을 비교하는 애플리케이션 
declare
    s1 type_nstack;
    s2 type_nstack;
begin
    s1 := type_nstack(8);
    s2 := type_nstack(4);
    if s2 &lt; s1 then
        dbms_output.put_line('s2 is smaller then s1.');
    end if;

    s1 := type_nstack(4);
    s2 := type_nstack(8);
    if s2 &gt; s1 then
        dbms_output.put_line('s2 is bigger then s1.');
    end if;

    s1 := type_nstack(4);
    s2 := type_nstack(4);
    if s2 = s1 then
        dbms_output.put_line('s2 is equal to s1.');
    end if;

end;
/</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_psm_object_method_map"/>10.4.4. MAP 메소드<a id="d5e4758" class="indexterm"/></h3></div></div></div>
      

      <p>MAP 메소드는 인스턴스에서 primitive 타입의 scalar 값을 리턴하는 메소드이다. 함수는 SELF 외에
      아무런 파라미터가 있어서는 안되며 primitive 타입을 리턴해야 한다. 만약 이항 연산자가 있는 경우 <span><strong class="guibutton">a
      &lt; b</strong></span>는 다음과 같이 변환되어 오브젝트 인스턴스의 비교가 가능하도록 한다.</p>

      <pre class="programlisting">a.map_mehod() &lt; b.map_method()</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 MAP 메소드의 사용 예이다.</p>

      <pre class="programlisting">CREATE OR REPLACE TYPE some_type AS OBJECT (
    key_value   number,
    divider     number,

    MAP MEMBER FUNCTION get_hashval RETURN NUMBER
    );
/

CREATE OR REPLACE TYPE BODY some_type
AS
    MAP MEMBER FUNCTION get_hashval RETURN NUMBER
    AS
    BEGIN
        return mod (key_value, divider);
    END;
END;
/


DECLARE
    var1 some_type;
    var2 some_type;
BEGIN
    var1 := some_type (15, 10);
    var2 := some_type (16, 10);
    dbms_output.put_line ( var1.get_hashval );
    dbms_output.put_line ( var2.get_hashval );

    IF var1 &lt; var2 THEN     
        -- var1 &lt; var2에서 암묵적으로 MAP 메소드가 호출된다. 
        -- 즉, var1.get_hashval() &lt; var2.get_hashval()로 변환된다. 
        dbms_output.put_line ('var2 is bigger then var1.');
    ELSE
        dbms_output.put_line ('var1 is bigger then var2.');
    END IF;
END;
/</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_psm_object_method_member"/>10.4.5. 멤버 메소드<a id="d5e4769" class="indexterm"/></h3></div></div></div>
      

      <p>멤버 메소드는 다음과 같은 형태로 호출한다.</p>

      <pre class="programlisting">"인스턴스 이름"."메소드 이름"</pre>

      <p>멤버 메소드는 첫 번째 파라미터가 암묵적인 SELF 파라미터로 자기 자신의 타입을 가지는 파라미터이다. 기본 속성은
      IN 파라미터이며 사용자가 IN/OUT 형태로 변경이 가능하다. IN으로 사용하면 Attribute 값을 변경할 수 없고 리턴을
      통해 변경이 가능하므로 원소적인 동작을 취할수 있다. SELF 파라미터는 인스턴스 데이터에 접근할 수 있도록 해주며
      "SELF"."Attribute 이름"으로 사용하거나 "Attribute 이름"으로 직접 사용이 가능하다.</p>

      <p>멤버 메소드는 OVERLOADING이 가능하지만 MAP, ORDER 메소드는 OVERLOADING이 불가능하다. 멤버
      메소드는 LOCAL METHOD(BODY에서만 사용 가능한 메소드)를 정의할 수 없다. 항상 TYPE OBJECT에 기술된
      메소드가 정확히 BODY에도 존재해야 하며, BODY에 존재하는 메소드는 반드시 TYPE OBJECT에 기술되야
      한다.</p>

      <p>다음은 Number Stack의 사용 예이다.</p>

      <pre class="programlisting">declare 
  s1 type_nstack;
begin 
  s1 := type_nstack (16); 
  
  s1.push (1);                     -- 멤버 메소드 호출(procedure) 
  dbms_output.put_line (s1.top())  -- 멤버 베소드 호출(function)
  s1.pop;                          -- 멤버 메소드 호출(procedure)  
end;
/</pre>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_psm_object_static_view"/>10.5. 오브젝트 관련 정적 뷰<a id="d5e4779" class="indexterm"/></h2></div></div></div>
    

    <p>다음은 <span><strong class="guibutton">오브젝트 관련 정적 뷰</strong></span>이다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p>ALL_TYPES, DBA_TYPES, USER_TYPES</p>
      </li><li>
        <p>ALL_COLL_TYPES, DBA_COLL_TYPES, USER_COLL_TYPES</p>
      </li><li>
        <p>ALL_TYPE_ATTRS, DBA_TYPE_ATTRS, USER_TYPE_ATTRS</p>
      </li><li>
        <p>ALL_TYPE_METHODS, DBA_TYPE_METHODS, USER_TYPE_METHODS</p>
      </li><li>
        <p>ALL_METHOD_PARAMS, DBA_METHOD_PARAMS, USER_METHOD_PARAMS</p>
      </li><li>
        <p>ALL_METHOD_RESULTS, DBA_METHOD_RESULTS,
        USER_METHOD_RESULTS</p>
      </li></ul></div>

    <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>해당 뷰에 대한 자세한 내용은 "<span>Tibero</span> 참조 안내서"의 "제3장 Static View"를 참고한다.</p>
      </div>

    <p/>

    <p/>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch09.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch11.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제9장 파이프라인드 테이블 함수 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제11장 사용자 정의 AGGREGATION 함수</td></tr></table></div><div xmlns="" align="center"/></body></html>