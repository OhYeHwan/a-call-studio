<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta xmlns="" http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>제3장 기본 프로그래밍</title><link rel="stylesheet" href="../stylesheet.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Tibero tbESQL/COBOL 안내서"/><link rel="up" href="index.html" title="Tibero tbESQL/COBOL 안내서"/><link rel="prev" href="ch02.html" title="제2장 데이터 타입"/><link rel="next" href="chapter_array_variable.html" title="제4장 배열 변수"/></head><body><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><td class="navbar-title" colspan="3" align="center">제3장 기본 프로그래밍</td></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02.html">이전</a> </td><td class="navbar-title" width="60%" align="center"> </td><td width="20%" align="right"> <a accesskey="n" href="chapter_array_variable.html">다음</a></td></tr></table><hr/></div><div class="chapter" lang="ko"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1300"/>제3장 기본 프로그래밍</h2></div></div></div><div class="toc"><p><b>내용 목차</b></p><dl><dt><span class="section"><a href="ch03.html#d5e1305">3.1. 개요</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d5e1310">3.1.1. <span>tbESQL</span>/COBOL 프로그램 문법</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1371">3.1.2. 프로그램 실행 과정</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1457">3.1.3. 런타임 에러 처리</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#d5e1494">3.2. 프로그램 구조</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#sect_variable_declear">3.2.1. 변수 선언</a></span></dt><dt><span class="section"><a href="ch03.html#sect_init">3.2.2. 초기화</a></span></dt><dt><span class="section"><a href="ch03.html#sect_database_work">3.2.3. 데이터베이스 작업</a></span></dt><dt><span class="section"><a href="ch03.html#sect_rollback_and_commit">3.2.4. 종료화</a></span></dt><dt><span class="section"><a href="ch03.html#sect_error">3.2.5. 에러 처리</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#d5e1570">3.3. <span>tbESQL</span>/COBOL 문장 실행</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d5e1576">3.3.1. SELECT</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1644">3.3.2. INSERT</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1665">3.3.3. UPDATE</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1685">3.3.4. DELETE</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#sect_cursor">3.4. 커서</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d5e1706">3.4.1. 사용 방법</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1757">3.4.2. CURRENT OF 절</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1779">3.4.3. 사용 예제</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#sect_scrollable_cursor">3.5. 스크롤 가능 커서</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d5e1812">3.5.1. 사용 방법</a></span></dt><dt><span class="section"><a href="ch03.html#d5e1892">3.5.2. 사용 예제</a></span></dt></dl></dd></dl></div>
  

  <p>본 장에서는 <span>tbESQL</span>/COBOL 프로그램의 문법과 실행 과정, 런타임 에러(runtime
  error) 처리, 그리고 <span>tbESQL</span>/COBOL 문장의 실행, 커서를 설명한다.</p>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1305"/>3.1. 개요</h2></div></div></div>
    

    <p>본 절에서는 <span>tbESQL</span>/COBOL 프로그램의 문법과 런타임 에러 처리에 대해서
    설명한다.</p>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1310"/>3.1.1. <span>tbESQL</span>/COBOL 프로그램 문법</h3></div></div></div>
      

      <p><span>tbESQL</span>/COBOL 프로그램의 문법은 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>SQL 문장의 시작과 끝</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p><span>tbESQL</span>/COBOL 프로그램에 포함되는 SQL 문장은 항상
              <span><strong class="guibutton">EXEC SQL</strong></span>로 시작되며
              <span><strong class="guibutton">END-EXEC.</strong></span>로 끝난다.</p>
            </li><li>
              <p>하나의 SQL 문장은 여러 줄에 걸쳐 있을 수 있다.</p>
            </li></ul></div>
        </li><li>
          <p>DECLARE 영역<a id="d5e1328" class="indexterm"/></p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>DECLARE 영역은 <span><strong class="guibutton">'BEGIN DECLARE
              SECTION'</strong></span>으로 시작되며, <span><strong class="guibutton">'END DECLARE
              SECTION'</strong></span>으로 끝난다.</p>
            </li><li>
              <p>DECLARE 영역에는 변수 선언 이외에 다른 코드가 삽입되어서는 안 된다.</p>
            </li><li>
              <p>SQL 문장과 함께 사용되는 입/출력 변수는 항상 DECLARE 영역에 선언해야 한다.</p>

              <p>입/출력 변수가 구조체나 배열의 형태로 선언된 경우에도 DECLARE 영역에 선언해야 한다.</p>

              <p>단, 프리컴파일러 옵션에 따라 그렇지 않은 경우도 있다. 프리컴파일러 옵션에 대해서는 <a href="chapter_precompiler_option.html" title="제6장 tbESQL/COBOL 프리컴파일러 옵션">“제6장 <span>tbESQL</span>/COBOL 프리컴파일러 옵션”</a>을 참고한다.</p>
            </li><li>
              <p>입/출력 변수가 아닌 일반적인 프로그램 변수의 경우에는 DECLARE 영역 밖에 선언되어도
              무방하다.</p>
            </li><li>
              <p>다음은 DECLARE 영역의 예이다.</p>

              <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
01 OPERATION PIC X(20) VARYING OCCURS 5 TIMES. 
01 TELLER. 
   03 EMPNO  PIC S9(7). 
   03 ENAME  PIC X(10). 
   03 SALARY PIC S9(5). 
01 CNT PIC S9(9). 
EXEC SQL END DECLARE SECTION END-EXEC.</pre>
            </li></ul></div>
        </li><li>
          <p>문자열</p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>COBOL 프로그래밍 코드에 포함된 문자열은 큰따옴표(" ")를 사용한다.</p>
            </li><li>
              <p><span>tbESQL</span>/COBOL 문장에 포함되는 문자열은 작은따옴표('
              ')를 사용한다.</p>
            </li></ul></div>
        </li><li>
          <p>주석(Comment)<a id="d5e1357" class="indexterm"/></p>

          <div class="itemizedlist"><ul type="circle" compact="compact"><li>
              <p>주석은 COBOL 프로그래밍 언어에서 사용하는 방법 이외에 두 개의 마이너스 부호(--)를 이용하는
              방법이 있다.</p>
            </li><li>
              <p>두 개의 마이너스 부호(--)를 사용하는 주석은 부호(--)가 시작되는 곳에서부터 그 라인의 끝까지
              주석으로 처리한다. 또한 EXEC SQL 문장에만 사용될 수 있으며, COBOL 프로그래밍 코드 부분에는 사용되지
              못한다.</p>
            </li><li>
              <p>다음은 주석을 사용하는 예이다.</p>

              <pre class="programlisting">EXEC SQL SELECT ENAME, SALARY, ADDR 
         INTO :EMP -- 구조체 변수를 사용한다. 
         FROM EMP 
         WHERE EMPNO = :EMPNO 
END-EXEC.</pre>
            </li></ul></div>
        </li></ul></div>

      <p/>

      <p/>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1371"/>3.1.2. 프로그램 실행 과정</h3></div></div></div>
      

      <p/>

      <p><span>tbESQL</span>/COBOL 프로그램을 작성할 때는 필요한 데이터 타입이나 함수
      프로토타입 등을 이용하기 위해서 반드시 <span><strong class="guibutton">SQLCA</strong></span> 파일을 포함해야 한다. 즉, 아래의
      내용이 항상 <span>tbESQL</span>/COBOL 프로그램 소스 코드의 맨 위에 명시되어 있어야
      한다.</p>

      <pre class="programlisting">EXEC SQL INCLUDE SQLCA END-EXEC.</pre>

      <p>만약 존재하지 않으면 프리컴파일러 실행 후에 생성되는 COBOL 코드에 자동으로 추가된다.</p>

      <div class="literallayout"><p/></div>

      <p>다음 그림은 <span>tbESQL</span>/COBOL 프로그램 소스 코드를 실행 파일로 생성하기 위해 거치는 전
      과정이다. 프리컴파일 과정을 제외하면 COBOL 프로그램의 경우와 별로 다르지 않다.</p>

      <div class="figure"><a id="figure_tbcesql_program_compile_link"/><p class="title"><b>[그림 3.1] <span>tbESQL</span>/COBOL 프로그램 실행 과정</b></p><div class="figure-contents">
        

        <div xmlns="" class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="385"><tr><td align="left"><img src="resources/img_esql_02.png" align="top" width="385" alt="tbESQL/COBOL 프로그램 실행 과정"/></td></tr></table></div>
      </div></div><br class="figure-break"/>

      <p>위의 <a href="ch03.html#figure_tbcesql_program_compile_link" title="[그림 3.1] tbESQL/COBOL 프로그램 실행 과정">[그림 3.1]</a>의 과정을
      순서대로 설명하면 다음과 같다.</p>

      <div class="orderedlist"><ol type="1" compact="compact"><li>
          <p><span>tbESQL</span>/COBOL program</p>

          <p><span>tbESQL</span>/COBOL 프로그램을 작성한 뒤 소스 코드를 저장하면
          <span><strong class="guibutton">.<span>tb</span>co</strong></span> 확장자를 갖는 파일이 생성된다.</p>
        </li><li>
          <p>Precompile</p>

          <p>작성된 프로그램을 실행하려면, 먼저 프리컴파일 과정을 거쳐야 한다.<span> tbESQL</span>/COBOL의 프리컴파일러를 실행하는 명령어는
          <span><strong class="guibutton"><span>tbpc</span>b</strong></span>이다.</p>

          <p>다음은 emp.<span>tb</span>co 프로그램 파일에 대해 프리컴파일을 실행하는 예이다.</p>

          <div class="example"><a id="ex_tbpc"/><p class="title"><b>[예 3.1] emp.<span>tb</span>co 프로그램의 프리컴파일</b></p><div class="example-contents">
            

            

            <pre class="programlisting">$ <span>tbpc</span>b emp.<span>tb</span>co</pre>
          </div></div><br class="example-break"/>

          <p>프리컴파일러를 실행하는 명령어는 옵션을 포함할 수 있다.</p>

          <p>다음은 프리컴파일러 옵션을 사용하여 COPY 또는 SQLCA ESQL INCLUDE 파일의 경로를 지정하는
          예이다.</p>

          <div class="example"><a id="d5e1415"/><p class="title"><b>[예 3.2] 프리컴파일러 옵션을 사용한 COPY 또는 SQLCA ESQL INCLUDE 파일의 경로 지정</b></p><div class="example-contents">
            

            

            <pre class="programlisting">$ <span>tbpc</span>b INCLUDE=../include emp.<span>tb</span>co</pre>
          </div></div><br class="example-break"/>

          <p>프리컴파일러 옵션에 대한 자세한 내용은 <a href="chapter_precompiler_option.html" title="제6장 tbESQL/COBOL 프리컴파일러 옵션">“제6장 <span>tbESQL</span>/COBOL 프리컴파일러 옵션”</a>을 참고한다.</p>
        </li><li>
          <p>General program</p>

          <p>프리컴파일의 결과로는 COBOL 프로그램 소스 코드가 생성되며, 이때 파일의 이름은 원본 파일의 이름과 동일하고
          확장자만 <span><strong class="guibutton">.cob</strong></span>로 변경된다. 예를 들어 emp.<span>tb</span>co
          파일을 프리컴파일하면 emp.cob라는 이름을 가진 파일이 생성된다.</p>
        </li><li>
          <p>Compile, Link</p>

          <p>프리컴파일이 완료된 파일은 그 다음으로 컴파일 과정과 링크 과정을 거쳐야 한다. <a href="ch03.html#figure_tbcesql_program_compile_link" title="[그림 3.1] tbESQL/COBOL 프로그램 실행 과정">[그림 3.1]</a>에서는 컴파일과 링크 과정이 따로
          표현되었지만, 실제로는 대개의 경우에 두 과정이 함께 수행된다.</p>

          <p>다음은 <a href="ch03.html#ex_tbpc" title="[예 3.1] emp.tbco 프로그램의 프리컴파일">[예 3.1]</a>의 실행결과로 생성된 emp.cob 파일을 컴파일하고
          링크하는 예이다. 본 예제는 64-bit 머신의 MF-COBOL 컴파일러를 사용하는 경우이다.</p>

          <div class="example"><a id="d5e1434"/><p class="title"><b>[예 3.3] 컴파일과 링크 과정</b></p><div class="example-contents">
              

              <pre class="programlisting">$ cob64 -xo emp emp.cob -L$<span>TB_HOME</span>/client/lib -l<span>tbertl</span> -l<span>tbcli</span> -lpthread -lm</pre>
            </div></div><p><br class="example-break"/></p>

          <p><span>tbESQL</span>/COBOL에서는 <span>tbCLI</span> 함수도 함께 사용하기 때문에 <span>tbERTL</span> 라이브러리 이외에 <span>tbCLI</span> 라이브러리를 함께 링크한다.</p>

          <p>위의 <a href="ch03.html#figure_tbcesql_program_compile_link" title="[그림 3.1] tbESQL/COBOL 프로그램 실행 과정">[그림 3.1]</a>에서
          링크(Link) 과정에서 링커(Linker)의 입력으로 받아들이는 <span><strong class="guibutton"><span>tbERTL</span> 라이브러리</strong></span>는 <span>tbESQL</span>/COBOL의 함수 라이브러리이다. 이 라이브러리에는
          esql_do 함수 등이 정의되어 있으며, <span>tbESQL</span>/COBOL 프로그램을 안전하고 효율적으로 실행하기 위한 여러
          가지 작업을 수행한다.<a id="d5e1451" class="indexterm"/></p>
        </li><li>
          <p>Execution code</p>

          <p>컴파일 과정과 링크 과정을 거치고 나면 emp라는 이름의 실행 파일이 생성된다.</p>
        </li></ol></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1457"/>3.1.3. 런타임 에러 처리</h3></div></div></div>
      

      <p><span>tbESQL</span>/COBOL 프로그램 내의 SQL 문장을 실행했을 때 에러 또는 경고
      등의 여러 가지 예외 상황이 발생할 수 있다. 예를 들면 SELECT 문장의 실행 결과로 반환되는 로우가 존재하지 않거나 특정
      컬럼의 일부 내용이 잘린 경우를 들 수 있다. <span>tbESQL</span>/COBOL 프로그램 내에서는 에러 또는 경고 상황이 발생한 경우 그에
      대한 적절한 처리를 프로그램 내에서 수행할 수 있다.</p>

      <p><span>tbESQL</span>/COBOL에서는 이러한 런타임 에러 처리를 위해 다음의 세 가지
      인터페이스를 지원한다.</p>

      <div class="informaltable">
          <table border="1"><colgroup><col width="130" align="left"/><col/></colgroup><thead><tr><th align="left">인터페이스</th><th>설명</th></tr></thead><tbody><tr><td align="left">상태 변수<a id="d5e1475" class="indexterm"/></td><td><p>상태 변수(Status Variable)는 임의의 SQL 문장이 실행된 결과가 저장되는
                변수이다.</p><p>프로그램 내에서는 SQL 문장을 실행한 후에 상태 변수의 값을 검토하여, 에러
                또는 경고 상황의 발생을 알 수 있고, 그에 따른 처리를 수행할 수 있다.</p></td></tr><tr><td align="left"><p>SQLCA<a id="d5e1483" class="indexterm"/></p></td><td><p>SQLCA(SQL 통신 영역: SQL Communication Area)는 임의의 SQL
                문장이 실행된 결과가 저장되는 구조체 변수이다. 이 구조체는 SQLCA라는 이름으로 SQLCA ESQL
                INCLUDE 파일에 정의되어 있으며, 상태 변수를 포함하고 있다.</p><p>상태 변수와
                마찬가지로, SQL 문장을 실행한 후에 SQLCA 내의 적절한 멤버 변수의 값을 검토하여 에러 또는 경고 상황의
                발생을 알 수 있고, 그에 따른 처리를 수행할 수 있다.</p></td></tr><tr><td align="left">WHENEVER<a id="d5e1490" class="indexterm"/></td><td>WHENEVER 문장은 에러 또는 경고 상황이 발생하면 미리 정해진 특정 동작을 수행한다. 상태
                변수나 SQLCA 구조체를 이용하면 SQL 문장을 실행할 때마다 에러 또는 경고 상황이 발생하였는지 검토해야
                한다. 하지만 WHENEVER 문장을 사용하면 <span>tbESQL</span>/COBOL이 자동으로 예외 상황을 검토하고 그에
                따른 처리를 수행한다.</td></tr></tbody></table>
        </div>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1494"/>3.2. 프로그램 구조</h2></div></div></div>
    

    <p><span>tbESQL</span>/COBOL 프로그램의 구조는 다음과 같다.</p>

    <div class="itemizedlist"><ul type="disc" compact="compact"><li>
        <p><a href="ch03.html#sect_variable_declear" title="3.2.1. 변수 선언">변수 선언</a></p>
      </li><li>
        <p><a href="ch03.html#sect_init" title="3.2.2. 초기화">초기화</a></p>
      </li><li>
        <p><a href="ch03.html#sect_database_work" title="3.2.3. 데이터베이스 작업">데이터베이스 작업</a></p>
      </li><li>
        <p><a href="ch03.html#sect_rollback_and_commit" title="3.2.4. 종료화">종료화</a></p>
      </li><li>
        <p><a href="ch03.html#sect_error" title="3.2.5. 에러 처리">에러 처리</a></p>
      </li></ul></div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_variable_declear"/>3.2.1. 변수 선언</h3></div></div></div>
      

      <p>변수 선언 부분에는 <a href="chapter_introduce.html#sect_component" title="1.2. 구성요소">“1.2. 구성요소”</a>에서 설명한 DECLARE 영역이
      포함된다. <span>tbESQL</span>/COBOL 문장에서 데이터베이스 작업에 사용될 모든 변수를
      DECLARE 영역에 선언해야 한다. 데이터베이스 작업과 관련이 없는 변수는 DECLARE 영역에 포함하지 않아도
      된다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 변수 선언의 예이다.</p>

      <pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION END-EXEC.
01 BRANCH pic x(9) varying.
01 POSTAL pic x(10) varying.
01 REGION pic x(10) varying.
01 OPERATION pic x(20) varying occurs 5 times.
01 TELLER.
    03 IDE pic x(5).
    03 BR pic x(5).
    03 NAMEE pic x(12).
01 TELLER2 occurs 10 times.
    03 IDE pic x(5).
    03 BR pic x(5).
    03 NAMEE pic x(12).
01 IDK pic x(5) occurs 10 times.
01 NAMEK pic x(12) occurs 10 times.
01 CDK pic x(5).
EXEC SQL END DECLARE SECTION END-EXEC.</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_init"/>3.2.2. 초기화</h3></div></div></div>
      

      <p>초기화 부분에서는 다음의 두 가지를 수행한다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>런타임 에러가 발생했을 때 어떤 작업을 수행할 것인지 선언한다.</p>

          <p>런타임 에러가 발생했을 때 수행하는 작업에는 에러 처리 함수를 호출하는 경우, 에러를 무시하고 프로그램을 계속
          진행하는 경우, 프로그램을 종료하는 경우, 특정 위치로 이동한 후 실행을 계속하는 경우 등이 있다. 대부분의 경우에 에러
          처리를 위한 함수를 미리 정의하고 그 정의된 함수를 호출한다.</p>

          <p>다음은 런타임 에러가 발생했을 때 <code class="function"><span>tbesql</span>_error</code> 함수를 호출하는
          예이다.</p>

          <div class="example"><a id="d5e1532"/><p class="title"><b>[예 3.4] <code class="function"><span>tbesql</span>_error</code>함수 호출</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL WHENEVER SQLERROR 
DO CALL "<span>tbesql</span>_error" USING 
BY REFERENCE SQLCODE IN SQLCA 
END-EXEC.</pre>
          </div></div><br class="example-break"/>
        </li><li>
          <p><span>Tibero</span>의 데이터베이스에 접속한다.</p>

          <p>데이터베이스에 접속할 때는 반드시 사용자 이름과 패스워드를 함께 명시해야 한다.</p>

          <p>다음의 소스 코드는 USERNAME과 PASSWORD, 이렇게 두 개의 입력 변수를 이용해 데이터베이스에
          접속하는 예이다.</p>

          <div class="example"><a id="d5e1543"/><p class="title"><b>[예 3.5] 입력 변수를 이용해 데이터베이스에 접속</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWORD END-EXEC.</pre>
          </div></div><br class="example-break"/>
        </li></ul></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_database_work"/>3.2.3. 데이터베이스 작업</h3></div></div></div>
      

      <p>데이터베이스 작업 부분에서는 <span>tbESQL</span>/COBOL 문장을 사용해 데이터베이스 질의 및 갱신을 수행한다. 이
      부분은 <span>tbESQL</span>/COBOL 프로그램에서 가장 중요한 부분 중 하나이다.</p>

      <p>데이터베이스와 관련된 작업에는 입력 변수와 출력 변수를 많이 사용하게 된다. 데이터베이스 질의와 관련된 소스 코드에는
      커서를 선언하고, 이 선언된 커서를 이용해 로우를 액세스하는 코드가 포함된다.</p>

      <p>다음은 데이터베이스 작업 부분의 예이다.</p>

      <pre class="programlisting">EXEC SQL
     DECLARE C1 CURSOR FOR SELECT * FROM BRANCH 
     ORDER BY BRANCH_CD
END-EXEC.

EXEC SQL
     OPEN C1
END-EXEC.

EXEC SQL
     FETCH C1 INTO :BRANCH, :POSTAL, :REGION
END-EXEC.</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_rollback_and_commit"/>3.2.4. 종료화</h3></div></div></div>
      

      <p>종료화 부분에서는 모든 데이터베이스 작업을 마치고 커밋을 수행하거나 롤백을 수행한다.</p>

      <div class="caution" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">주의</h3>
        <p>종료화 부분이 <span>tbESQL</span>/COBOL 프로그램에 포함되지 않으면, 자동으로 커밋되지 않으므로
        주의한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 데이터베이스에 부분 롤백을 수행한 뒤 커밋을 하는 예이다.</p>

      <pre class="programlisting">EXEC SQL ROLLBACK WORK TO SAVEPOINT SP1 END-EXEC.
EXEC SQL COMMIT WORK END-EXEC.</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="sect_error"/>3.2.5. 에러 처리</h3></div></div></div>
      

      <p>에러 처리 부분에서는 에러를 처리하기 위한 코드가 포함된다. 에러 처리와 관련된 코드는 다른 코드와 섞여 동일한 하나의
      함수 안에 포함될 수도 있으며, 별도의 함수로 정의할 수도 있다.</p>

      <p>다음은 에러 처리의 예이다.</p>

      <pre class="programlisting">IF SQLCODE IN SQLCA IS LESS THAN 0 
THEN DISPLAY "connection failed" 
END-IF</pre>

      <p/>

      <p/>

      
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1570"/>3.3. <span>tbESQL</span>/COBOL 문장 실행</h2></div></div></div>
    

    <p>본 절에서는 <span>tbESQL</span>/COBOL 프로그램에서 SELECT, INSERT, UPDATE,
    DELETE 문장을 실행하는 방법에 대해 설명한다. 각 문장에는 입/출력 변수가 사용되는데, 입/출력 변수는 각 문장 내에 포함된
    스키마 객체와 구별하기 위하여 반드시 앞에 <span><strong class="guibutton">콜론(:)</strong></span>이 와야 한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1576"/>3.3.1. SELECT<a id="d5e1578" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">SELECT</strong></span> 문장은 데이터베이스에 질의를 수행하고 결과 로우를 반환하는
      문장이다. 결과 로우의 개수는 보통 하나 이상이지만 하나도 없을 수도 있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1583"/>INTO 절과 출력 변수</h4>

      <p><span>tbESQL</span>/COBOL 프로그램 내에서 사용되는 SELECT 문장은 일반
      SELECT 문장과 같은 문법을 가진다. 다만 SELECT 리스트 다음에 결과 로우의 각 컬럼 값을 <span><strong class="guibutton">출력
      변수</strong></span>에 저장하기 위해 <span><strong class="guibutton">INTO 절</strong></span>이 삽입된다.<a id="d5e1588" class="indexterm"/><a id="d5e1590" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>다음은 SELECT 문장의 INTO 절에 출력 변수가 사용된 예이다.</p>

      <pre class="programlisting">EXEC SQL
     SELECT A INT :COL-A FROM TAB1
END-EXEC.</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 SELECT문장의 INTO 절에 포함되는 출력 변수에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>컬럼 값과 출력 변수의 대응</p>

          <p>INTO 절에 포함되는 출력 변수는 SELECT 리스트 내의 컬럼과 같은 개수이어야 하며, 지시자 변수와 함께
          사용될 수 있다. 질의 결과로 반환된 로우의 각 컬럼 값은 컬럼 값과 동일한 순서로 대응되는 각각의 출력 변수에 저장된다.
          출력 변수에 저장될 때 <span>tbESQL</span>/COBOL 프로그램에서는 필요한 경우 데이터 타입의 변환을
          수행한다.</p>
        </li><li>
          <p>구조체 변수</p>

          <p>INTO 절에 포함되는 출력 변수에는 구조체 변수를 사용할 수도 있다. 이때 구조체 변수에 포함된 멤버 변수의
          개수는 SELECT 리스트 내의 컬럼과 개수가 같아야 한다. <span>tbESQL</span>/COBOL 프로그램에서는 결과 로우의 각 컬럼 값을 구조체
          변수 내의 각 멤버 변수에 할당한다.</p>
        </li><li>
          <p>로우의 개수에 따른 출력 변수</p>

          <p>SELECT 문장의 결과 로우의 개수가 반드시 하나라는 보장이 있다면 INTO 절에 단순 출력 변수를 이용하여
          처리가 가능하다. 하지만 하나 이상인 경우에는 커서를 사용하거나 INTO 절에 출력 배열 변수를 사용해야
          한다.</p>
        </li></ul></div>

      <div class="note" style="margin-left: 0in; margin-right: 0in;"><h3 class="title">참고</h3>
        <p>커서에 대한 자세한 내용은 <a href="ch03.html#sect_cursor" title="3.4. 커서">“3.4. 커서”</a>와 <a href="ch03.html#sect_scrollable_cursor" title="3.5. 스크롤 가능 커서">“3.5. 스크롤 가능 커서”</a>를, 배열 변수에 대한 자세한 내용은 <a href="chapter_array_variable.html" title="제4장 배열 변수">“제4장 배열 변수”</a>를 참고한다.</p>
      </div>

      <div class="literallayout"><p/></div>

      <p>다음은 결과 로우가 하나인 경우 이를 처리하는 예이다.</p>

      <pre class="programlisting">01 ENAME  PIC X(24) VARYING. 
01 SALARY PIC S9(5). 
01 ADDR   PIC X(32) VARYING. 
... 
MOVE 20 TO EMPNO. 
EXEC SQL SELECT ENAME, SALARY * 1.05 
         INTO :ENAME, :SALARY 
         FROM EMP 
         WHERE EMPNO = :EMPNO 
END-EXEC. 
 
DISPLAY 'ENAME = ' ENAME-ARR.</pre>

      <p>위의 예에서 컬럼 EMPNO가 테이블 EMP의 기본 키 컬럼이므로 질의 결과 로우의 개수가 하나라는 것을 알 수
      있다.</p>

      <div class="literallayout"><p/></div>

      <h4><a id="d5e1619"/>WHERE 절과 입력 변수<a id="d5e1620" class="indexterm"/><a id="d5e1622" class="indexterm"/></h4>

      <p>SELECT 문장 내에서 변수의 위치는 INTO 절에 출력 변수가 포함되는 것 외에 <span><strong class="guibutton">WHERE
      절</strong></span>에 <span><strong class="guibutton">입력 변수</strong></span>가 포함된다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 SELECT 문장의 WHERE 절에 입력 변수가 사용된 예이다.</p>

      <pre class="programlisting">EXEC SQL 
  SELECT EMP_NO, EMP_NAME 
   INTO :EMP-A, :NAME 
  FROM EMP 
  WHERE DEPT_NO = :DEPT-NO 
END-EXEC.</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 SELECT 문장의 WHERE 절에 포함되는 입력 변수에 대한 설명이다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>입력 변수의 값 설정</p>

          <p>WHERE 절에 포함되는 입력 변수의 값은 SELECT 문장이 실행되기 전에 설정되어 있어야 한다. 그 이유는
          SELECT 문장은 실행 직전에 입력 변수의 값을 가져와서 SELECT 문장을 완성한 뒤에 실행되기 때문이다. SELECT
          문장의 실행에 필요한 입력 변수의 값은 그 문장이 실행되기 직전에 읽혀지므로, 입력 변수의 값은 프로그램 실행 중에
          동적으로 설정할 수 있다.</p>
        </li><li>
          <p>입력 변수 사용의 제약</p>

          <p>SELECT 문장의 입력 변수는 상수를 대신하여 사용할 수 있지만, 스키마 객체 또는 컬럼 등의 이름을 대신하여
          사용될 수는 없다. SELECT 문장에 부질의(Subquery)가 사용되는 경우에는 부질의 내에 출력 변수를 포함시킬 수는
          없지만 입력 변수를 포함시킬 수는 있다.</p>
        </li></ul></div>

      <div class="literallayout"><p/></div>

      <p>다음은 컬럼의 이름을 대신하여 입력 변수가 사용된 예이다.</p>

      <pre class="programlisting">01 ENAME    PIC X(24) VARYING. 
01 SALARY   PIC S9(5). 
01 COL-NAME PIC X(32) VARYING. 
... 
MOVE Z"EMPNO" TO COL-NAME-ARR. 
EXEC SQL SELECT ENAME, SALARY 
         INTO :ENAME, :SALARY 
         FROM EMP<span><strong class="guibutton">
         WHERE :COL-NAME = 20</strong></span>
END-EXEC.</pre>

      <p>위의 예에서 WHERE 절 다음에 컬럼의 이름이 나와야 하는데, 대신 변수가 사용되었기 때문에 잘못되었다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1644"/>3.3.2. INSERT<a id="d5e1646" class="indexterm"/></h3></div></div></div>
      

      <p>INSERT, DELETE, UPDATE 문장은 공통적으로 질의의 결과 로우가 존재하지 않으므로 출력 변수 없이 입력
      변수만을 사용한다.<span><strong class="guibutton"> INSERT</strong></span> 문장에서 입력 변수는
      <span><strong class="guibutton">컬럼</strong></span>에 삽입할 데이터 값의 위치나 <span><strong class="guibutton">부질의</strong></span> 내부에
      사용될 수 있다.</p>

      <div class="literallayout"><p/></div>

      <p>INSERT 문장에서 삽입하고자 하는 컬럼 값의 일부에 대해서만 입력 변수를 사용할 수도 있다.</p>

      <p>다음은 일부 컬럼에 대해서만 입력 변수를 사용하는 예이다.</p>

      <pre class="programlisting">01 ENAME PIC X(24) VARYING. 
01 EMPNO PIC S9(9). 
... 
MOVE 20 TO EMPNO. 
MOVE Z"Peter" TO ENAME-ARR. 
EXEC SQL INSERT INTO EMP (ENAME, SALARY, EMPNO) 
                VALUES (:ENAME, 35000, :EMPNO) 
END-EXEC.</pre>

      <p/>

      <p/>

      <div class="literallayout"><p/></div>

      <p>삽입하고자 하는 모든 컬럼 값에 대하여 입력 변수를 사용하는 경우 구조체 변수를 사용할 수 있다. 이때 구조체 변수에
      포함된 각 변수 값은 삽입하고자 하는 각 컬럼 값에 대응된다.</p>

      <p>다음은 구조체 변수를 사용해 데이터를 삽입하는 예이다.</p>

      <pre class="programlisting">01 EMP. 
   03 ENAME  PIC X(24) VARYING. 
   03 SALARY PIC S9(5). 
   03 EMPNO  PIC S9(9). 
... 
MOVE Z"Peter" TO ENAME-ARR IN ENAME IN EMP. 
MOVE 35000 TO SALARY IN EMP. 
MOVE 25 TO EMPNO IN EMP. 
EXEC SQL INSERT INTO EMP (ENAME, SALARY, EMPNO) 
                VALUES (:EMP) 
END-EXEC.</pre>

      <div class="literallayout"><p/></div>

      <p>또한 부질의에 입력 변수를 사용할 수도 있다. 다음은 부질의를 포함하는 INSERT 문장의 예이다.</p>

      <pre class="programlisting">01 SAL-BOUND PIC S9(5). 
... 
MOVE 30000 TO SAL-BOUND. 
EXEC SQL INSERT INTO EMP_SUB (ENAME, EMPNO) 
         SELECT ENAME, EMPNO FROM EMP 
         WHERE SALARY &gt;= :SAL-BOUND 
END-EXEC.</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1665"/>3.3.3. UPDATE<a id="d5e1667" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">UPDATE</strong></span> 문장도 INSERT 문장과 마찬가지로 입력 변수만을
      사용한다.</p>

      <p>UPDATE 문장에서는 <span><strong class="guibutton">SET 절</strong></span>의 컬럼 값의 위치나
      <span><strong class="guibutton">WHERE 절</strong></span>에서 입력 변수가 사용될 수 있다. UPDATE 문장에 포함된
      <span><strong class="guibutton">부질의</strong></span>에서도 입력 변수를 사용할 수 있다. UPDATE 문장에서는 INSERT 문장에서와
      달리 구조체 입력 변수를 사용할 수 없다.<a id="d5e1675" class="indexterm"/><a id="d5e1677" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>다음은 일부 컬럼 값과 WHERE 절 내에 입력 변수를 사용하는 예이다.</p>

      <pre class="programlisting">01 ENAME PIC X(24) VARYING. 
01 EMPNO PIC S9(9). 
... 
EXEC SQL UPDATE EMP 
         SET ENAME = :ENAME, SALARY = SALARY * 1.05 
         WHERE EMPNO = :EMPNO 
END-EXEC.</pre>

      <div class="literallayout"><p/></div>

      <p>다음은 부질의에 입력 변수를 사용하는 예이다.</p>

      <pre class="programlisting">01 EMPNO     PIC S9(9). 
01 SAL-BOUND PIC S9(5). 
... 
MOVE 20 TO EMPNO. 
MOVE 30000 TO SAL-BOUND. 
EXEC SQL UPDATE EMP 
         SET SALARY = (SELECT SALARY FROM EMP WHERE EMPNO = :EMPNO) 
         WHERE SALARY &lt;= :SAL-BOUND 
END-EXEC.</pre>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1685"/>3.3.4. DELETE<a id="d5e1687" class="indexterm"/><a id="d5e1689" class="indexterm"/></h3></div></div></div>
      

      <p><span><strong class="guibutton">DELETE</strong></span> 문장도 INSERT, UPDATE 문장과 마찬가지로 입력 변수만을
      사용한다. DELETE 문장에서는 <span><strong class="guibutton">WHERE 절</strong></span>에서 입력 변수가 사용된다. DELETE
      문장에서도 UPDATE 문장과 마찬가지로 구조체 입력 변수를 사용할 수 없다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 입력 변수를 사용하는 DELETE 문장의 예이다.</p>

      <pre class="programlisting">01 SAL-BOUND PIC S9(5). 
... 
MOVE 25000 TO SAL-BOUND. 
EXEC SQL DELETE FROM EMP 
         WHERE SALARY &lt;= :SAL-BOUND 
END-EXEC.</pre>

      <p/>

      <p/>

      <p/>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_cursor"/>3.4. 커서<a id="d5e1702" class="indexterm"/></h2></div></div></div>
    

    <p>본 절에서는 커서의 기본적인 사용 방법에 대하여 설명하고, 갱신 및 삭제를 위한 CURRENT OF 절을 설명한다. 그리고
    마지막으로 사용 예제를 제시한다.</p>

    <p/>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1706"/>3.4.1. 사용 방법</h3></div></div></div>
      

      <p>SELECT 문을 통한 질의를 수행할 때 WHERE 절에 기본 키 제약조건을 부여하지 않으면, 대개의 경우 결과 로우의
      개수는 하나 이상이다. <span><strong class="guibutton">커서</strong></span>는 이렇게 반환된 다수의 결과 로우에 각각 차례로 액세스하기
      위한 데이터 구조이다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 커서를 사용하는 순서이다.</p>

      <div class="orderedlist"><ol type="1"><li>
          <p>커서를 사용하기 위해서는 DECLARE CURSOR를 사용해 맨 먼저 SQL 문장과 연관하여 커서를 선언해야
          한다. 커서를 선언할 때에는 항상 커서의 이름을 주어야 하며, 커서의 선언부는 그 커서를 사용하는 다른 모든 문장의 앞에
          와야 한다.</p>

          <p>다음은 EMP-CURSOR라는 이름으로 커서를 선언하는 예이다.</p>

          <div class="example"><a id="ex_declare_cursor"/><p class="title"><b>[예 3.6] 커서의 선언</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL DECLARE EMP-CURSOR CURSOR FOR 
         SELECT ENAME, SALARY, ADDR 
         FROM EMP 
         WHERE DEPTNO = :DEPTNO 
END-EXEC.</pre>
          </div></div><br class="example-break"/>
        </li><li>
          <p>커서를 사용하기 위해서는 OPEN을 사용해 해당 커서를 열어야 한다.<a id="d5e1721" class="indexterm"/></p>

          <p>OPEN을 실행하면 연관된 SELECT 문장이 실행되어 질의의 결과 로우가 반환된다. 또한 커서는 결과 로우
          중에서 맨 처음에 위치한 로우의 직전을 가리킨다. 첫 FETCH가 실행되면 첫 번째 로우를 가리키게 된다. OPEN을
          실행할 때 유의할 점은 커서를 선언할 때 SELECT 문장에 포함된 입력 변수의 값은 OPEN이 실행될 때 할당된다는
          것이다.</p>

          <p>다음은 <a href="ch03.html#ex_declare_cursor" title="[예 3.6] 커서의 선언">[예 3.6]</a>에서 선언한 EMP-CUROSR라는
          이름의 커서에 OPEN을 실행하는 예이다.</p>

          <div class="example"><a id="d5e1726"/><p class="title"><b>[예 3.7] OPEN의 실행</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL OPEN EMP-CURSOR 
END-EXEC.</pre>
          </div></div><br class="example-break"/>
        </li><li>
          <p>FETCH를 실행해 로우에 액세스를 한다.<a id="d5e1731" class="indexterm"/></p>

          <p>OPEN의 실행으로는 아직 로우에 액세스를 할 수 있는 것은 아니다. 로우에 액세스를 하기 위해서는 FETCH를
          실행해야 한다. FETCH의 INTO 절에는 구조체 변수나 지시자 변수를 함께 사용할 수 있다.</p>

          <p>다음은 FETCH를 실행하는 예이다.</p>

          <div class="example"><a id="d5e1735"/><p class="title"><b>[예 3.8] FETCH의 실행</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL FETCH EMP-CURSOR
          INTO :ENAME, :SALARY, :ADDR
END-EXEC.</pre>
          </div></div><br class="example-break"/>

          <p>FETCH를 실행하면 먼저 커서가 다음 결과 로우를 가리키게 되고, 커서가 가리키는 결과 로우를 출력 변수에
          저장한다. FETCH를 실행할 때마다 커서는 다음 결과 로우를 가리키고, 결국 맨 마지막 결과 로우의 범위를 넘어
          FETCH를 실행하면, NOT FOUND 에러가 발생한다.</p>

          <p>대개의 경우 FETCH를 <span><strong class="guibutton">무한 루프</strong></span> 안에 포함시키며,
          <span><strong class="guibutton">NOT FOUND 에러</strong></span>가 발행하면 루프를 빠져 나오도록 코드를 작성한다. 이때
          NOT FOUND 에러가 발생했을 때 루프를 빠져 나오도록 하기 위해서는
          <span><strong class="guibutton">WHENEVER</strong></span> 문장을 사용한다.</p>

          <p>다음은 WHENEVER 문장을 사용하는 예이다.</p>

          <div class="example"><a id="d5e1744"/><p class="title"><b>[예 3.9] WHENEVER 문장의 사용</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL WHENEVER NOT FOUND GOTO FETCH-END END-EXEC. 
FETCH-LOOP. 
   EXEC SQL FETCH EMP-CURSOR 
            INTO :ENAME, :SALARY, :ADDR 
   END-EXEC. 
... 
   GO TO FETCH-LOOP. 
FETCH-END.</pre>
          </div></div><br class="example-break"/>

          <p>WHENEVER 문장에 GOTO 명령 이외에 DO CALL, DO PERFORM 등의 명령을 사용할 수도
          있다.</p>

          <p>OPEN을 사용해 커서를 열기 전이나 CLOSE를 사용해 커서를 닫은 후 또는 NOT FOUND 에러가 발생한
          이후에 FETCH를 실행하면 에러가 발생한다.</p>

          <p>FETCH를 이용해 다음 로우 뿐만 아니라 이전 로우를 액세스할 수도 있다. 이러한 작업을 위해서는 스크롤 가능
          커서를 선언해야 한다. 스크롤 가능 커서에 대해서는 <a href="ch03.html#sect_scrollable_cursor" title="3.5. 스크롤 가능 커서">“3.5. 스크롤 가능 커서”</a>를 참고한다.</p>
        </li><li>
          <p>커서 사용의 마지막 단계는 CLOSE를 사용해 커서를 닫는 것이다. 커서를 닫은 이후에는 그 커서에 대해 어떠한
          작업도 실행할 수 없다.</p>

          <p>다음은 EMP-CURSOR라는 이름의 커서에 CLOSE를 실행하는 예이다.</p>

          <div class="example"><a id="d5e1754"/><p class="title"><b>[예 3.10] CLOSE의 사용</b></p><div class="example-contents">
            

            

            <pre class="programlisting">EXEC SQL CLOSE EMP-CURSOR 
END-EXEC.</pre>
          </div></div><br class="example-break"/>
        </li></ol></div>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1757"/>3.4.2. CURRENT OF 절</h3></div></div></div>
      

      <p>커서를 이용해 SELECT 문장의 실행 결과 로우를 차례로 액세스하면서 커서가 현재 가리키고 있는 결과 로우를
      삭제하거나 갱신하려고 할 때 DELETE 문장과 UPDATE 문장에 <span><strong class="guibutton">CURRENT OF</strong></span>
      절을 사용한다.<a id="d5e1761" class="indexterm"/></p>

      <p>SELECT 문장에서 CURRENT OF 절을 사용하기 위해서는 FOR UPDATE 절을 포함해야 한다.
      <span><strong class="guibutton">FOR UPDATE</strong></span> 절은 질의 결과로 반환된 로우에 잠금(LOCK)을 설정한다. 잠금이
      설정된 로우는 현재 트랜잭션이 커밋 또는 롤백되기 전까지는 다른 트랜잭션이 로우를 갱신하거나 삭제할 수 없다.<a id="d5e1765" class="indexterm"/><a id="d5e1767" class="indexterm"/><a id="d5e1769" class="indexterm"/></p>

      <div class="literallayout"><p/></div>

      <p>다음은 UPDATE 문장에서 CURRENT OF 절을 이용하여 컬럼 SALARY만을 갱신하는 예이다.</p>

      <pre class="programlisting">EXEC SQL DECLARE EMP-CURSOR CURSOR FOR 
         SELECT ENAME, SALARY, ADDR 
         FROM EMP 
         WHERE DEPTNO = :DEPTNO 
         FOR UPDATE OF SALARY 
END-EXEC. 
... 
EXEC SQL OPEN CURSOR EMP-CURSOR END-EXEC. 
EXEC SQL WHENEVER NOT FOUND GOTO FETCH-END END-EXEC. 
FETCH-LOOP. 
   EXEC SQL FETCH EMP-CURSOR 
            INTO :ENAME, :SALARY, :ADDR 
   END-EXEC. 
   ... 
   EXEC SQL UPDATE EMP 
            SET SALARY = SALARY * 1.05<span><strong class="guibutton">
            WHERE CURRENT OF EMP-CURSOR</strong></span>
   END-EXEC. 
   ... 
   GO TO FETCH-LOOP. 
FETCH-END.</pre>

      <div class="literallayout"><p/></div>

      <p>커서가 현재 가리키고 있는 로우는 FETCH 문장을 실행하여 방금 전에 컬럼 값을 읽은 로우이다. 커서에 대해 OPEN
      문장을 실행한 후에 한번도 FETCH 문장을 실행하지 않았거나 모든 결과 로우를 읽고 나서 NOT FOUND 에러가 반환되었다면
      커서가 현재 가리키고 있는 로우는 없다.</p>

      <p>현재 가리키고 있는 로우가 없는 커서를 이용하여 DELETE 또는 UPDATE 문장을 실행하였다면 에러를 반환한다.
      또한 OPEN 문장을 수행하지 않았거나 CLOSE 문장을 이미 수행한 커서를 이용하여 삭제 또는 갱신을 시도할 때에도 에러를
      반환한다.</p>

      <p>CLOSE_ON_COMMIT 옵션이 'YES'로 지정된 경우를 제외하고는 일반적으로 커서는 현재 트랜잭션이 커밋 또는
      롤백한 후에도 사용할 수 있다. 즉, 커서를 이용하여 질의 결과 로우를 액세스할 수 있다. 하지만 FOR UPDATE 절을 포함한
      SELECT 문장에 대한 커서는 사용할 수 없다. 왜냐하면 트랜잭션이 커밋되거나 롤백되는 동시에 결과 로우에 설정되었던 잠금을
      해제해 버리기 때문이다.</p>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1779"/>3.4.3. 사용 예제</h3></div></div></div>
      

      <p>다음은 커서를 사용하는 예제 프로그램이다.</p>

      <div class="example"><a id="ex_using_cursor"/><p class="title"><b>[예 3.11] 커서의 사용</b></p><div class="example-contents">
        

        

        <pre class="programlisting">IDENTIFICATION                      DIVISION. 
************************************************************* 
PROGRAM-ID.                         TEST. 
************************************************************* 
ENVIRONMENT                         DIVISION. 
************************************************************* 
CONFIGURATION                       SECTION. 
* 
SOURCE-COMPUTER.                    TEST-MACHINE. 
OBJECT-COMPUTER.                    TEST-MACHINE. 
************************************************************* 
DATA                                DIVISION. 
************************************************************* 
WORKING-STORAGE                     SECTION.
<span><strong class="guibutton">
EXEC SQL BEGIN DECLARE SECTION END-EXEC.</strong></span><em class="lineannotation"><span class="lineannotation">... ① ...</span></em>
01 USERPASS PIC X(20) VALUE Z"<span>tibero</span>/<span>tmax</span>". 
01 ENAME    PIC X(24) VARYING. 
01 SALARY   PIC S9(5). 
01 ADDR     PIC X(32) VARYING. 
01 DEPTNO   PIC S9(9).<span><strong class="guibutton">
EXEC SQL END DECLARE SECTION END-EXEC.</strong></span>

EXEC SQL INCLUDE SQLCA END-EXEC. 
 
PROCEDURE             DIVISION. 
 
EXEC SQL DECLARE<span><strong class="guibutton"> EMP-CURSOR </strong></span>CURSOR FOR<em class="lineannotation"><span class="lineannotation">... ② ...</span></em>
         SELECT ENAME, SALARY, ADDR 
         FROM EMP 
         WHERE DEPTNO =<span><strong class="guibutton"> :DEPTNO</strong></span><em class="lineannotation"><span class="lineannotation">... ③ ...</span></em>
END-EXEC. 
 
EXEC SQL DECLARE<span><strong class="guibutton"> EMP-UPDATE-CURSOR</strong></span> CURSOR FOR<em class="lineannotation"><span class="lineannotation">... ④ ...</span></em>
         SELECT SALARY 
         FROM EMP 
         WHERE DEPTNO = <span><strong class="guibutton">:DEPTNO</strong></span><em class="lineannotation"><span class="lineannotation">... ⑤ ...</span></em>
         FOR UPDATE OF SALARY END-EXEC. 
 
EXEC SQL CONNECT :USERPASS END-EXEC. 
DISPLAY "Connected.". 
 
DISPLAY "Enter dept number to show: " 
ACCEPT DEPTNO. 
 
EXEC SQL OPEN EMP-CURSOR END-EXEC. 
EXEC SQL WHENEVER NOT FOUND GOTO FETCH-END END-EXEC. 
FETCH-LOOP. 
   EXEC SQL FETCH EMP-CURSOR 
            INTO :ENAME, :SALARY, :ADDR 
   END-EXEC. 
   DISPLAY 'ENAME = 'ENAME-ARR', SALARY = 'SALARY 
           ',ADDR = 'ADDR-ARR 
   GO TO FETCH-LOOP. 
FETCH-END. 
 
EXEC SQL CLOSE EMP-CURSOR END-EXEC. 
 
DISPLAY "Enter dept number to raise salary: " 
ACCEPT DEPTNO. 
 
EXEC SQL OPEN EMP-UPDATE-CURSOR END-EXEC. 
EXEC SQL WHENEVER NOT FOUND GOTO FETCH-UPDATE-END END-EXEC. 
FETCH-UPDATE-LOOP. 
   EXEC SQL FETCH EMP-UPDATE-CURSOR 
            INTO :SALARY 
   END-EXEC. 
   EXEC SQL UPDATE EMP 
            SET SALARY = :SALARY * 1.05 
            WHERE CURRENT OF EMP-UPDATE-CURSOR 
   END-EXEC. 
   GO TO FETCH-UPDATE-LOOP. 
FETCH-UPDATE-END. 
 
EXEC SQL CLOSE EMP-UPDATE-CURSOR END-EXEC. 
EXEC SQL<span><strong class="guibutton">COMMIT WORK RELEASE</strong></span> END-EXEC.<em class="lineannotation"><span class="lineannotation">... ⑥ ...</span></em></pre>
      </div></div><br class="example-break"/>

      <p>① <span>tbESQL</span>/COBOL 문장 내에 포함되는 모든 입/출력 변수는 DECLARE
      영역 안에서 선언한다. 프로그램의 맨 앞쪽에서 커서를 선언하고 있지만, 변수의 선언과는 달리 커서의 선언은 어떠한 위치에 오더라도
      상관없으며, 그 커서가 사용되기 전에만 선언되면 된다.</p>

      <p>②, ④ 두 개의 커서를 선언한다. 각각 단순 질의와 갱신을 위한 커서인데, 단순 질의를 위한 커서는
      EMP-CURSOR이고, 갱신을 위한 커서는 EMP-UPDATE-CURSOR이다.</p>

      <p>③, ⑤ 변수 DEPTNO가 두 개의 커서에 공통적으로 사용된다. 커서와 연관된 SELECT 문장은 OPEN 문장으로
      커서를 열 때 실행되며, 그 직전에 입력 변수의 값을 읽어 들인다. 따라서 같은 변수를 사용하더라도 각각의 SELECT 문장이
      실행될 때 서로 다른 DEPTNO 값이 적용될 수도 있다.</p>

      <p>⑥ 프로그램의 맨 마지막에서는 현재 트랜잭션을 커밋한다. 단순 질의를 위한 커서 EMP-CURSOR는 트랜잭션 커밋
      후에도 계속 사용할 수 있으나, 갱신을 위한 커서 EMP-UPDATE-CURSOR는 사용할 수 없다.</p>
    </div>
  </div>

  <div class="section" lang="ko"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sect_scrollable_cursor"/>3.5. 스크롤 가능 커서<a id="d5e1807" class="indexterm"/><a id="d5e1809" class="indexterm"/></h2></div></div></div>
    

    <p>본 절에서는 스크롤 가능 커서(Scrollable Cursors)의 사용 방법을 설명하고, 사용 예제를
    제시한다.</p>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1812"/>3.5.1. 사용 방법</h3></div></div></div>
      

      <p>커서는 질의의 결과 로우를 액세스할 때 항상 다음에 위치한 로우만 액세스할 수 있는 것에 비해,
      <span><strong class="guibutton">스크롤 가능 커서</strong></span>는 임의의 로우에 액세스를 할 수 있다. 예를 들어 스크롤 가능 커서는
      현재 커서가 가리키고 있는 로우의 바로 이전 로우를 액세스하거나 전체 결과 로우 중에서 n번째 로우를 액세스할 수
      있다.<a id="d5e1816" class="indexterm"/></p>

      <p>스크롤 가능 커서는 사용 방법의 편리성과 유연성을 제공하지만 커서와 비교했을 때 메모리 등의 리소스를 많이 사용할 수
      있으므로 프로그램의 실행 성능을 떨어뜨릴 수 있다. 따라서 꼭 필요한 경우가 아니라면 커서를 사용하는 것이
      효율적이다.</p>

      <div class="literallayout"><p/></div>

      <p>다음은 커서와 스크롤 가능 커서의 차이점이다.</p>

      <div class="informaltable">
        <table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>커서</th><th>스크롤 가능 커서</th></tr></thead><tbody><tr><td>다음 위치에 있는 로우만 차례대로 액세스를 한다.</td><td>임의의 위치에 있는 로우를 액세스할 수 있다.</td></tr><tr><td>'DECLARE {<span class="emphasis"><em>커서 이름</em></span>} CURSOR'의 형태로
              선언한다.</td><td>'DECLARE {<span class="emphasis"><em>커서 이름</em></span>} SCROLL CURSOR'의 형태로
              선언한다.</td></tr><tr><td>FETCH를 실행할 때 옵션을 지정할 수 없다.</td><td>FETCH를 실행할 때 반드시 옵션을 지정해야 한다.</td></tr></tbody></table>
      </div>

      <div class="literallayout"><p/></div>

      <p>스크롤 가능 커서에서도 커서와 동일하게 OPEN과 CLOSE를 사용한다. 스크롤 가능 커서가 현재 가리키고 있는 로우에
      대하여 삭제 및 갱신을 수행하고자 할 때에도 커서와 마찬가지로 DELETE 문장과 UPDATE 문장 내에서 CURRENT OF
      절을 이용한다. 문장의 작성 및 사용 방법은 커서와 동일하다.</p>

      <div class="literallayout"><p/></div>

      <p>커서와 스크롤 가능 커서의 차이점을 좀더 상세하게 설명하면 다음과 같다.</p>

      <div class="itemizedlist"><ul type="disc" compact="compact"><li>
          <p>스크롤 가능 커서의 선언</p>

          <p>스크롤 가능 커서의 선언은 <span><strong class="guibutton">SCROLL</strong></span> 키워드가 포함된다는 것을
          제외하면 커서의 선언과 동일하며 다음과 같은 형태로 선언한다.</p>

          <pre class="programlisting">DECLARE {<span class="emphasis"><em>커서 이름</em></span>} SCROLL CURSOR</pre>

          <p>다음의 소스 코드는 스크롤 가능 커서를 선언하는 예이다.</p>

          <pre class="programlisting">EXEC SQL<span><strong class="guibutton"> DECLARE</strong></span> EMP-SCROLL-CURSOR <span><strong class="guibutton">SCROLL CURSOR</strong></span> FOR 
         SELECT ENAME, SALARY, ADDR 
         FROM EMP 
         WHERE DEPTNO = :DEPTNO 
END-EXEC.</pre>
        </li><li>
          <p>스크롤 가능 커서에서의 FETCH의 사용</p>

          <p>스크롤 가능 커서에서 FETCH를 사용할 때는 항상 액세스할 대상 로우를 지정해야 한다.</p>

          <p>다음은 FETCH에서 액세스를 할 대상 로우를 지정할 때 사용되는 옵션이다.</p>

          <div class="informaltable">
            <table border="1"><colgroup><col width="120" align="left"/><col/></colgroup><thead><tr><th align="left">옵션</th><th>설명</th></tr></thead><tbody><tr><td align="left">NEXT</td><td>현재 커서가 가리키고 있는 로우의 다음 로우에 액세스를 한다. PRIOR 옵션과 반대이다.
                  (생략 가능)</td></tr><tr><td align="left">PRIOR</td><td>현재 커서가 가리키고 있는 로우의 이전 로우에 액세스를 한다. NEXT 옵션과
                  반대이다.</td></tr><tr><td align="left">FIRST</td><td>맨 처음에 위치한 로우에 액세스를 한다. LAST 옵션과 반대이다.</td></tr><tr><td align="left">LAST</td><td>맨 마지막에 위치한 로우에 액세스를 한다. FIRST 옵션과 반대이다.</td></tr><tr><td align="left">CURRENT</td><td>현재 로우에 액세스를 한다.</td></tr><tr><td align="left">RELATIVE offset</td><td>현재 커서가 가리키고 있는 로우의 다음 offset 번째에 위치한 로우에 액세스를 한다.
                  offset 값이 음수라면 커서가 현재 위치에서 앞으로 이동한다. 예를 들어 현재 커서가 8번째 로우를
                  가리키고 있는데, 'FETCH RELATIVE -3'을 실행한다면 커서는 5번째 로우를 가리키게
                  된다.</td></tr><tr><td align="left">ABSOLUTE offset</td><td>전체 로우 중에서 offset 번째 로우에 액세스를 한다.</td></tr></tbody></table>
          </div>

          <p>다음은 FETCH에 옵션을 사용하는 예이다.</p>

          <pre class="programlisting">EXEC SQL FETCH PRIOR EMP-SCROLL-CURSOR 
         INTO :ENAME, :SALARY, :ADDR 
END-EXEC. 
 
EXEC SQL FETCH LAST EMP-SCROLL-CURSOR 
         INTO :ENAME, :SALARY, :ADDR 
END-EXEC. 
 
EXEC SQL FETCH ABSOLUTE 3 EMP-SCROLL-CURSOR 
         INTO :ENAME, :SALARY, :ADDR 
END-EXEC.</pre>

          <p>위의 예에서는 각각 순서대로 첫 번째 문장은 이전 로우를 액세스하고, 두 번째 문장은 마지막 로우를 액세스한다.
          세 번째 문장은 전체 로우 중에서 세 번째 로우를 액세스하고 있다. 만약 액세스하려는 로우가 존재하지 않으면 NOT
          FOUND 에러가 반환된다.</p>
        </li></ul></div>

      <p/>

      <p/>
    </div>

    <div class="section" lang="ko"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1892"/>3.5.2. 사용 예제</h3></div></div></div>
      

      <p>다음은 스크롤 가능 커서를 사용하는 예제 프로그램이다.</p>

      <pre class="programlisting">IDENTIFICATION                      DIVISION. 
************************************************************* 
PROGRAM-ID.                         TEST. 
************************************************************* 
ENVIRONMENT                         DIVISION. 
************************************************************* 
CONFIGURATION                       SECTION. 
* 
SOURCE-COMPUTER.                    TEST-MACHINE. 
OBJECT-COMPUTER.                    TEST-MACHINE. 
************************************************************* 
DATA                                DIVISION. 
************************************************************* 
WORKING-STORAGE                     SECTION. 
 
EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
01 USERPASS PIC X(20) VALUE Z"<span>tibero</span>/<span>tmax</span>". 
01 ENAME    PIC X(24) VARYING. 
01 SALARY   PIC S9(5). 
01 ADDR     PIC X(32) VARYING. 
01 DEPTNO   PIC S9(9). 
EXEC SQL END DECLARE SECTION END-EXEC. 
 
EXEC SQL INCLUDE SQLCA END-EXEC. 
 
PROCEDURE             DIVISION. 
 
EXEC SQL DECLARE EMP-SCROLL-CURSOR SCROLL CURSOR FOR 
         SELECT ENAME, SALARY, ADDR 
         FROM EMP 
         WHERE DEPTNO = :DEPTNO 
END-EXEC. 
 
EXEC SQL CONNECT :USERPASS END-EXEC. 
DISPLAY "Connected.". 
MOVE 10 TO DEPTNO. 
 
EXEC SQL OPEN EMP-SCROLL-CURSOR END-EXEC. 
 
* 1st row 
 EXEC SQL FETCH FIRST EMP-SCROLL-CURSOR 
          INTO :ENAME, :SALARY, :ADDR 
 END-EXEC. 
* last row 
 EXEC SQL FETCH LAST EMP-SCROLL-CURSOR 
          INTO :ENAME, :SALARY, :ADDR 
 END-EXEC. 
* 5th row 
 EXEC SQL FETCH ABSOLUTE 5 EMP-SCROLL-CURSOR 
          INTO :ENAME, :SALARY, :ADDR 
 END-EXEC. 
* 8th row 
 EXEC SQL FETCH RELATIVE 3 EMP-SCROLL-CURSOR 
          INTO :ENAME, :SALARY, :ADDR 
 END-EXEC. 
* 7th row 
 EXEC SQL FETCH PRIOR EMP-SCROLL-CURSOR 
          INTO :ENAME, :SALARY, :ADDR 
 END-EXEC. 
* 7th row 
 EXEC SQL FETCH CURRENT EMP-SCROLL-CURSOR 
          INTO :ENAME, :SALARY, :ADDR 
 END-EXEC. 
* 4th row 
 EXEC SQL FETCH RELATIVE -3 EMP-SCROLL-CURSOR 
          INTO :ENAME, :SALARY, :ADDR 
       END-EXEC. 
* 5th row 
 EXEC SQL FETCH EMP-SCROLL-CURSOR 
          INTO :ENAME, :SALARY, :ADDR 
 END-EXEC. 
 
EXEC SQL CLOSE EMP-SCROLL-CURSOR END-EXEC. 
EXEC SQL COMMIT WORK RELEASE END-EXEC.</pre>

      <p>위의 예에서는 주석을 삽입하여, FETCH를 실행할 때마다 스크롤 가능 커서의 현재 위치를 설명하였다. 또한 질의 결과
      로우가 8개 이상임을 가정한다.</p>

      <p>SQL 문장 내에 포함되는 모든 입/출력 변수는 DECLARE 영역 안에서 선언하였다. 커서를 선언할 때와 마찬가지로
      스크롤 가능 커서를 선언하는 문장도, 스크롤 가능 커서가 사용되기 전이라면 어떤 위치에 있어도 상관없다.</p>
    </div>
  </div>
</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02.html">이전</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="chapter_array_variable.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">제2장 데이터 타입 </td><td width="20%" align="center"><a accesskey="h" href="index.html">처음으로</a></td><td width="40%" align="right" valign="top"> 제4장 배열 변수</td></tr></table></div><div xmlns="" align="center"/></body></html>